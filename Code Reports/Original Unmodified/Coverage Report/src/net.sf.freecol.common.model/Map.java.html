<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Map.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Map.java</span></div><h1>Map.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;
import java.util.HashMap;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.RandomUtils.*;
// @compat 0.10.x
import net.sf.freecol.server.generator.TerrainGenerator;
// end @compat 0.10.x


/**
 * A rectangular isometric map.  The map is represented as a
 * two-dimensional array of tiles.  Off-map destinations, such as
 * {@link Europe}, can be reached via the {@link HighSeas}.
 *
 * In theory, a {@link Game} might contain several Map instances
 * connected by the HighSeas.
 */
public class Map extends FreeColGameObject implements Location {

<span class="fc" id="L63">    private static final Logger logger = Logger.getLogger(Map.class.getName());</span>

    /**
     * Possible actions by the unit travelling along a path in consideration
     * of the next tile.
     */
<span class="fc" id="L69">    private static enum MoveStep { FAIL, BYLAND, BYWATER, EMBARK, DISEMBARK };</span>

    /**
     * The number of tiles from the upper edge that are considered
     * polar by default.
     */
    public final static int POLAR_HEIGHT = 2;

    /**
     * The layers included in the map. The RIVERS layer includes all
     * natural tile improvements that are not resources. The NATIVES
     * layer includes Lost City Rumours as well as settlements.
     */
<span class="fc" id="L82">    public static enum Layer {</span>
<span class="fc" id="L83">        NONE, LAND, TERRAIN, REGIONS, RIVERS, RESOURCES, NATIVES, ALL;</span>
    };

    /** A position on the Map. */
    public static final class Position {
        
        /** The coordinates of the position. */
        public final int x, y;


        /**
         * Creates a new &lt;code&gt;Position&lt;/code&gt; object with the given
         * coordinates.
         *
         * @param posX The x-coordinate for this position.
         * @param posY The y-coordinate for this position.
         */
<span class="fc" id="L100">        public Position(int posX, int posY) {</span>
<span class="fc" id="L101">            x = posX;</span>
<span class="fc" id="L102">            y = posY;</span>
<span class="fc" id="L103">        }</span>

        /**
         * Creates a new &lt;code&gt;Position&lt;/code&gt; object with the coordinates
         * of a supplied tile.
         *
         * @param tile The &lt;code&gt;Tile&lt;/code&gt; to extract coordinates from.
         */
        public Position(Tile tile) {
<span class="fc" id="L112">            this(tile.getX(), tile.getY());</span>
<span class="fc" id="L113">        }</span>

        /**
         * Creates a new &lt;code&gt;Position&lt;/code&gt; from an existing one with
         * an optional step in a given direction.
         *
         * @param start The starting &lt;code&gt;Position&lt;/code&gt;.
         * @param direction An optional &lt;code&gt;Direction&lt;/code&gt; to step.
         */
<span class="fc" id="L122">        public Position(Position start, Direction direction) {</span>
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            Position step = (direction == null) ? start</span>
<span class="fc" id="L124">                : direction.step(start.x, start.y);</span>
<span class="fc" id="L125">            this.x = step.x;</span>
<span class="fc" id="L126">            this.y = step.y;</span>
<span class="fc" id="L127">        }</span>


        /**
         * Gets the x-coordinate of this Position.
         *
         * @return The x-coordinate of this Position.
         */
        public int getX() {
<span class="fc" id="L136">            return x;</span>
        }

        /**
         * Gets the y-coordinate of this Position.
         *
         * @return The y-coordinate of this Position.
         */
        public int getY() {
<span class="fc" id="L145">            return y;</span>
        }

        /**
         * Checks whether a position is valid within a given map size.
         *
         * @param width The width of the map.
         * @param height The height of the map.
         * @return True if the given position is within the bounds of the map.
         */
        public boolean isValid(int width, int height) {
<span class="fc" id="L156">            return Map.isValid(x, y, width, height);</span>
        }

        /**
         * Gets the distance in tiles between two map positions.
         * With an isometric map this is a non-trivial task.
         * The formula below has been developed largely through trial and
         * error.  It should cover all cases, but I wouldn't bet my
         * life on it.
         *
         * @param ax The x-coordinate of the first position.
         * @param ay The y-coordinate of the first position.
         * @param bx The x-coordinate of the second position.
         * @param by The y-coordinate of the second position.
         * @return The distance in tiles between the positions.
         */
        public static int getDistance(int ax, int ay, int bx, int by) {
<span class="fc" id="L173">            int r = (bx - ax) - (ay - by) / 2;</span>

<span class="fc bfc" id="L175" title="All 6 branches covered.">            if (by &gt; ay &amp;&amp; ay % 2 == 0 &amp;&amp; by % 2 != 0) {</span>
<span class="fc" id="L176">                r++;</span>
<span class="fc bfc" id="L177" title="All 6 branches covered.">            } else if (by &lt; ay &amp;&amp; ay % 2 != 0 &amp;&amp; by % 2 == 0) {</span>
<span class="fc" id="L178">                r--;</span>
            }
<span class="fc" id="L180">            return Math.max(Math.abs(ay - by + r), Math.abs(r));</span>
        }

        /**
         * Gets the distance in tiles between two map positions.
         * With an isometric map this is a non-trivial task.
         * The formula below has been developed largely through trial and
         * error.  It should cover all cases, but I wouldn't bet my
         * life on it.
         *
         * @param position The other &lt;code&gt;Position&lt;/code&gt; to compare.
         * @return The distance in tiles to the other position.
         */
        public int getDistance(Position position) {
<span class="nc" id="L194">            return getDistance(getX(), getY(),</span>
<span class="nc" id="L195">                               position.getX(), position.getY());</span>
        }

        /**
         * Get the direction from this position to an adjacent position.
         *
         * @param other The adjacent &lt;code&gt;Position&lt;/code&gt;.
         * @return The &lt;code&gt;Direction&lt;/code&gt;, or null if not adjacent.
         */
        public Direction getDirection(Position other) {
<span class="fc" id="L205">            return find(Direction.values(),</span>
<span class="fc" id="L206">                d -&gt; new Position(this, d).equals(other), null);</span>
        }

        // Override Object

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean equals(Object o) {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (this == o) return true;</span>
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">            if (o instanceof Position) {</span>
<span class="fc" id="L218">                Position p = (Position)o;</span>
<span class="fc bfc" id="L219" title="All 4 branches covered.">                return x == p.x &amp;&amp; y == p.y;</span>
            }
<span class="nc" id="L221">            return false;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public int hashCode() {
<span class="nc" id="L229">            return x | (y &lt;&lt; 16);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L237">            return &quot;(&quot; + x + &quot;, &quot; + y + &quot;)&quot;;</span>
        }
    }


    /** The tiles that this map contains. */
    private Tile[][] tiles;

    /** The highest map layer included. */
    private Layer layer;

    /**
     * The latitude of the northern edge of the map. A negative value
     * indicates northern latitude, a positive value southern
     * latitude. Thus, -30 equals 30°N, and 40 equals 40°S.
     */
<span class="pc" id="L253">    private int minimumLatitude = -90;</span>

    /**
     * The latitude of the southern edge of the map. A negative value
     * indicates northern latitude, a positive value southern
     * latitude. Thus, -30 equals 30°N, and 40 equals 40°S.
     */
<span class="pc" id="L260">    private int maximumLatitude = 90;</span>

    /** Variable used to convert rows to latitude. */
    private float latitudePerRow;

    /** The regions on the map. */
<span class="pc" id="L266">    private final List&lt;Region&gt; regions = new ArrayList&lt;&gt;();</span>

    /** The search tracing status.  Do not serialize. */
<span class="pc" id="L269">    private boolean traceSearch = false;</span>


    /**
     * Create a new &lt;code&gt;Map&lt;/code&gt; from a collection of tiles.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param width The map width.
     * @param height The map height.
     */
    public Map(Game game, int width, int height) {
<span class="fc" id="L280">        super(game);</span>

<span class="fc" id="L282">        this.tiles = new Tile[width][height];</span>
<span class="fc" id="L283">        setLayer(Layer.RESOURCES);</span>
<span class="fc" id="L284">        calculateLatitudePerRow();</span>
<span class="fc" id="L285">    }</span>

    /**
     * Create a new &lt;code&gt;Map&lt;/code&gt; from an input stream.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param xr The input stream containing the XML.
     * @throws XMLStreamException if a problem was encountered during parsing.
     */
    public Map(Game game, FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L295">        super(game, null);</span>

<span class="nc" id="L297">        readFromXML(xr);</span>
<span class="nc" id="L298">    }</span>

    /**
     * Creates a new &lt;code&gt;Map&lt;/code&gt; with the given object identifier.
     *
     * The object should be initialized later.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param id The object identifier.
     */
    public Map(Game game, String id) {
<span class="fc" id="L309">        super(game, id);</span>
<span class="fc" id="L310">    }</span>


    /**
     * Checks if an (x,y) coordinate tuple is within a map of
     * specified width and height.
     *
     * @param x The x-coordinate of the position.
     * @param y The y-coordinate of the position.
     * @param width The width of the map.
     * @param height The height of the map.
     * @return True if the given position is within the bounds of the map.
     */
    public static boolean isValid(int x, int y, int width, int height) {
<span class="fc bfc" id="L324" title="All 8 branches covered.">        return x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height;</span>
    }

    /**
     * Checks whether a position is valid (within the map limits).
     *
     * @param x The X coordinate to check.
     * @param y The Y coordinate to check.
     * @return True if the coordinates are valid.
     */
    public boolean isValid(int x, int y) {
<span class="fc" id="L335">        return isValid(x, y, getWidth(), getHeight());</span>
    }

    /**
     * Checks whether a position is valid (within the map limits).
     *
     * @param position The &lt;code&gt;Position&lt;/code&gt; to check.
     * @return True if the position is valid.
     */
    public boolean isValid(Position position) {
<span class="fc" id="L345">        return isValid(position.getX(), position.getY());</span>
    }

    /**
     * Gets the Tile at position (x, y).  'x' specifies a column and
     * 'y' specifies a row.  (0, 0) is the Tile at the top-left corner
     * of the Map.
     *
     * @param x The x-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
     * @param y The y-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
     * @return The &lt;code&gt;Tile&lt;/code&gt; at (x, y), or null if the
     *     position is invalid.
     */
    public Tile getTile(int x, int y) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        return (isValid(x, y)) ? tiles[x][y] : null;</span>
    }

    /**
     * Gets the Tile at a requested position.
     *
     * @param p The &lt;code&gt;Position&lt;/code&gt; to query.
     * @return The &lt;code&gt;Tile&lt;/code&gt; at the given position.
     */
    public Tile getTile(Position p) {
<span class="fc" id="L369">        return getTile(p.getX(), p.getY());</span>
    }

    /**
     * Sets the tile at the given coordinates.
     *
     * @param x The x-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
     * @param y The y-coordinate of the &lt;code&gt;Tile&lt;/code&gt;.
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to set.
     */
    public void setTile(Tile tile, int x, int y) {
<span class="fc" id="L380">        tiles[x][y] = tile;</span>
<span class="fc" id="L381">    }</span>

    /**
     * Gets the width of this map.
     *
     * @return The width of this map.
     */
    public int getWidth() {
<span class="fc" id="L389">        return tiles.length;</span>
    }

    /**
     * Gets the height of this map.
     *
     * @return The height of this map.
     */
    public int getHeight() {
<span class="fc" id="L398">        return tiles[0].length;</span>
    }

    public final Layer getLayer() {
<span class="nc" id="L402">        return layer;</span>
    }

    public final void setLayer(final Layer newLayer) {
<span class="fc" id="L406">        this.layer = newLayer;</span>
<span class="fc" id="L407">    }</span>

    /**
     * Gets the &lt;code&gt;MinimumLatitude&lt;/code&gt; value.
     *
     * @return The minimum latitude of this map.
     */
    public final int getMinimumLatitude() {
<span class="nc" id="L415">        return minimumLatitude;</span>
    }

    public final void setMinimumLatitude(final int newMinimumLatitude) {
<span class="fc" id="L419">        this.minimumLatitude = newMinimumLatitude;</span>
<span class="fc" id="L420">        calculateLatitudePerRow();</span>
<span class="fc" id="L421">    }</span>

    /**
     * Gets the &lt;code&gt;MaximumLatitude&lt;/code&gt; value.
     *
     * @return The maximum latitude of this map.
     */
    public final int getMaximumLatitude() {
<span class="nc" id="L429">        return maximumLatitude;</span>
    }

    public final void setMaximumLatitude(final int newMaximumLatitude) {
<span class="fc" id="L433">        this.maximumLatitude = newMaximumLatitude;</span>
<span class="fc" id="L434">        calculateLatitudePerRow();</span>
<span class="fc" id="L435">    }</span>

    /**
     * Gets the &lt;code&gt;LatitudePerRow&lt;/code&gt; value.
     *
     * @return The latitude change between rows.
     */
    public final float getLatitudePerRow() {
<span class="fc" id="L443">        return latitudePerRow;</span>
    }

    private final void calculateLatitudePerRow() {
<span class="fc" id="L447">        this.latitudePerRow = 1f * (maximumLatitude - minimumLatitude) /</span>
<span class="fc" id="L448">            (getHeight() - 1);</span>
<span class="fc" id="L449">    }</span>

    /**
     * Gets the latitude of the given map row.
     *
     * @param row The row to check.
     * @return The row latitude.
     */
    public int getLatitude(int row) {
<span class="fc" id="L458">        return minimumLatitude + (int) (row * latitudePerRow);</span>
    }

    /**
     * Gets the map row with the given latitude.
     *
     * @param latitude The latitude to find.
     * @return The row closest to the supplied latitude.
     */
    public int getRow(int latitude) {
<span class="fc" id="L468">        return (int) ((latitude - minimumLatitude) / latitudePerRow);</span>
    }

    /**
     * Gets the regions in this map.
     *
     * @return All the regions in this map.
     */
    public Collection&lt;Region&gt; getRegions() {
<span class="fc" id="L477">        return regions;</span>
    }

    /**
     * Get the fixed regions indexed by key.
     *
     * @return A map of the fixed regions.
     */
    public java.util.Map&lt;String, Region&gt; getFixedRegions() {
<span class="fc" id="L486">        HashMap&lt;String, Region&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        for (Region r : getRegions()) {</span>
<span class="fc" id="L488">            String n = r.getKey();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (n != null) result.put(n, r);</span>
        }
<span class="fc" id="L491">        return result;</span>
    }

    /**
     * Gets a &lt;code&gt;Region&lt;/code&gt; by name key.
     *
     * @param key The name key to lookup the region with.
     * @return The region with the given name key, or null if not found.
     */
    public Region getRegionByKey(final String key) {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        return (key == null) ? null</span>
<span class="fc" id="L502">            : find(getRegions(), r -&gt; key.equals(r.getKey()));</span>
    }

    /**
     * Gets a &lt;code&gt;Region&lt;/code&gt; by name.
     *
     * @param name The region name.
     * @return The &lt;code&gt;Region&lt;/code&gt; with the given name, or null if
     *     not found.
     */
    public Region getRegionByName(final String name) {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        return (name == null) ? null</span>
<span class="nc" id="L514">            : find(getRegions(), r -&gt; name.equals(r.getName()));</span>
    }

    /**
     * Adds a region to this map.
     *
     * @param region The &lt;code&gt;Region&lt;/code&gt; to add.
     */
    public void addRegion(final Region region) {
<span class="fc" id="L523">        regions.add(region);</span>
<span class="fc" id="L524">    }</span>


    /**
     * Are two locations non-null and either the same or at the same tile.
     * This routine is here because Location is an interface.
     *
     * @param l1 The first &lt;code&gt;Location&lt;/code&gt;.
     * @param l2 The second &lt;code&gt;Location&lt;/code&gt;.
     * @return True if the locations are the same or at the same tile.
     */
    public static final boolean isSameLocation(Location l1, Location l2) {
<span class="pc bpc" id="L536" title="2 of 4 branches missed.">        return (l1 == null || l2 == null) ? false</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">            : (l1 == l2) ? true</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">            : (l1.getTile() == null) ? false</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">            : l1.getTile() == l2.getTile();</span>
    }

    /**
     * Are two locations at least in the same contiguous land/sea-mass?
     * This routine is here because Location is an interface.
     *
     * @param l1 The first &lt;code&gt;Location&lt;/code&gt;.
     * @param l2 The second &lt;code&gt;Location&lt;/code&gt;.
     * @return True if the locations are the same or in the same land/sea-mass.
     */
    public static final boolean isSameContiguity(Location l1, Location l2) {
<span class="pc bpc" id="L551" title="2 of 4 branches missed.">        return (l1 == null || l2 == null) ? false</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">            : (l1 == l2) ? true</span>
<span class="pc bpc" id="L553" title="2 of 4 branches missed.">            : (l1.getTile() == null || l2.getTile() == null) ? false</span>
<span class="fc" id="L554">            : l1.getTile().isConnectedTo(l2.getTile());</span>
    }            

    /**
     * Is a tile in the map in a polar region?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to examine.
     * @return True if the tile is in a polar region.
     */
    public boolean isPolar(Tile tile) {
<span class="fc bfc" id="L564" title="All 4 branches covered.">        return tile.getY() &lt;= POLAR_HEIGHT</span>
<span class="fc" id="L565">            || tile.getY() &gt;= getHeight() - POLAR_HEIGHT - 1;</span>
    }

    /**
     * Gets the direction a unit needs to move in
     * order to get from &lt;code&gt;t1&lt;/code&gt; to &lt;code&gt;t2&lt;/code&gt;
     *
     * @param t1 The tile to move from.
     * @param t2 The target tile if moving from &lt;code&gt;t1&lt;/code&gt;
     *      in the direction returned by this method.
     * @return The direction you need to move from &lt;code&gt;t1&lt;/code&gt;
     *      in order to reach &lt;code&gt;t2&lt;/code&gt;, or null if the two
     *      specified tiles are not neighbours.
     */
    public Direction getDirection(Tile t1, Tile t2) {
<span class="pc bpc" id="L580" title="2 of 4 branches missed.">        return (t1 == null || t2 == null) ? null</span>
<span class="fc" id="L581">            : new Position(t1).getDirection(new Position(t2));</span>
    }

    /**
     * Get the approximate direction from one tile to another.
     *
     * @param src The source &lt;code&gt;Tile&lt;/code&gt;.
     * @param dst The destination &lt;code&gt;Tile&lt;/code&gt;.
     * @return The approximate direction from source to direction, or null
     *     if source and destination are the same.
     */
    public static Direction getRoughDirection(Tile src, Tile dst) {
<span class="fc" id="L593">        int x = dst.getX() - src.getX();</span>
<span class="fc" id="L594">        int y = dst.getY() - src.getY();</span>
<span class="pc bpc" id="L595" title="1 of 4 branches missed.">        if (x == 0 &amp;&amp; y == 0) return null;</span>
<span class="fc" id="L596">        double theta = Math.atan2(y, x) + Math.PI/2 + Math.PI/8;</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        if (theta &lt; 0) theta += 2 * Math.PI;</span>
<span class="fc" id="L598">        return Direction.angleToDirection(theta);</span>
    }

    /**
     * Gets the adjacent tile in a given direction from the given coordinates.
     *
     * @param x The x coordinate to work from.
     * @param y The y coordinate to work from.
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; to check.
     * @return The adjacent &lt;code&gt;Tile&lt;/code&gt; in the specified
     *     direction, or null if invalid.
     */
    public Tile getAdjacentTile(int x, int y, Direction direction) {
<span class="fc" id="L611">        return getTile(direction.step(x, y));</span>
    }

    /**
     * Gets the adjacent tile in a given direction from a given tile.
     *
     * @param tile The starting &lt;code&gt;Tile&lt;/code&gt;.
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; to check.
     * @return The adjacent &lt;code&gt;Tile&lt;/code&gt; in the specified
     *     direction, or null if invalid.
     */
    public Tile getAdjacentTile(Tile tile, Direction direction) {
<span class="fc" id="L623">        return getAdjacentTile(tile.getX(), tile.getY(), direction);</span>
    }

    /**
     * Gets the distance between two tiles.
     *
     * @param t1 The first &lt;code&gt;Tile&lt;/code&gt;.
     * @param t2 The second &lt;code&gt;Tile&lt;/code&gt;.
     * @return The distance between the tiles.
     */
    public int getDistance(Tile t1, Tile t2) {
<span class="fc" id="L634">        return Position.getDistance(t1.getX(), t1.getY(),</span>
<span class="fc" id="L635">                                    t2.getX(), t2.getY());</span>
    }

    /**
     * Get the closest tile to a given one from a list of other tiles.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to start from.
     * @param tiles The list of &lt;code&gt;Tile&lt;/code&gt;s to check.
     * @return The closest tile found (may be null if the list is empty).
     */
    public Tile getClosestTile(Tile tile, Collection&lt;Tile&gt; tiles) {
<span class="nc" id="L646">        Tile result = null;</span>
<span class="nc" id="L647">        int minimumDistance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        for (Tile t : tiles) {</span>
<span class="nc" id="L649">            int distance = getDistance(t, tile);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (distance &lt; minimumDistance) {</span>
<span class="nc" id="L651">                minimumDistance = distance;</span>
<span class="nc" id="L652">                result = t;</span>
            }
        }
<span class="nc" id="L655">        return result;</span>
    }

    /**
     * Select a random land tile on the map.
     *
     * @param random A &lt;code&gt;Random&lt;/code&gt; number source.
     * @return A random land tile, or null if none found.
     */
    public Tile getRandomLandTile(Random random) {
<span class="fc" id="L665">        final int SLOSH = 10;</span>
<span class="fc" id="L666">        int x = 0, y = 0, width = getWidth(), height = getHeight();</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (width &gt;= SLOSH) {</span>
<span class="fc" id="L668">            width -= SLOSH;</span>
<span class="fc" id="L669">            x += SLOSH/2;</span>
        }
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">        if (height &gt;= SLOSH) {</span>
<span class="fc" id="L672">            height -= SLOSH;</span>
<span class="fc" id="L673">            y += SLOSH/2;</span>
        }
<span class="fc" id="L675">        x += randomInt(logger, &quot;W&quot;, random, width);</span>
<span class="fc" id="L676">        y += randomInt(logger, &quot;H&quot;, random, height);</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        for (Tile t : getCircleTiles(getTile(x, y), true, INFINITY)) {</span>
<span class="fc bfc" id="L678" title="All 2 branches covered.">            if (t.isLand()) return t;</span>
        }
<span class="nc" id="L680">        return null;</span>
    }


    // Path-finding/searching infrastructure and routines

    /**
     * Simple interface to supply a heuristic to the A* routine.
     */
    private interface SearchHeuristic {
        int getValue(Tile tile);
    }

    /**
     * Gets a search heuristic using the Manhatten distance to an end tile.
     *
     * @param endTile The &lt;code&gt;Tile&lt;/code&gt; to aim for.
     * @return A new &lt;code&gt;SearchHeuristic&lt;/code&gt; aiming for the end tile.
     */
    private SearchHeuristic getManhattenHeuristic(Tile endTile) {
<span class="fc" id="L700">        return (Tile tile) -&gt; tile.getDistanceTo(endTile);</span>
    }

    /**
     * Unified argument tests for full path searches, which then finds
     * the actual starting location for the path.  Deals with special
     * cases like starting on a carrier and/or high seas.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
     * @param start The &lt;code&gt;Location&lt;/code&gt; in which the path starts from.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @return The actual starting location.
     * @throws IllegalArgumentException If there are any argument problems.
     */
    private Location findRealStart(final Unit unit, final Location start,
                                   final Unit carrier) {
        // Unit checks.
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        if (unit == null) {</span>
<span class="nc" id="L718">            throw new IllegalArgumentException(&quot;Null unit.&quot;);</span>
<span class="pc bpc" id="L719" title="1 of 4 branches missed.">        } else if (carrier != null &amp;&amp; !carrier.canCarryUnits()) {</span>
<span class="nc" id="L720">            throw new IllegalArgumentException(&quot;Non-carrier carrier: &quot;</span>
<span class="nc" id="L721">                + carrier);</span>
<span class="pc bpc" id="L722" title="1 of 4 branches missed.">        } else if (carrier != null &amp;&amp; !carrier.couldCarry(unit)) {</span>
<span class="nc" id="L723">            throw new IllegalArgumentException(&quot;Carrier could not carry unit: &quot;</span>
<span class="nc" id="L724">                + carrier + &quot;/&quot; + unit);</span>
        }

        Location entry;
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (start == null) {</span>
<span class="nc" id="L729">            throw new IllegalArgumentException(&quot;Null start: &quot; + unit);</span>
<span class="fc bfc" id="L730" title="All 2 branches covered.">        } else if (start instanceof Unit) {</span>
<span class="fc" id="L731">            Location unitLoc = ((Unit)start).getLocation();</span>
<span class="pc bpc" id="L732" title="1 of 2 branches missed.">            if (unitLoc == null) {</span>
<span class="nc" id="L733">                throw new IllegalArgumentException(&quot;Null on-carrier start: &quot;</span>
<span class="nc" id="L734">                    + unit + &quot;/&quot; + start);</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">            } else if (unitLoc instanceof HighSeas) {</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">                if (carrier == null) {</span>
<span class="nc" id="L737">                    throw new IllegalArgumentException(&quot;Null carrier when&quot;</span>
<span class="nc" id="L738">                        + &quot; starting on high seas: &quot; + unit);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">                } else if (carrier != start) {</span>
<span class="nc" id="L740">                    throw new IllegalArgumentException(&quot;Wrong carrier when&quot;</span>
<span class="nc" id="L741">                        + &quot; starting on high seas: &quot; + unit</span>
<span class="nc" id="L742">                        + &quot;/&quot; + carrier + &quot; != &quot; + start);</span>
                }
<span class="nc" id="L744">                entry = carrier.resolveDestination();</span>
<span class="nc" id="L745">            } else {</span>
<span class="fc" id="L746">                entry = unitLoc;</span>
            }
            
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">        } else if (start instanceof HighSeas) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (unit.isOnCarrier()) {</span>
<span class="nc" id="L751">                entry = unit.getCarrier().resolveDestination();</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">            } else if (unit.isNaval()) {</span>
<span class="nc" id="L753">                entry = unit.resolveDestination();</span>
<span class="nc" id="L754">            } else {</span>
<span class="nc" id="L755">                throw new IllegalArgumentException(&quot;No carrier when&quot;</span>
<span class="nc" id="L756">                    + &quot; starting on high seas: &quot; + unit</span>
<span class="nc" id="L757">                    + &quot;/&quot; + unit.getLocation());</span>
            }
<span class="pc bpc" id="L759" title="1 of 4 branches missed.">        } else if (start instanceof Europe || start.getTile() != null) {</span>
<span class="fc" id="L760">            entry = start; // OK</span>
<span class="fc" id="L761">        } else {</span>
<span class="nc" id="L762">            throw new IllegalArgumentException(&quot;Invalid start: &quot; + start);</span>
        }
        // Valid result, reduce to tile if possible.
<span class="fc bfc" id="L765" title="All 2 branches covered.">        return (entry.getTile() != null) ? entry.getTile() : entry;</span>
    }

    /**
     * Destination argument test for path searches.  Find the actual
     * destination of a path.
     *
     * @param unit An optional &lt;code&gt;Unit&lt;/code&gt; to search for.
     * @param end The candidate end &lt;code&gt;Location&lt;/code&gt;.
     * @return The actual end location.
     * @throws IllegalArgumentException If there are any argument problems.
     */
    private Location findRealEnd(Unit unit, Location end) {
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">        if (end == null) {</span>
<span class="nc" id="L779">            throw new IllegalArgumentException(&quot;Null end.&quot;);</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">        } else if (end instanceof Europe) {</span>
<span class="fc" id="L781">            return end;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        } else if (end instanceof Map) {</span>
<span class="nc" id="L783">            return findRealEnd(unit, unit.getEntryLocation());</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        } else if (end.getTile() != null) {</span>
<span class="fc" id="L785">            return end.getTile();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        } else if (unit != null) {</span>
<span class="nc" id="L787">            return unit.resolveDestination();</span>
        } else {
<span class="nc" id="L789">            throw new IllegalArgumentException(&quot;Invalid end: &quot; + end);</span>
        }
    }

    /**
     * Gets the best (closest) path location for this unit to reach a
     * given tile from off the map.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to check.
     * @param tile The target &lt;code&gt;Tile&lt;/code&gt;.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt;to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; to use.
     * @return A path to the best entry location tile to arrive on the
     *     map at, or null if none found.
     */
    private PathNode getBestEntryPath(Unit unit, Tile tile, Unit carrier,
                                      CostDecider costDecider) {
<span class="fc" id="L806">        return searchMap(unit, tile, GoalDeciders.getHighSeasGoalDecider(),</span>
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">            ((costDecider != null) ? costDecider</span>
<span class="fc" id="L808">                : CostDeciders.avoidSettlementsAndBlockingUnits()),</span>
<span class="fc" id="L809">            INFINITY, carrier, null, null);</span>
    }

    /**
     * Gets the best (closest) entry location for this unit to reach a
     * given tile from off the map.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to check.
     * @param tile The target &lt;code&gt;Tile&lt;/code&gt;.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt;to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; to use.
     * @return The best entry location tile to arrive on the map at, or null
     *     if none found.
     */
    public Tile getBestEntryTile(Unit unit, Tile tile, Unit carrier,
                                 CostDecider costDecider) {
<span class="nc" id="L825">        PathNode path = getBestEntryPath(unit, tile, carrier, costDecider);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        return (path == null) ? null : path.getLastNode().getTile();</span>
    }

    /**
     * Find the quickest path for a unit (with optional carrier) from
     * a start tile to an end tile.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
     * @param start The &lt;code&gt;Tile&lt;/code&gt; in which the path starts from.
     * @param end The &lt;code&gt;Tile&lt;/code&gt; at the end of the path.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return A path starting at the start tile and ending at the end
     *     tile, or null if none found.
     */
    private PathNode findMapPath(Unit unit, Tile start, Tile end, Unit carrier,
                                 CostDecider costDecider, LogBuilder lb) {
<span class="fc bfc" id="L846" title="All 2 branches covered.">        final Unit offMapUnit = (carrier != null) ? carrier</span>
<span class="pc bpc" id="L847" title="1 of 4 branches missed.">            : (unit != null &amp;&amp; unit.isNaval()) ? unit</span>
<span class="fc" id="L848">            : null;</span>
<span class="fc" id="L849">        final GoalDecider gd = GoalDeciders.getLocationGoalDecider(end);</span>
<span class="fc" id="L850">        final SearchHeuristic sh = getManhattenHeuristic(end);</span>
        Unit embarkTo;

        PathNode path;
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (start.getContiguity() == end.getContiguity()) {</span>
            // If the unit potentially could get to the destination
            // without a carrier, compare both with-carrier and
            // without-carrier paths.  The latter will usually be
            // faster, but not always, e.g. mounted units on a good
            // road system.
<span class="fc" id="L860">            path = searchMap(unit, start, gd, costDecider,</span>
<span class="fc" id="L861">                             INFINITY, null, sh, lb);</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">            PathNode carrierPath = (carrier == null) ? null</span>
<span class="fc" id="L863">                : searchMap(unit, start, gd, costDecider,</span>
<span class="fc" id="L864">                            INFINITY, carrier, sh, lb);</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">            if (carrierPath != null</span>
<span class="pc bpc" id="L866" title="1 of 2 branches missed.">                &amp;&amp; (path == null</span>
<span class="fc" id="L867">                    || (path.getLastNode().getCost()</span>
<span class="fc bfc" id="L868" title="All 2 branches covered.">                        &gt; carrierPath.getLastNode().getCost()))) {</span>
<span class="fc" id="L869">                path = carrierPath;</span>
            }

<span class="fc bfc" id="L872" title="All 2 branches covered.">        } else if (offMapUnit != null) {</span>
            // If there is an off-map unit then complex paths which
            // use settlements and inland lakes are possible, but hard
            // to capture with the contiguity test, so just allow the
            // search to proceed.
<span class="fc" id="L877">            path = searchMap(unit, start, gd, costDecider,</span>
<span class="fc" id="L878">                             INFINITY, carrier, sh, lb);</span>

<span class="pc bpc" id="L880" title="2 of 4 branches missed.">        } else if (unit != null &amp;&amp; unit.isOnCarrier()</span>
<span class="nc bnc" id="L881" title="All 4 branches missed.">            &amp;&amp; !start.isLand() &amp;&amp; end.isLand()</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">            &amp;&amp; !start.getContiguityAdjacent(end.getContiguity()).isEmpty()) {</span>
            // Special case where a land unit is trying to move off a
            // ship to adjacent land.
<span class="nc" id="L885">            path = searchMap(unit, start, gd, costDecider, INFINITY,</span>
<span class="nc" id="L886">                             carrier, sh, lb);</span>

<span class="pc bpc" id="L888" title="2 of 4 branches missed.">        } else if (start.isLand() &amp;&amp; !end.isLand()</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">            &amp;&amp; end.getFirstUnit() != null</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            &amp;&amp; !end.getContiguityAdjacent(start.getContiguity()).isEmpty()</span>
<span class="nc bnc" id="L891" title="All 4 branches missed.">            &amp;&amp; unit != null &amp;&amp; unit.getOwner().owns(end.getFirstUnit())</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            &amp;&amp; (embarkTo = end.getCarrierForUnit(unit)) != null) {</span>
            // Special case where a land unit is trying to move from
            // land to an adjacent ship.
<span class="nc" id="L895">            path = searchMap(unit, start,</span>
<span class="nc" id="L896">                GoalDeciders.getAdjacentLocationGoalDecider(end), costDecider,</span>
<span class="nc" id="L897">                INFINITY, null, null, lb);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (path != null) {</span>
<span class="nc" id="L899">                PathNode last = path.getLastNode();</span>
<span class="nc" id="L900">                last.next = new PathNode(embarkTo, 0, last.getTurns()+1, true,</span>
<span class="nc" id="L901">                                         last, null);</span>
            }
<span class="nc" id="L903">        } else { // Otherwise, there is a connectivity failure.</span>
<span class="fc" id="L904">            path = null;</span>
        }
<span class="fc" id="L906">        return path;</span>
    }

    /**
     * Finish processing a path.
     *
     * @param path The &lt;code&gt;PathNode&lt;/code&gt; to finish.
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is travelling along the path.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     */
    private void finishPath(PathNode path, Unit unit, LogBuilder lb) {
<span class="fc bfc" id="L917" title="All 2 branches covered.">        if (path != null) {</span>
            // Add the turns remaining on the high seas.
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">            final int initialTurns = (!unit.isAtSea()) ? 0</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                : ((unit.isOnCarrier()) ? unit.getCarrier() : unit)</span>
<span class="nc" id="L921">                .getWorkLeft();</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">            if (initialTurns != 0) path.addTurns(initialTurns);</span>

<span class="pc bpc" id="L924" title="1 of 2 branches missed.">            if (lb != null) {</span>
<span class="nc" id="L925">                lb.add(&quot;\nSuccess\n&quot;, path.fullPathToString());</span>
            }
        }
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">        if (lb != null) lb.log(logger, Level.INFO);</span>
<span class="fc" id="L929">    }</span>
        
    /**
     * Find the quickest path for a unit (with optional carrier) from
     * a start location to an end location.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find the path for.
     * @param start The &lt;code&gt;Location&lt;/code&gt; in which the path starts from.
     * @param end The &lt;code&gt;Location&lt;/code&gt; at the end of the path.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return A path starting at the start location and ending at the
     *     end location, or null if none found.
     * @throws IllegalArgumentException For many reasons, see
     *     {@link #findRealStart}.
     */
    public PathNode findPath(final Unit unit,
                             final Location start, final Location end,
                             final Unit carrier, CostDecider costDecider,
                             LogBuilder lb) {
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">        if (traceSearch) lb = new LogBuilder(1024);</span>

        // Validate the arguments, reducing to either Europe or a Tile.
<span class="fc" id="L955">        final Location realStart = findRealStart(unit, start, carrier);</span>
        final Location realEnd;
        try {
<span class="fc" id="L958">            realEnd = findRealEnd(unit, end);</span>
<span class="pc" id="L959">        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L960">            throw new IllegalArgumentException(&quot;Path fail: &quot; + unit</span>
<span class="nc" id="L961">                + &quot; from &quot; + start + &quot; to &quot; + end + &quot; with &quot; + carrier, iae);</span>
        }
        // Get the unit that will be used for off-map travel.
<span class="fc bfc" id="L964" title="All 2 branches covered.">        final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>

        PathNode p, path;
        Tile tile;
<span class="pc bpc" id="L968" title="1 of 4 branches missed.">        if (realEnd instanceof Tile &amp;&amp; !((Tile)realEnd).isExplored()) {</span>
            // Do not allow finding a path into unexplored territory,
            // as we do not have the terrain type and thus can not
            // calculate costs, but relent if the unexplored tile borders
            // an explored one on the same contiguity.
<span class="nc bnc" id="L973" title="All 2 branches missed.">            Tile closest = (realStart instanceof Tile)</span>
<span class="nc" id="L974">                ? getClosestTile((Tile)realStart,</span>
<span class="nc" id="L975">                    toList(((Tile)realEnd).getSurroundingTiles(1, 1).stream()</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">                        .filter(t -&gt; t.isExplored()</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">                            &amp;&amp; isSameContiguity(t, realStart))))</span>
<span class="nc" id="L978">                : null;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            path = (closest == null) ? null</span>
<span class="nc" id="L980">                : findPath(unit, realStart, closest, carrier, costDecider, lb);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (path != null) {</span>
<span class="nc" id="L982">                PathNode last = path.getLastNode();</span>
<span class="nc" id="L983">                last.next = new PathNode((Tile)realEnd, 0,</span>
<span class="nc" id="L984">                    last.getTurns()+1, last.isOnCarrier(), last, null);</span>
            }

<span class="pc bfc" id="L987" title="All 4 branches covered.">        } else if (realStart instanceof Europe &amp;&amp; realEnd instanceof Europe) {</span>
            // 0: Europe-&gt;Europe: Create a trivial path.
<span class="fc" id="L989">            path = new PathNode(realStart, unit.getMovesLeft(), 0,</span>
<span class="fc" id="L990">                                false, null, null);</span>

<span class="pc bpc" id="L992" title="1 of 4 branches missed.">        } else if (realStart instanceof Europe &amp;&amp; realEnd instanceof Tile) {</span>
            // 1: Europe-&gt;Tile
            // Fail fast without an off map unit.
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">            if (offMapUnit == null</span>
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">                || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L997">                path = null;</span>

            // Find the best place to enter the map from Europe
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">            } else if ((p = getBestEntryPath(unit, (Tile)realEnd, carrier,</span>
<span class="fc" id="L1001">                                             costDecider)) == null) {</span>
<span class="nc" id="L1002">                path = null;</span>

            // Now search forward from there to get a path in the
            // right order (path costs are not symmetric).  There are
            // &quot;expected&quot; failures when rivers block due to foreign
            // ship movement.  There are also other failures which we
            // would like to log.  Try to filter out the first case.
<span class="pc bpc" id="L1009" title="1 of 2 branches missed.">            } else if ((path = findMapPath(unit,</span>
<span class="fc" id="L1010">                        (tile = p.getLastNode().getTile()), (Tile)realEnd,</span>
<span class="fc" id="L1011">                        carrier, costDecider, lb)) == null) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                if (!((Tile)realEnd).isOnRiver()) {</span>
<span class="nc" id="L1013">                    LogBuilder l2 = new LogBuilder(512);</span>
<span class="nc" id="L1014">                    l2.add(&quot;Fail in findPath(&quot;, unit, &quot;, &quot;, tile,</span>
<span class="nc" id="L1015">                        &quot;, &quot;, realEnd, &quot;, &quot;, carrier, &quot;)\n&quot;);</span>
<span class="nc" id="L1016">                    l2.addStackTrace();</span>
<span class="nc" id="L1017">                    l2.add(p.fullPathToString());</span>
<span class="nc" id="L1018">                    findMapPath(unit, tile, (Tile)realEnd,</span>
<span class="nc" id="L1019">                                carrier, costDecider, l2);</span>
<span class="nc" id="L1020">                    l2.log(logger, Level.WARNING);</span>
                }
<span class="nc" id="L1022">                path = null;</span>

            // At the front of the path insert a node for the starting
            // location in Europe, correcting for the turns to sail to
            // the entry location.
<span class="nc" id="L1027">            } else {</span>
<span class="fc" id="L1028">                path.addTurns(offMapUnit.getSailTurns());</span>
<span class="fc" id="L1029">                path.previous = new PathNode(realStart, unit.getMovesLeft(),</span>
<span class="pc bpc" id="L1030" title="1 of 2 branches missed.">                                             0, carrier != null, null, path);</span>
<span class="fc" id="L1031">                path = path.previous;</span>
<span class="pc bpc" id="L1032" title="2 of 4 branches missed.">                if (carrier != null &amp;&amp; unit.getLocation() != carrier) {</span>
<span class="fc" id="L1033">                    path.previous = new PathNode(realStart, unit.getMovesLeft(),</span>
<span class="fc" id="L1034">                                                 0, false, null, path);</span>
<span class="fc" id="L1035">                    path = path.previous;</span>
                }
            }

<span class="pc bpc" id="L1039" title="1 of 4 branches missed.">        } else if (realStart instanceof Tile &amp;&amp; realEnd instanceof Europe) {</span>
            // 2: Tile-&gt;Europe
            // Fail fast if Europe is unattainable.
<span class="pc bpc" id="L1042" title="1 of 2 branches missed.">            if (offMapUnit == null</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">                || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L1044">                path = null;</span>
                
            // Search forwards to the high seas.
<span class="pc bfc" id="L1047" title="All 2 branches covered.">            } else if ((p = searchMap(unit, (Tile)realStart,</span>
<span class="fc" id="L1048">                        GoalDeciders.getHighSeasGoalDecider(),</span>
<span class="fc" id="L1049">                        costDecider, INFINITY, carrier, null, lb)) == null) {</span>
<span class="fc" id="L1050">                path = null;</span>

<span class="fc" id="L1052">            } else {</span>
<span class="fc" id="L1053">                PathNode last = p.getLastNode();</span>
<span class="fc" id="L1054">                last.next = new PathNode(realEnd, unit.getInitialMovesLeft(),</span>
<span class="fc" id="L1055">                    last.getTurns() + offMapUnit.getSailTurns(),</span>
<span class="fc" id="L1056">                    last.isOnCarrier(), last, null);</span>
<span class="fc" id="L1057">                path = p;</span>
            }

<span class="pc bpc" id="L1060" title="2 of 4 branches missed.">        } else if (realStart instanceof Tile &amp;&amp; realEnd instanceof Tile) {</span>
            // 3: Tile-&gt;Tile
            // Short circuit if adjacent and blocked
            Direction d;
            Unit.MoveType mt;
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">            if (unit != null</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">                &amp;&amp; (d = ((Tile)realStart).getDirection((Tile)realEnd)) != null</span>
<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">                &amp;&amp; (mt = unit.getMoveType(d)).isLegal()</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">                &amp;&amp; !mt.isProgress()) {</span>
<span class="fc" id="L1069">                path = new PathNode(realStart, unit.getMovesLeft(), 0,</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">                                    carrier != null, null, null);</span>
<span class="fc" id="L1071">                int cost = unit.getMoveCost((Tile)realStart, (Tile)realEnd,</span>
<span class="fc" id="L1072">                                            unit.getMovesLeft());</span>
<span class="fc" id="L1073">                path.next = new PathNode(realEnd, unit.getMovesLeft() - cost,</span>
<span class="fc" id="L1074">                                         0, false, path, null);</span>
<span class="fc" id="L1075">            } else {</span>
<span class="fc" id="L1076">                path = findMapPath(unit, (Tile)realStart, (Tile)realEnd,</span>
<span class="fc" id="L1077">                                   carrier, costDecider, lb);</span>
            }
<span class="fc" id="L1079">        } else {</span>
<span class="nc" id="L1080">            throw new IllegalStateException(&quot;Can not happen: &quot; + realStart</span>
<span class="nc" id="L1081">                                            + &quot;, &quot; + realEnd);</span>
        }

<span class="fc" id="L1084">        finishPath(path, unit, lb);</span>
<span class="fc" id="L1085">        return path;</span>
    }

    /**
     * Searches for a goal.
     * Assumes units in Europe return to their current entry location,
     * which is not optimal most of the time.
     * Returns the full path including the start and end locations.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find a path for.
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param goalDecider The object responsible for determining whether a
     *     given &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt;
     *     responsible for determining the path cost.
     * @param maxTurns The maximum number of turns the given
     *     &lt;code&gt;Unit&lt;/code&gt; is allowed to move.  This is the
     *     maximum search range for a goal.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return The path to a goal, or null if none can be found.
     * @throws IllegalArgumentException If the unit is null, or the
     *     start location does not make sense, or the carrier/unit
     *     combination is bogus.
     */
    public PathNode search(final Unit unit, Location start,
                           final GoalDecider goalDecider,
                           final CostDecider costDecider,
                           final int maxTurns, final Unit carrier,
                           LogBuilder lb) {
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">        if (traceSearch) lb = new LogBuilder(1024);</span>

<span class="fc" id="L1117">        final Location realStart = findRealStart(unit, start, carrier);</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">        final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>
        
        PathNode p, path;
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        if (realStart instanceof Europe) {</span>
            // Fail fast if Europe is unattainable.
<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if (offMapUnit == null</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">                || !offMapUnit.getType().canMoveToHighSeas()) {</span>
<span class="nc" id="L1125">                path = null;</span>

            // This is suboptimal.  We do not know where to enter from
            // Europe, so start with the standard entry location...
<span class="nc bnc" id="L1129" title="All 2 branches missed.">            } else if ((p = searchMap(unit,</span>
<span class="nc" id="L1130">                        (Tile)offMapUnit.getEntryLocation(),</span>
<span class="nc" id="L1131">                        goalDecider, costDecider, maxTurns, carrier,</span>
<span class="nc" id="L1132">                        null, lb)) == null) {</span>
<span class="nc" id="L1133">                path = null;</span>

            // ...then if we find a path, try to optimize it.  This
            // will lose if the initial search fails due to a turn limit.
            // FIXME: do something better.
<span class="nc" id="L1138">            } else {</span>
<span class="nc" id="L1139">                path = findPath(unit, realStart, p.getLastNode().getTile(),</span>
<span class="nc" id="L1140">                                carrier, costDecider, lb);</span>
            }

<span class="nc" id="L1143">        } else {</span>
<span class="fc" id="L1144">            path = searchMap(unit, realStart.getTile(), goalDecider,</span>
<span class="fc" id="L1145">                             costDecider, maxTurns, carrier, null, lb);</span>
        }

<span class="fc" id="L1148">        finishPath(path, unit, lb);</span>
<span class="fc" id="L1149">        return path;</span>
    }

    /**
     * Gets the search tracing status.
     *
     * @return The search tracing status.
     */
    public boolean getSearchTrace() {
<span class="nc" id="L1158">        return traceSearch;</span>
    }

    /**
     * Sets the search tracing status.
     *
     * @param trace The new search tracing status.
     * @return The original search tracing status.
     */
    public boolean setSearchTrace(boolean trace) {
<span class="nc" id="L1168">        boolean ret = traceSearch;</span>
<span class="nc" id="L1169">        traceSearch = trace;</span>
<span class="nc" id="L1170">        return ret;</span>
    }

    /**
     * Was a carrier used previously on a path?
     *
     * Beware!  This is special case code for partially constructed
     * paths that do not yet have valid .next links, so we can not use the
     * generic PathNode routines.
     *
     * @param path The path the search.
     * @return True if the path includes a previous on-carrier node.
     */
    private boolean usedCarrier(PathNode path) {
<span class="fc bfc" id="L1184" title="All 2 branches covered.">        while (path != null) {</span>
<span class="pc bpc" id="L1185" title="1 of 2 branches missed.">            if (path.isOnCarrier()) return true;</span>
<span class="fc" id="L1186">            path = path.previous;</span>
        }
<span class="fc" id="L1188">        return false;</span>
    }

    /**
     * Internal class for evaluating a candidate move.
     */
    private class MoveCandidate {

        private Unit unit;
        private final PathNode current;
        private final Location dst;
        private int movesLeft;
        private int turns;
        private final boolean onCarrier;
        private final CostDecider decider;
        private int cost;
        private PathNode path;


        /**
         * Creates a new move candidate where a cost decider will be used
         * to work out the new moves and turns left.
         *
         * @param unit The &lt;code&gt;Unit&lt;/code&gt; to move.
         * @param current The current position on the path.
         * @param dst The &lt;code&gt;Location&lt;/code&gt; to move to.
         * @param movesLeft The initial number of moves left.
         * @param turns The initial number of turns.
         * @param onCarrier Will the new move be on a carrier.
         * @param decider The &lt;code&gt;CostDecider&lt;/code&gt; to use.
         */
<span class="fc" id="L1219">        public MoveCandidate(Unit unit, PathNode current, Location dst,</span>
                             int movesLeft, int turns, boolean onCarrier,
<span class="fc" id="L1221">                             CostDecider decider) {</span>
<span class="fc" id="L1222">            this.unit = unit;</span>
<span class="fc" id="L1223">            this.current = current;</span>
<span class="fc" id="L1224">            this.dst = dst;</span>
<span class="fc" id="L1225">            this.movesLeft = movesLeft;</span>
<span class="fc" id="L1226">            this.turns = turns;</span>
<span class="fc" id="L1227">            this.onCarrier = onCarrier;</span>
<span class="fc" id="L1228">            this.decider = decider;</span>
<span class="fc" id="L1229">            this.cost = decider.getCost(unit, current.getLocation(),</span>
<span class="fc" id="L1230">                                        dst, movesLeft);</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">            if (this.cost != CostDecider.ILLEGAL_MOVE) {</span>
<span class="fc" id="L1232">                this.turns += decider.getNewTurns();</span>
<span class="fc" id="L1233">                this.movesLeft = decider.getMovesLeft();</span>
<span class="fc" id="L1234">                this.cost = PathNode.getCost(this.turns, this.movesLeft);</span>
            }
<span class="fc" id="L1236">            this.path = null;</span>
<span class="fc" id="L1237">        }</span>

        /**
         * Get the cost.
         *
         * @return The current move cost.
         */
        public int getCost() {
<span class="fc" id="L1245">            return this.cost;</span>
        }

        /**
         * Handles the change of unit as a result of an embark.
         *
         * @param unit The &lt;code&gt;Unit&lt;/code&gt; to embark.
         */
        public void embarkUnit(Unit unit) {
<span class="fc" id="L1254">            this.unit = unit;</span>
<span class="fc" id="L1255">            this.movesLeft = unit.getInitialMovesLeft();</span>
<span class="fc" id="L1256">            this.cost = PathNode.getCost(turns, movesLeft);</span>
<span class="fc" id="L1257">        }</span>

        /**
         * Resets the path.  Required after the parameters change.
         *
         * @param goal True if this is a goal node.
         */
        public void resetPath(boolean goal) {
<span class="fc" id="L1265">            path = new PathNode(dst, movesLeft, turns, onCarrier,</span>
<span class="fc" id="L1266">                                current, null);</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            if (goal) {</span>
                // Do not let the CostDecider (which may be
                // conservative) block a final destination.  This
                // allows planning routines to compute paths to tiles
                // temporarily occupied by an enemy unit, or for an
                // empty ship to find a compound path to a native
                // settlement where the first step is to collect the
                // cargo it needs to make the final move legal.
<span class="pc bpc" id="L1275" title="1 of 2 branches missed.">                if (cost == CostDecider.ILLEGAL_MOVE</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                    &amp;&amp; unit != null</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">                    &amp;&amp; current.getTile() != null</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                    &amp;&amp; dst.getTile() != null) {</span>
                    // Pretend it finishes the move.
<span class="nc" id="L1280">                    movesLeft = unit.getInitialMovesLeft();</span>
<span class="nc" id="L1281">                    turns++;</span>
<span class="nc" id="L1282">                    path = new PathNode(dst, movesLeft, turns, onCarrier,</span>
<span class="nc" id="L1283">                                        current, null);</span>
                }

                // Add an extra step to disembark from a carrier at a
                // settlement.  If this is omitted, then a path that
                // disembarks a unit from its carrier on an adjacent
                // tile looks unfairly expensive.
                Settlement s;
<span class="pc bpc" id="L1291" title="1 of 4 branches missed.">                if (unit != null &amp;&amp; path.isOnCarrier()</span>
<span class="pc bpc" id="L1292" title="1 of 2 branches missed.">                    &amp;&amp; (s = path.getLocation().getSettlement()) != null</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                    &amp;&amp; unit.getOwner().owns(s)) {</span>
<span class="nc" id="L1294">                    movesLeft = 0;</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                    if (path.embarkedThisTurn(turns)) turns++;</span>
<span class="nc" id="L1296">                    path = new PathNode(s.getTile(), 0, turns, false,</span>
<span class="nc" id="L1297">                                        path, null);</span>
                }
<span class="fc" id="L1299">                cost = PathNode.getCost(turns, movesLeft);</span>
            }
<span class="fc" id="L1301">        }</span>

        /**
         * Does this move candidate improve on a specified move.
         *
         * @param best The &lt;code&gt;PathNode&lt;/code&gt; to compare against.
         * @return True if this candidate is an improvement.
         */
        public boolean canImprove(PathNode best) {
<span class="pc bpc" id="L1310" title="2 of 4 branches missed.">            return cost != CostDecider.ILLEGAL_MOVE</span>
<span class="pc bpc" id="L1311" title="1 of 4 branches missed.">                &amp;&amp; (best == null || cost &lt; best.getCost()</span>
<span class="fc bfc" id="L1312" title="All 2 branches covered.">                    || (cost == best.getCost()</span>
<span class="fc" id="L1313">                        &amp;&amp; best.getLength() &lt; path.getLength()));</span>
        }

        /**
         * Replace a given path with that of this candidate move.
         *
         * @param openMap The list of available nodes.
         * @param openMapQueue The queue of available nodes.
         * @param f The heuristic values for A*.
         * @param sh An optional &lt;code&gt;SearchHeuristic&lt;/code&gt; to apply.
         */
        public void improve(HashMap&lt;String, PathNode&gt; openMap,
                            PriorityQueue&lt;PathNode&gt; openMapQueue,
                            HashMap&lt;String, Integer&gt; f,
                            SearchHeuristic sh) {
<span class="fc" id="L1328">            PathNode best = openMap.get(dst.getId());</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">            if (best != null) {</span>
<span class="nc" id="L1330">                openMap.remove(dst.getId());</span>
<span class="nc" id="L1331">                openMapQueue.remove(best);</span>
            }
<span class="fc" id="L1333">            int fcost = cost;</span>
<span class="pc bpc" id="L1334" title="1 of 4 branches missed.">            if (sh != null &amp;&amp; dst.getTile() != null) {</span>
<span class="fc" id="L1335">                fcost += sh.getValue(dst.getTile());</span>
            }
<span class="fc" id="L1337">            f.put(dst.getId(), fcost);</span>
<span class="fc" id="L1338">            openMap.put(dst.getId(), path);</span>
<span class="fc" id="L1339">            openMapQueue.offer(path);</span>
<span class="fc" id="L1340">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1347">            StringBuilder sb = new StringBuilder(128);</span>
<span class="nc" id="L1348">            sb.append(&quot;[candidate unit=&quot;).append(unit)</span>
<span class="nc" id="L1349">                .append(&quot; dst=&quot;).append(dst)</span>
<span class="nc" id="L1350">                .append(&quot; movesLeft=&quot;).append(movesLeft)</span>
<span class="nc" id="L1351">                .append(&quot; turns=&quot;).append(turns)</span>
<span class="nc" id="L1352">                .append(&quot; onCarrier=&quot;).append(onCarrier)</span>
<span class="nc" id="L1353">                .append(&quot; decider=&quot;).append(decider)</span>
<span class="nc" id="L1354">                .append(&quot; cost=&quot;).append(cost)</span>
<span class="nc" id="L1355">                .append(&quot;]&quot;);</span>
<span class="nc" id="L1356">            return sb.toString();</span>
        }
    };

    /**
     * Searches for a path to a goal determined by the given
     * &lt;code&gt;GoalDecider&lt;/code&gt;.
     *
     * Using A* with a List (closedMap) for marking the visited nodes
     * and using a PriorityQueue (openMapQueue) for getting the next
     * edge with the least cost.  This implementation could be
     * improved by having the visited attribute stored on each Tile in
     * order to avoid both of the HashMaps currently being used to
     * serve this purpose.
     *
     * If the SearchHeuristic is not supplied, then the algorithm
     * degrades gracefully to Dijkstra's algorithm.
     *
     * The data structure for the open list is a combined structure: using a
     * HashMap for membership tests and a PriorityQueue for getting the node
     * with the minimal f (cost+heuristics). This gives O(1) on membership
     * test and O(log N) for remove-best and insertions.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find a path for.
     * @param start The &lt;code&gt;Tile&lt;/code&gt; to start the search from.
     * @param goalDecider The object responsible for determining whether a
     *     given &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt;
     *     responsible for determining the path cost.
     * @param maxTurns The maximum number of turns the given
     *     &lt;code&gt;Unit&lt;/code&gt; is allowed to move. This is the
     *     maximum search range for a goal.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param searchHeuristic An optional &lt;code&gt;SearchHeuristic&lt;/code&gt;.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return A path to a goal determined by the given
     *     &lt;code&gt;GoalDecider&lt;/code&gt;.
     */
    private PathNode searchMap(final Unit unit, final Tile start,
                               final GoalDecider goalDecider,
                               final CostDecider costDecider,
                               final int maxTurns, final Unit carrier,
                               final SearchHeuristic searchHeuristic,
                               final LogBuilder lb) {
<span class="fc" id="L1400">        final HashMap&lt;String, PathNode&gt; openMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1401">        final HashMap&lt;String, PathNode&gt; closedMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1402">        final HashMap&lt;String, Integer&gt; f = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1403">        final PriorityQueue&lt;PathNode&gt; openMapQueue = new PriorityQueue&lt;&gt;(1024,</span>
<span class="fc" id="L1404">            Comparator.comparingInt(p -&gt; f.get(p.getLocation().getId())));</span>
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">        final Europe europe = (unit == null) ? null</span>
<span class="fc" id="L1406">            : unit.getOwner().getEurope();</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">        final Unit offMapUnit = (carrier != null) ? carrier : unit;</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">        Unit currentUnit = (start.isLand())</span>
<span class="fc bfc" id="L1409" title="All 2 branches covered.">            ? ((start.hasSettlement()</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">                    &amp;&amp; start.getSettlement().isConnectedPort()</span>
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">                    &amp;&amp; unit != null</span>
<span class="pc bpc" id="L1412" title="1 of 2 branches missed.">                    &amp;&amp; unit.getLocation() == carrier) ? carrier : unit)</span>
<span class="fc" id="L1413">            : offMapUnit;</span>
<span class="pc bpc" id="L1414" title="1 of 2 branches missed.">        if (lb != null) lb.add(&quot;Search trace(unit=&quot;, unit,</span>
<span class="nc" id="L1415">            &quot;, from=&quot;, start,</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            &quot;, max=&quot;, ((maxTurns == INFINITY)?&quot;-&quot;:Integer.toString(maxTurns)),</span>
<span class="nc" id="L1417">            &quot;, carrier=&quot;, carrier, &quot;)&quot;);</span>

        // Create the start node and put it on the open list.
<span class="fc" id="L1420">        final PathNode firstNode = new PathNode(start,</span>
<span class="pc bpc" id="L1421" title="1 of 2 branches missed.">            ((currentUnit != null) ? currentUnit.getMovesLeft() : -1),</span>
<span class="fc bfc" id="L1422" title="All 4 branches covered.">            0, carrier != null &amp;&amp; currentUnit == carrier, null, null);</span>
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        f.put(start.getId(), (searchHeuristic == null) ? 0</span>
<span class="fc" id="L1424">                : searchHeuristic.getValue(start));</span>
<span class="fc" id="L1425">        openMap.put(start.getId(), firstNode);</span>
<span class="fc" id="L1426">        openMapQueue.offer(firstNode);</span>

<span class="fc" id="L1428">        PathNode best = null;</span>
<span class="fc" id="L1429">        int bestScore = INFINITY;</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">        while (!openMap.isEmpty()) {</span>
            // Choose the node with the lowest f.
<span class="fc" id="L1432">            final PathNode currentNode = openMapQueue.poll();</span>
<span class="fc" id="L1433">            final Location currentLocation = currentNode.getLocation();</span>
<span class="fc" id="L1434">            openMap.remove(currentLocation.getId());</span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">            if (lb != null) lb.add(&quot;\n  &quot;, currentNode);</span>

            // Reset current unit to that of this node.
<span class="fc bfc" id="L1438" title="All 2 branches covered.">            currentUnit = (currentNode.isOnCarrier()) ? carrier : unit;</span>

            // Check for success.
<span class="fc bfc" id="L1441" title="All 2 branches covered.">            if (goalDecider.check(currentUnit, currentNode)) {</span>
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot; ***goal(&quot;,</span>
<span class="nc" id="L1443">                    currentNode.getCost(), &quot;)***&quot;);</span>
<span class="fc" id="L1444">                best = goalDecider.getGoal();</span>
<span class="fc" id="L1445">                bestScore = best.getCost();</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">                if (!goalDecider.hasSubGoals()) break;</span>
                continue;
            }

            // Skip nodes that can not beat the current best path.
<span class="fc bfc" id="L1451" title="All 2 branches covered.">            if (bestScore &lt; currentNode.getCost()) {</span>
<span class="fc" id="L1452">                closedMap.put(currentLocation.getId(), currentNode);</span>
<span class="pc bpc" id="L1453" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot; ...goal cost wins(&quot;,</span>
<span class="nc" id="L1454">                    bestScore, &quot; &lt; &quot;, currentNode.getCost(), &quot;)...&quot;);</span>
<span class="nc" id="L1455">                continue;</span>
            }

            // Ignore nodes over the turn limit.
<span class="fc bfc" id="L1459" title="All 2 branches covered.">            if (currentNode.getTurns() &gt; maxTurns) {</span>
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot;...out-of-range&quot;);</span>
<span class="nc" id="L1461">                continue;</span>
            }

            // Valid candidate for the closed list.
<span class="fc" id="L1465">            closedMap.put(currentLocation.getId(), currentNode);</span>
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">            if (lb != null) lb.add(&quot;...close&quot;);</span>

            // Collect the parameters for the current node.
<span class="fc" id="L1469">            final int currentMovesLeft = currentNode.getMovesLeft();</span>
<span class="fc" id="L1470">            final int currentTurns = currentNode.getTurns();</span>
<span class="fc" id="L1471">            final boolean currentOnCarrier = currentNode.isOnCarrier();</span>

<span class="fc" id="L1473">            final Tile currentTile = currentNode.getTile();</span>
<span class="pc bpc" id="L1474" title="1 of 2 branches missed.">            if (currentTile == null) { // Must be in Europe.</span>
                // FIXME: Do not consider tiles &quot;adjacent&quot; to Europe, yet.
                // There may indeed be cases where going to Europe and
                // coming back on the other side of the map is faster.
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                if (lb != null) lb.add(&quot;...skip Europe&quot;);</span>
<span class="nc" id="L1479">                continue;</span>
            }

            // Try the tiles in each direction
            PathNode closed;
<span class="fc bfc" id="L1484" title="All 2 branches covered.">            for (Tile moveTile : currentTile.getSurroundingTiles(1)) {</span>
                // If the new tile is the tile we just visited, skip it.
<span class="pc bpc" id="L1486" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot;\n    &quot;, moveTile);</span>
<span class="fc bfc" id="L1487" title="All 2 branches covered.">                if (currentNode.previous != null</span>
<span class="fc bfc" id="L1488" title="All 2 branches covered.">                    &amp;&amp; currentNode.previous.getTile() == moveTile) {</span>
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">                    if (lb != null) lb.add(&quot; prev&quot;);</span>
<span class="nc" id="L1490">                    continue;</span>
                }

                // Skip neighbouring tiles already too expensive.
                int cc;
<span class="fc bfc" id="L1495" title="All 2 branches covered.">                if ((closed = closedMap.get(moveTile.getId())) != null</span>
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">                    &amp;&amp; (cc = closed.getCost()) &lt;= currentNode.getCost()) {</span>
<span class="pc bpc" id="L1497" title="1 of 2 branches missed.">                    if (lb != null) lb.add(&quot; &quot;, cc);</span>
<span class="nc" id="L1498">                    continue;</span>
                }

                // Is this move to the goal?  Use fake high cost so
                // this does not become cached inside the goal decider
                // as the preferred path.
<span class="fc" id="L1504">                boolean isGoal = goalDecider.check(unit,</span>
<span class="fc" id="L1505">                    new PathNode(moveTile, 0, INFINITY/2, false,</span>
<span class="fc" id="L1506">                        currentNode, null));</span>
<span class="pc bpc" id="L1507" title="1 of 4 branches missed.">                if (isGoal &amp;&amp; lb != null) lb.add(&quot; *goal*&quot;);</span>

                // Is this move possible for the base unit?
                // Allow some seemingly impossible moves if it is to
                // the goal (see the comment to recoverMove).
<span class="fc" id="L1512">                Unit.MoveType umt = unit.getSimpleMoveType(currentTile,</span>
<span class="fc" id="L1513">                                                           moveTile);</span>
<span class="fc bfc" id="L1514" title="All 2 branches covered.">                boolean carrierMove = carrier != null</span>
<span class="fc bfc" id="L1515" title="All 2 branches covered.">                    &amp;&amp; carrier.isTileAccessible(moveTile);</span>
<span class="fc" id="L1516">                boolean unitMove = umt.isProgress();</span>
<span class="fc bfc" id="L1517" title="All 2 branches covered.">                if (isGoal) {</span>
<span class="fc bfc" id="L1518" title="All 2 branches covered.">                    if (!unitMove) {</span>
<span class="pc bpc" id="L1519" title="2 of 4 branches missed.">                        switch (umt) {</span>
                        case ATTACK_UNIT:
                        case ATTACK_SETTLEMENT:
                        case ENTER_FOREIGN_COLONY_WITH_SCOUT:
                        case ENTER_INDIAN_SETTLEMENT_WITH_SCOUT:
                        case ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST:
                        case ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY:
                        case ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS:
                            // Can not move to the tile, but there is
                            // a valid interaction with the unit or
                            // settlement that is there.
<span class="fc" id="L1530">                            unitMove = true;</span>
<span class="fc" id="L1531">                            break;</span>
                        case MOVE_NO_ATTACK_MARINE:
                        case MOVE_NO_ATTACK_CIVILIAN:
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                            if (moveTile.hasSettlement()) break;</span>
                            // There is a unit in the way.  Unless this
                            // unit can arrive there this turn, assume the
                            // condition is transient as long as the tile
                            // is not in a constrained position such as a
                            // small island or river.
<span class="nc bnc" id="L1540" title="All 4 branches missed.">                            unitMove = currentNode.getTurns() &gt; 0</span>
<span class="nc" id="L1541">                                &amp;&amp; moveTile.getAvailableAdjacentCount() &gt;= 3;</span>
<span class="nc" id="L1542">                            break;</span>
                        case MOVE_NO_ACCESS_WATER:
                            // The unit can not disembark directly to the
                            // goal along this path, but the goal is still
                            // available by other paths.
<span class="nc bnc" id="L1547" title="All 2 branches missed.">                            if (lb != null) lb.add(&quot; !disembark&quot;);</span>
<span class="nc" id="L1548">                            continue;</span>
                        default:
                            break;
                        }
<span class="fc bfc" id="L1552" title="All 4 branches covered.">                        if (!unitMove &amp;&amp; unit == currentUnit) {</span>
                            // This search can never succeed if the unit
                            // can not reach the goal, except if there is
                            // a carrier involved that might still succeed.
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">                            if (lb != null) lb.add(&quot; fail-at-GOAL(&quot;, umt, &quot;)&quot;);</span>
<span class="nc" id="L1557">                            continue;</span>
                        }
                    }
                    // Special case where the carrier is adjacent to
                    // an accessible goal settlement but out of moves,
                    // in which case we let the unit finish the job
                    // if it can move.
<span class="pc bpc" id="L1564" title="3 of 6 branches missed.">                    if (unitMove &amp;&amp; carrierMove &amp;&amp; currentOnCarrier) {</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">                        carrierMove = currentNode.getMovesLeft() &gt; 0</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">                            || currentNode.embarkedThisTurn(currentTurns);</span>
                    }
                }
<span class="pc bpc" id="L1569" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot; &quot;, umt, &quot;/&quot;,</span>
<span class="nc bnc" id="L1570" title="All 4 branches missed.">                    ((unitMove) ? &quot;U&quot; : &quot;&quot;), ((carrierMove) ? &quot;C&quot; : &quot;&quot;));</span>

                // Check for a carrier change at the new tile,
                // creating a MoveCandidate for each case.
                //
                // Do *not* allow units to re-embark on the carrier.
                // Note that embarking can actually increase the moves
                // left because the carrier might be not have spent
                // any moves yet that turn.
                //
                // Note that we always favour using the carrier if
                // both carrier and non-carrier moves are possible,
                // which can only be true moving into a settlement.
                // Usually when moving into a settlement it will be
                // useful to dock the carrier so it can collect new
                // cargo.  OTOH if the carrier is just passing through
                // the right thing is to keep the passenger on board.
                // However, see the goal settlement exception above.
<span class="fc bfc" id="L1588" title="All 2 branches covered.">                MoveStep step = (currentOnCarrier)</span>
<span class="fc bfc" id="L1589" title="All 2 branches covered.">                    ? ((carrierMove) ? MoveStep.BYWATER</span>
<span class="fc bfc" id="L1590" title="All 2 branches covered.">                        : (unitMove) ? MoveStep.DISEMBARK</span>
<span class="fc" id="L1591">                        : MoveStep.FAIL)</span>
<span class="pc bpc" id="L1592" title="1 of 4 branches missed.">                    : ((carrierMove &amp;&amp; !usedCarrier(currentNode))</span>
<span class="fc" id="L1593">                        ? MoveStep.EMBARK</span>
<span class="pc bpc" id="L1594" title="1 of 6 branches missed.">                        : (unitMove || isGoal) ? ((unit.isNaval())</span>
<span class="fc" id="L1595">                            ? MoveStep.BYWATER</span>
<span class="fc" id="L1596">                            : MoveStep.BYLAND)</span>
<span class="fc" id="L1597">                        : MoveStep.FAIL);</span>
                MoveCandidate move;
<span class="fc bfc" id="L1599" title="All 5 branches covered.">                switch (step) {</span>
                case BYLAND:
<span class="fc" id="L1601">                    move = new MoveCandidate(unit, currentNode, moveTile, </span>
<span class="fc" id="L1602">                        currentMovesLeft, currentTurns, false,</span>
<span class="fc bfc" id="L1603" title="All 2 branches covered.">                        ((costDecider != null) ? costDecider</span>
<span class="fc" id="L1604">                            : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1605">                    break;</span>
                case BYWATER:
<span class="fc" id="L1607">                    move = new MoveCandidate(offMapUnit, currentNode, moveTile,</span>
<span class="fc" id="L1608">                        currentMovesLeft, currentTurns, currentOnCarrier,</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                        ((costDecider != null) ? costDecider</span>
<span class="fc" id="L1610">                            : CostDeciders.defaultCostDeciderFor(offMapUnit)));</span>
<span class="fc" id="L1611">                    break;</span>
                case EMBARK:
<span class="fc" id="L1613">                    move = new MoveCandidate(unit, currentNode, moveTile,</span>
<span class="fc" id="L1614">                        currentMovesLeft, currentTurns, true,</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">                        ((costDecider != null) ? costDecider</span>
<span class="fc" id="L1616">                            : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1617">                    move.embarkUnit(carrier);</span>
<span class="fc" id="L1618">                    break;</span>
                case DISEMBARK:
<span class="fc" id="L1620">                    move = new MoveCandidate(unit, currentNode, moveTile,</span>
<span class="fc" id="L1621">                        0, currentTurns, false,</span>
<span class="fc bfc" id="L1622" title="All 2 branches covered.">                        ((costDecider != null) ? costDecider</span>
<span class="fc" id="L1623">                            : CostDeciders.defaultCostDeciderFor(unit)));</span>
<span class="fc" id="L1624">                    break;</span>
                case FAIL: default: // Loop on failure.
<span class="fc" id="L1626">                    move = null;</span>
                    break;
                }

                String stepLog;
<span class="fc bfc" id="L1631" title="All 2 branches covered.">                if (move == null) {</span>
<span class="fc" id="L1632">                    stepLog = &quot;!&quot;;</span>
<span class="fc" id="L1633">                } else {</span>
<span class="fc" id="L1634">                    move.resetPath(isGoal);</span>
                    // Tighten the bounds on a previously seen case if possible
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">                    if (closed != null) {</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">                        if (move.canImprove(closed)) {</span>
<span class="nc" id="L1638">                            closedMap.remove(moveTile.getId());</span>
<span class="nc" id="L1639">                            move.improve(openMap, openMapQueue, f,</span>
<span class="nc" id="L1640">                                         searchHeuristic);</span>
<span class="nc" id="L1641">                            stepLog = &quot;^&quot; + Integer.toString(move.getCost());</span>
<span class="nc" id="L1642">                        } else {</span>
<span class="nc" id="L1643">                            stepLog = &quot;.&quot;;</span>
                        }
<span class="pc bfc" id="L1645" title="All 2 branches covered.">                    } else if (move.canImprove(openMap.get(moveTile.getId()))){</span>
<span class="fc" id="L1646">                        move.improve(openMap, openMapQueue, f,</span>
<span class="fc" id="L1647">                                     searchHeuristic);</span>
<span class="fc" id="L1648">                        stepLog = &quot;+&quot; + Integer.toString(move.getCost());</span>
<span class="fc" id="L1649">                    } else {</span>
<span class="fc" id="L1650">                        stepLog = &quot;-&quot;;</span>
                    }
                }
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">                if (lb != null) lb.add(&quot; &quot;, step, stepLog);</span>
            }
        }

        // Relink the path.  We omitted the .next link while constructing it.
<span class="fc" id="L1658">        best = goalDecider.getGoal();</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">        if (best != null) {</span>
<span class="fc bfc" id="L1660" title="All 2 branches covered.">            while (best.previous != null) {</span>
<span class="fc" id="L1661">                best.previous.next = best;</span>
<span class="fc" id="L1662">                best = best.previous;</span>
            }
        }
<span class="fc" id="L1665">        return best;</span>
    }

    /**
     * Searches for a tile within a radius of a starting tile.
     *
     * Does not use a unit, and thus does not consider movement validity.
     *
     * @param start The starting &lt;code&gt;Tile&lt;/code&gt;.
     * @param goalDecider A &lt;code&gt;GoalDecider&lt;/code&gt; that chooses the goal,
     *     which must be capable of tolerating a null unit.
     * @param radius The maximum radius of tiles to search from the start.
     * @return The goal tile as determined by the, or null if none found.
     */
    public Tile searchCircle(final Tile start, final GoalDecider goalDecider,
                             final int radius) {
<span class="pc bpc" id="L1681" title="3 of 6 branches missed.">        if (start == null || goalDecider == null || radius &lt;= 0) return null;</span>

<span class="fc bfc" id="L1683" title="All 2 branches covered.">        for (Tile t : getCircleTiles(start, true, radius)) {</span>
<span class="fc" id="L1684">            PathNode path = new PathNode(t, 0, start.getDistanceTo(t), false,</span>
<span class="fc" id="L1685">                                         null, null);</span>
<span class="pc bpc" id="L1686" title="1 of 2 branches missed.">            if (goalDecider.check(null, path)</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">                &amp;&amp; !goalDecider.hasSubGoals())</span>
<span class="nc" id="L1688">                break;</span>
        }
        
<span class="fc" id="L1691">        PathNode best = goalDecider.getGoal();</span>
<span class="pc bpc" id="L1692" title="1 of 2 branches missed.">        return (best == null) ? null : best.getTile();</span>
    }

    
    // Support for various kinds of map iteration.

    /**
     * An iterator returning positions in a spiral starting at a given
     * center tile.  The center tile is never included in the returned
     * tiles, and all returned tiles are valid.
     */
    private final class CircleIterator implements Iterator&lt;Tile&gt; {

        /** The maximum radius. */
        private final int radius;
        /** The current radius of the iteration. */
        private int currentRadius;
        /** The current index in the circle with the current radius: */
        private int n;
        /** The current position in the circle. */
        private int x, y;


        /**
         * Create a new Circle Iterator.
         *
         * @param center The center &lt;code&gt;Tile&lt;/code&gt; of the circle.
         * @param isFilled True to get all of the positions within the circle.
         * @param radius The radius of the circle.
         */
<span class="fc" id="L1722">        public CircleIterator(Tile center, boolean isFilled, int radius) {</span>
<span class="pc bpc" id="L1723" title="1 of 2 branches missed.">            if (center == null) {</span>
<span class="nc" id="L1724">                throw new IllegalArgumentException(&quot;center must not be null.&quot;);</span>
            }
<span class="fc" id="L1726">            this.radius = radius;</span>
<span class="fc" id="L1727">            n = 0;</span>

            Position step;
<span class="pc bpc" id="L1730" title="3 of 4 branches missed.">            if (isFilled || radius == 1) {</span>
<span class="fc" id="L1731">                step = Direction.NE.step(center.getX(), center.getY());</span>
<span class="fc" id="L1732">                x = step.x;</span>
<span class="fc" id="L1733">                y = step.y;</span>
<span class="fc" id="L1734">                currentRadius = 1;</span>
<span class="fc" id="L1735">            } else {</span>
<span class="nc" id="L1736">                this.currentRadius = radius;</span>
<span class="nc" id="L1737">                x = center.getX();</span>
<span class="nc" id="L1738">                y = center.getY();</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">                for (int i = 1; i &lt; radius; i++) {</span>
<span class="nc" id="L1740">                    step = Direction.N.step(x, y);</span>
<span class="nc" id="L1741">                    x = step.x;</span>
<span class="nc" id="L1742">                    y = step.y;</span>
                }
<span class="nc" id="L1744">                step = Direction.NE.step(x, y);</span>
<span class="nc" id="L1745">                x = step.x;</span>
<span class="nc" id="L1746">                y = step.y;</span>
            }
<span class="fc bfc" id="L1748" title="All 2 branches covered.">            if (!isValid(x, y)) nextTile();</span>
<span class="fc" id="L1749">        }</span>

        /**
         * Gets the current radius of the circle.
         *
         * @return The distance from the center tile this
         *     &lt;code&gt;CircleIterator&lt;/code&gt; was initialized with.
         */
        public int getCurrentRadius() {
<span class="nc" id="L1758">            return currentRadius;</span>
        }

        /**
         * Finds the next position.
         */
        private void nextTile() {
<span class="fc bfc" id="L1765" title="All 2 branches covered.">            boolean started = n != 0;</span>
            do {
<span class="fc" id="L1767">                n++;</span>
<span class="fc" id="L1768">                final int width = currentRadius * 2;</span>
<span class="fc bfc" id="L1769" title="All 2 branches covered.">                if (n &gt;= width * 4) {</span>
<span class="fc" id="L1770">                    currentRadius++;</span>
<span class="fc bfc" id="L1771" title="All 2 branches covered.">                    if (currentRadius &gt; radius) {</span>
<span class="fc" id="L1772">                        x = y = UNDEFINED;</span>
<span class="fc" id="L1773">                        break;</span>
<span class="fc bfc" id="L1774" title="All 2 branches covered.">                    } else if (!started) {</span>
<span class="fc" id="L1775">                        x = y = UNDEFINED;</span>
<span class="fc" id="L1776">                        break;</span>
                    } else {
<span class="fc" id="L1778">                        n = 0;</span>
<span class="fc" id="L1779">                        started = false;</span>
<span class="fc" id="L1780">                        Position step = Direction.NE.step(x, y);</span>
<span class="fc" id="L1781">                        x = step.x;</span>
<span class="fc" id="L1782">                        y = step.y;</span>
                    }
<span class="fc" id="L1784">                } else {</span>
<span class="fc" id="L1785">                    int i = n / width;</span>
                    Direction direction;
<span class="pc bpc" id="L1787" title="1 of 5 branches missed.">                    switch (i) {</span>
                    case 0:
<span class="fc" id="L1789">                        direction = Direction.SE;</span>
<span class="fc" id="L1790">                        break;</span>
                    case 1:
<span class="fc" id="L1792">                        direction = Direction.SW;</span>
<span class="fc" id="L1793">                        break;</span>
                    case 2:
<span class="fc" id="L1795">                        direction = Direction.NW;</span>
<span class="fc" id="L1796">                        break;</span>
                    case 3:
<span class="fc" id="L1798">                        direction = Direction.NE;</span>
<span class="fc" id="L1799">                        break;</span>
                    default:
<span class="nc" id="L1801">                        throw new IllegalStateException(&quot;i=&quot; + i + &quot;, n=&quot; + n</span>
<span class="nc" id="L1802">                                                        + &quot;, width=&quot; + width);</span>
                    }
<span class="fc" id="L1804">                    Position step = direction.step(x, y);</span>
<span class="fc" id="L1805">                    x = step.x;</span>
<span class="fc" id="L1806">                    y = step.y;</span>
                }
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            } while (!isValid(x, y));</span>
<span class="fc" id="L1809">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean hasNext() {
<span class="pc bpc" id="L1816" title="1 of 4 branches missed.">            return x != UNDEFINED &amp;&amp; y != UNDEFINED;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Tile next() throws NoSuchElementException {
<span class="pc bpc" id="L1824" title="1 of 2 branches missed.">            if (!hasNext()) {</span>
<span class="nc" id="L1825">                throw new NoSuchElementException(&quot;CircleIterator exhausted&quot;);</span>
            }
<span class="fc" id="L1827">            Tile result = getTile(x, y);</span>
<span class="fc" id="L1828">            nextTile();</span>
<span class="fc" id="L1829">            return result;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void remove() {
<span class="nc" id="L1837">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Gets a circle iterator.
     *
     * @param center The center &lt;code&gt;Tile&lt;/code&gt; to iterate around.
     * @param isFilled True to get all of the positions in the circle.
     * @param radius The radius of circle.
     * @return The circle iterator.
     */
    public Iterator&lt;Tile&gt; getCircleIterator(Tile center, boolean isFilled,
                                            int radius) {
<span class="fc" id="L1851">        return new CircleIterator(center, isFilled, radius);</span>
    }

    /**
     * Gets an iterable for all the tiles in a circle using an
     * underlying CircleIterator.
     *
     * @param center The center &lt;code&gt;Tile&lt;/code&gt; to iterate around.
     * @param isFilled True to get all of the positions in the circle.
     * @param radius The radius of circle.
     * @return An &lt;code&gt;Iterable&lt;/code&gt; for a circle of tiles.
     */
    public Iterable&lt;Tile&gt; getCircleTiles(final Tile center,
                                         final boolean isFilled,
                                         final int radius) {
<span class="fc" id="L1866">        return new Iterable&lt;Tile&gt;() {</span>
            @Override
            public Iterator&lt;Tile&gt; iterator() {
<span class="fc" id="L1869">                return getCircleIterator(center, isFilled, radius);</span>
            }
        };
    }

    /**
     * An iterator for the whole map.
     */
    private class WholeMapIterator implements Iterator&lt;Tile&gt; {
       
        /** The current coordinate position in the iteration. */
        private int x, y;


        /**
         * Default constructor.
         */
<span class="fc" id="L1886">        public WholeMapIterator() {</span>
<span class="fc" id="L1887">            x = y = 0;</span>
<span class="fc" id="L1888">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L1895" title="All 2 branches covered.">            return y &lt; getHeight();</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Tile next() throws NoSuchElementException {
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">            if (!hasNext()) {</span>
<span class="nc" id="L1904">                throw new NoSuchElementException(&quot;WholeMapIterator exhausted&quot;);</span>
            }
<span class="fc" id="L1906">            Tile result = getTile(x, y);</span>
<span class="fc" id="L1907">            x++;</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">            if (x &gt;= getWidth()) {</span>
<span class="fc" id="L1909">                x = 0;</span>
<span class="fc" id="L1910">                y++;</span>
            }
<span class="fc" id="L1912">            return result;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void remove() {
<span class="nc" id="L1920">            throw new UnsupportedOperationException();</span>
        }
    }

    /**
     * Gets an &lt;code&gt;Iterator&lt;/code&gt; of every &lt;code&gt;Tile&lt;/code&gt; on the map.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; for the whole map.
     */
    public Iterator&lt;Tile&gt; getWholeMapIterator() {
<span class="nc" id="L1930">        return new WholeMapIterator();</span>
    }

    /**
     * Gets an iterable for all the tiles in the map using an
     * underlying WholeMapIterator.
     *
     * @return An &lt;code&gt;Iterable&lt;/code&gt; for all tiles of the map.
     */
    public Iterable&lt;Tile&gt; getAllTiles() {
<span class="fc" id="L1940">        return new Iterable&lt;Tile&gt;() {</span>
            @Override
            public Iterator&lt;Tile&gt; iterator() {
<span class="fc" id="L1943">                return new WholeMapIterator();</span>
            }
        };
    }


    // Useful customers for tile iteration.

    /**
     * Searches for land within the given radius.
     *
     * @param x X-component of the position to search from.
     * @param y Y-component of the position to search from.
     * @param distance The radius in tiles that should be searched for land.
     * @return The first land tile found within the radius, or null if none
     *     found.
     */
    public Tile getLandWithinDistance(int x, int y, int distance) {
<span class="fc bfc" id="L1961" title="All 2 branches covered.">        for (Tile t : getCircleTiles(getTile(x, y), true, distance)) {</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">            if (t.isLand()) return t;</span>
        }
<span class="fc" id="L1964">        return null;</span>
    }

    /**
     * Iterates through a rectangular subpart of the Map.
     * Intentionally avoids calling methods doing redundant checks,
     * which would slow down map display.
     * 
     * @param x X-component of the position of first tile.
     * @param y Y-component of the position of first tile.
     * @param w Width of the rectangle.
     * @param h Height of the rectangle.
     * @param consumer Provides a function to call for each tile.
     */
    public void forSubMap(int x, int y, int w, int h,
                          java.util.function.Consumer&lt;Tile&gt; consumer) {
<span class="nc bnc" id="L1980" title="All 2 branches missed.">        if (x &lt; 0) {</span>
<span class="nc" id="L1981">            w += x;</span>
<span class="nc" id="L1982">            x = 0;</span>
        }
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        if (y &lt; 0) {</span>
<span class="nc" id="L1985">            h += y;</span>
<span class="nc" id="L1986">            y = 0;</span>
        }
<span class="nc bnc" id="L1988" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0)</span>
<span class="nc" id="L1989">            return;</span>
<span class="nc" id="L1990">        int width = getWidth();</span>
<span class="nc" id="L1991">        int height = getHeight();</span>
<span class="nc bnc" id="L1992" title="All 4 branches missed.">        if (x &gt; width || y &gt; height)</span>
<span class="nc" id="L1993">            return;</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">        if (x+w &gt; width)</span>
<span class="nc" id="L1995">            w = width - x;</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        if (y+h &gt; height)</span>
<span class="nc" id="L1997">            h = height - y;</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">        for (int yi = y; yi &lt; y+h; ++yi)</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">            for (int xi = x; xi &lt; x+w; ++xi)</span>
<span class="nc" id="L2000">                consumer.accept(tiles[xi][yi]);</span>
<span class="nc" id="L2001">    }</span>

    /**
     * Flood fills from a given &lt;code&gt;Position&lt;/code&gt; p, based on
     * connectivity information encoded in boolmap
     *
     * @param boolmap The connectivity information for this floodfill.
     * @param x The starting x coordinate.
     * @param y The starting y coordinate.
     * @return A boolean[][] of the same size as boolmap, where &quot;true&quot;
     *      means the fill succeeded at that location.
     */
    public static boolean[][] floodFill(boolean[][] boolmap, int x, int y) {
<span class="fc" id="L2014">        return floodFill(boolmap, x, y, Integer.MAX_VALUE);</span>
    }

    /**
     * Flood fills from a given &lt;code&gt;Position&lt;/code&gt; p, based on
     * connectivity information encoded in boolmap
     *
     * @param boolmap The connectivity information for this floodfill.
     * @param x The starting x coordinate.
     * @param y The starting y coordinate.
     * @param limit Limit to stop flood fill at.
     * @return A boolean[][] of the same size as boolmap, where &quot;true&quot;
     *      means the fill succeeded at that location.
     */
    public static boolean[][] floodFill(boolean[][] boolmap, int x, int y,
                                        int limit) {
<span class="fc" id="L2030">        Position p = new Position(x, y);</span>
<span class="fc" id="L2031">        Queue&lt;Position&gt; q = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L2032">        boolean[][] visited = new boolean[boolmap.length][boolmap[0].length];</span>
<span class="fc" id="L2033">        visited[p.getX()][p.getY()] = true;</span>
<span class="fc" id="L2034">        limit--;</span>
<span class="fc bfc" id="L2035" title="All 2 branches covered.">        do {</span>
<span class="fc bfc" id="L2036" title="All 2 branches covered.">            for (Direction direction : Direction.values()) {</span>
<span class="fc" id="L2037">                Position n = new Position(p, direction);</span>
<span class="fc bfc" id="L2038" title="All 2 branches covered.">                if (n.isValid(boolmap.length, boolmap[0].length)</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">                    &amp;&amp; boolmap[n.getX()][n.getY()]</span>
<span class="fc bfc" id="L2040" title="All 4 branches covered.">                    &amp;&amp; !visited[n.getX()][n.getY()] &amp;&amp; limit &gt; 0) {</span>
<span class="fc" id="L2041">                    visited[n.getX()][n.getY()] = true;</span>
<span class="fc" id="L2042">                    limit--;</span>
<span class="fc" id="L2043">                    q.add(n);</span>
                }
            }

<span class="fc" id="L2047">            p = q.poll();</span>
<span class="fc bfc" id="L2048" title="All 2 branches covered.">        } while (p != null &amp;&amp; limit &gt; 0);</span>
<span class="fc" id="L2049">        return visited;</span>
    }

    /**
     * Sets the contiguity identifier for all tiles.
     */
    public void resetContiguity() {
        // Create the water map.  It is an error for any tile not to
        // have a region at this point.
<span class="fc" id="L2058">        boolean[][] waterMap = new boolean[getWidth()][getHeight()];</span>
<span class="fc bfc" id="L2059" title="All 2 branches covered.">        for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2060" title="All 2 branches covered.">            for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="pc bpc" id="L2061" title="1 of 2 branches missed.">                if (isValid(x, y)) {</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">                    waterMap[x][y] = !getTile(x,y).isLand();</span>
<span class="fc" id="L2063">                    Tile tile = getTile(x, y);</span>
<span class="fc" id="L2064">                    tile.setContiguity(-1);</span>
                }
            }
        }

        // Flood fill each contiguous water region, setting the
        // contiguity number.
<span class="fc" id="L2071">        int contig = 0;</span>
<span class="fc bfc" id="L2072" title="All 2 branches covered.">        for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">            for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="fc bfc" id="L2074" title="All 2 branches covered.">                if (waterMap[x][y]) {</span>
<span class="fc" id="L2075">                    Tile tile = getTile(x, y);</span>
<span class="fc bfc" id="L2076" title="All 2 branches covered.">                    if (tile.getContiguity() &gt;= 0) continue;</span>
                    
<span class="fc" id="L2078">                    boolean[][] found = floodFill(waterMap, x, y);</span>
<span class="fc bfc" id="L2079" title="All 2 branches covered.">                    for (int yy = 0; yy &lt; getHeight(); yy++) {</span>
<span class="fc bfc" id="L2080" title="All 2 branches covered.">                        for (int xx = 0; xx &lt; getWidth(); xx++) {</span>
<span class="fc bfc" id="L2081" title="All 2 branches covered.">                            if (found[xx][yy]) {</span>
<span class="fc" id="L2082">                                Tile t = getTile(xx, yy);</span>
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                                if (t.getContiguity() &lt; 0) {</span>
<span class="fc" id="L2084">                                    t.setContiguity(contig);</span>
                                }
                            }
                        }
                    }
<span class="fc" id="L2089">                    contig++;</span>
                }
            }
        }

        // Complement the waterMap, it is now the land map.
<span class="fc bfc" id="L2095" title="All 2 branches covered.">        for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2096" title="All 2 branches covered.">            for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="pc bpc" id="L2097" title="1 of 4 branches missed.">                if (isValid(x, y)) waterMap[x][y] = !waterMap[x][y];</span>
            }
        }

        // Flood fill again for each contiguous land region.
<span class="fc bfc" id="L2102" title="All 2 branches covered.">        for (int y = 0; y &lt; getHeight(); y++) {</span>
<span class="fc bfc" id="L2103" title="All 2 branches covered.">            for (int x = 0; x &lt; getWidth(); x++) {</span>
<span class="fc bfc" id="L2104" title="All 2 branches covered.">                if (waterMap[x][y]) {</span>
<span class="fc" id="L2105">                    Tile tile = getTile(x, y);</span>
<span class="fc bfc" id="L2106" title="All 2 branches covered.">                    if (tile.getContiguity() &gt;= 0) continue;</span>
                    
<span class="fc" id="L2108">                    boolean[][] found = floodFill(waterMap, x, y);</span>
<span class="fc bfc" id="L2109" title="All 2 branches covered.">                    for (int yy = 0; yy &lt; getHeight(); yy++) {</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">                        for (int xx = 0; xx &lt; getWidth(); xx++) {</span>
<span class="fc bfc" id="L2111" title="All 2 branches covered.">                            if (found[xx][yy]) {</span>
<span class="fc" id="L2112">                                Tile t = getTile(xx, yy);</span>
<span class="pc bpc" id="L2113" title="1 of 2 branches missed.">                                if (t.getContiguity() &lt; 0) {</span>
<span class="fc" id="L2114">                                    t.setContiguity(contig);</span>
                                }
                            }
                        }
                    }
<span class="fc" id="L2119">                    contig++;</span>
                }
            }
        }
<span class="fc" id="L2123">    }        </span>

    /**
     * Places the &quot;high seas&quot;-tiles on the border of this map.
     *
     * All other tiles previously of type High Seas will be set to Ocean.
     *
     * @param distToLandFromHighSeas The distance between the land
     *     and the high seas (given in tiles).
     * @param maxDistanceToEdge The maximum distance a high sea tile
     *     can have from the edge of the map.
     */
    public void resetHighSeas(int distToLandFromHighSeas,
                              int maxDistanceToEdge) {
<span class="fc" id="L2137">        final Specification spec = getSpecification();</span>
<span class="fc" id="L2138">        final TileType ocean = spec.getTileType(&quot;model.tile.ocean&quot;);</span>
<span class="fc" id="L2139">        final TileType highSeas = spec.getTileType(&quot;model.tile.highSeas&quot;);</span>
<span class="pc bpc" id="L2140" title="1 of 2 branches missed.">        if (highSeas == null) {</span>
<span class="nc" id="L2141">            throw new RuntimeException(&quot;HighSeas TileType must exist&quot;);</span>
        }
<span class="pc bpc" id="L2143" title="1 of 2 branches missed.">        if (ocean == null) {</span>
<span class="nc" id="L2144">            throw new RuntimeException(&quot;Ocean TileType must exist&quot;);</span>
        }
<span class="pc bpc" id="L2146" title="1 of 2 branches missed.">        if (distToLandFromHighSeas &lt; 0) {</span>
<span class="nc" id="L2147">            throw new RuntimeException(&quot;Land&lt;-&gt;HighSeas distance can not be negative&quot;);</span>
        }
<span class="pc bpc" id="L2149" title="1 of 2 branches missed.">        if (maxDistanceToEdge &lt; 0) {</span>
<span class="nc" id="L2150">            throw new RuntimeException(&quot;Distance to edge can not be negative&quot;);</span>
        }

        // Reset all highSeas tiles to the default ocean type.
<span class="fc bfc" id="L2154" title="All 2 branches covered.">        for (Tile t : getAllTiles()) {</span>
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">            if (t.getType() == highSeas) t.setType(ocean);</span>
        }

<span class="fc" id="L2158">        final int width = getWidth(), height = getHeight();</span>
<span class="fc" id="L2159">        Tile t, seaL = null, seaR = null;</span>
<span class="fc" id="L2160">        int totalL = 0, totalR = 0, distanceL = -1, distanceR = -1;</span>
<span class="fc bfc" id="L2161" title="All 2 branches covered.">        for (int y = 0; y &lt; height; y++) {</span>
<span class="pc bpc" id="L2162" title="1 of 4 branches missed.">            for (int x = 0; x &lt; maxDistanceToEdge &amp;&amp; x &lt; width</span>
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">                     &amp;&amp; isValid(x, y)</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">                     &amp;&amp; (t = getTile(x, y)).getType() == ocean; x++) {</span>
<span class="fc" id="L2165">                Tile other = getLandWithinDistance(x, y,</span>
<span class="fc" id="L2166">                                                   distToLandFromHighSeas);</span>
<span class="fc bfc" id="L2167" title="All 2 branches covered.">                if (other == null) {</span>
<span class="fc" id="L2168">                    t.setType(highSeas);</span>
<span class="fc" id="L2169">                    totalL++;</span>
<span class="fc" id="L2170">                } else {</span>
<span class="fc" id="L2171">                    int distance = t.getDistanceTo(other);</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">                    if (distanceL &lt; distance) {</span>
<span class="fc" id="L2173">                        distanceL = distance;</span>
<span class="fc" id="L2174">                        seaL = t;</span>
                    }
                }
            }
<span class="pc bpc" id="L2178" title="1 of 4 branches missed.">            for (int x = 0; x &lt; maxDistanceToEdge &amp;&amp; x &lt; width</span>
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">                     &amp;&amp; isValid(width-1-x, y)</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">                     &amp;&amp; (t = getTile(width-1-x, y)).getType() == ocean; x++) {</span>
<span class="fc" id="L2181">                Tile other = getLandWithinDistance(width-1-x, y,</span>
<span class="fc" id="L2182">                                                   distToLandFromHighSeas);</span>
<span class="fc bfc" id="L2183" title="All 2 branches covered.">                if (other == null) {</span>
<span class="fc" id="L2184">                    t.setType(highSeas);</span>
<span class="fc" id="L2185">                    totalR++;</span>
<span class="fc" id="L2186">                } else {</span>
<span class="fc" id="L2187">                    int distance = t.getDistanceTo(other);</span>
<span class="fc bfc" id="L2188" title="All 2 branches covered.">                    if (distanceR &lt; distance) {</span>
<span class="fc" id="L2189">                        distanceR = distance;</span>
<span class="fc" id="L2190">                        seaR = t;</span>
                    }
                }
            }
        }
<span class="pc bpc" id="L2195" title="3 of 4 branches missed.">        if (totalL &lt;= 0 &amp;&amp; seaL != null) {</span>
<span class="nc" id="L2196">            seaL.setType(highSeas);</span>
<span class="nc" id="L2197">            totalL++;</span>
        }
<span class="pc bpc" id="L2199" title="3 of 4 branches missed.">        if (totalR &lt;= 0 &amp;&amp; seaR != null) {</span>
<span class="nc" id="L2200">            seaR.setType(highSeas);</span>
<span class="nc" id="L2201">            totalR++;</span>
        }
<span class="pc bpc" id="L2203" title="2 of 4 branches missed.">        if (totalL &lt;= 0 || totalR &lt;= 0) {</span>
<span class="nc" id="L2204">            logger.warning(&quot;No high seas on &quot;</span>
<span class="nc bnc" id="L2205" title="All 4 branches missed.">                + ((totalL &lt;= 0 &amp;&amp; totalR &lt;= 0) ? &quot;either&quot;</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">                    : (totalL &lt;= 0) ? &quot;left&quot;</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">                    : (totalR &lt;= 0) ? &quot;right&quot;</span>
<span class="nc" id="L2208">                    : &quot;BOGUS&quot;) + &quot; side of the map.&quot;</span>
<span class="nc" id="L2209">                + &quot;  This can cause failures on small test maps.&quot;);</span>
        }
<span class="fc" id="L2211">    }</span>

    /**
     * Sets the high seas count for all tiles connected to the high seas.
     * Any ocean tiles on the map vertical edges that do not have an
     * explicit false moveToEurope attribute are given a true one.
     *
     * Set all high seas counts negative, then start with a count of
     * zero for tiles with the moveToEurope attribute or of a type
     * with that ability.  Iterate outward by neighbouring tile,
     * incrementing the count on each pass, stopping at land.  Thus,
     * only the coastal land tiles will have a non-negative high seas
     * count.  This significantly speeds up the colony site evaluator,
     * as it does not have to try to find a path to Europe for each
     * tile.
     */
    public void resetHighSeasCount() {
<span class="fc" id="L2228">        List&lt;Tile&gt; curr = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2229">        List&lt;Tile&gt; next = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2230">        int hsc = 0;</span>
<span class="fc bfc" id="L2231" title="All 2 branches covered.">        for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2232">            t.setHighSeasCount(-1);</span>
<span class="fc bfc" id="L2233" title="All 2 branches covered.">            if (!t.isLand()) {</span>
<span class="fc bfc" id="L2234" title="All 4 branches covered.">                if ((t.getX() == 0 || t.getX() == getWidth()-1)</span>
<span class="pc bpc" id="L2235" title="1 of 2 branches missed.">                    &amp;&amp; t.getType() != null</span>
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">                    &amp;&amp; t.getType().isHighSeasConnected()</span>
<span class="fc bfc" id="L2237" title="All 2 branches covered.">                    &amp;&amp; !t.getType().isDirectlyHighSeasConnected()</span>
<span class="fc bfc" id="L2238" title="All 2 branches covered.">                    &amp;&amp; t.getMoveToEurope() == null) {</span>
<span class="fc" id="L2239">                    t.setMoveToEurope(Boolean.TRUE);</span>
                }
<span class="fc bfc" id="L2241" title="All 2 branches covered.">                if (t.isDirectlyHighSeasConnected()) {</span>
<span class="fc" id="L2242">                    t.setHighSeasCount(hsc);</span>
<span class="fc" id="L2243">                    next.add(t);</span>
                }
            }
        }
<span class="fc bfc" id="L2247" title="All 2 branches covered.">        while (!next.isEmpty()) {</span>
<span class="fc" id="L2248">            hsc++;</span>
<span class="fc" id="L2249">            curr.addAll(next);</span>
<span class="fc" id="L2250">            next.clear();</span>
<span class="fc bfc" id="L2251" title="All 2 branches covered.">            while (!curr.isEmpty()) {</span>
<span class="fc" id="L2252">                Tile tile = curr.remove(0);</span>
                // Deliberately using low level access to neighbours
                // rather than Tile.getSurroundingTiles() because that
                // relies on the map being attached to the game, which
                // is not necessarily true in the test suite.
<span class="fc" id="L2257">                Position position = new Position(tile.getX(), tile.getY());</span>
<span class="fc bfc" id="L2258" title="All 2 branches covered.">                for (Direction d : Direction.values()) {</span>
<span class="fc" id="L2259">                    Position p = new Position(position, d);</span>
<span class="fc bfc" id="L2260" title="All 2 branches covered.">                    if (isValid(p)) {</span>
<span class="fc" id="L2261">                        Tile t = getTile(p);</span>
<span class="fc bfc" id="L2262" title="All 2 branches covered.">                        if (t.getHighSeasCount() &lt; 0) {</span>
<span class="fc" id="L2263">                            t.setHighSeasCount(hsc);</span>
<span class="fc bfc" id="L2264" title="All 2 branches covered.">                            if (!t.isLand()) next.add(t);</span>
                        }
                    }
                }
            }
        }
<span class="fc" id="L2270">    }</span>

    /**
     * Reset layer to reflect what is actually there.
     */
    public void resetLayers() {
<span class="nc" id="L2276">        boolean regions = false,</span>
<span class="nc" id="L2277">            rivers = false,</span>
<span class="nc" id="L2278">            lostCityRumours = false,</span>
<span class="nc" id="L2279">            resources = false,</span>
<span class="nc" id="L2280">            nativeSettlements = false;</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">        for (Tile t : getAllTiles()) {</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">            regions |= t.getRegion() != null;</span>
<span class="nc" id="L2283">            rivers |= t.hasRiver();</span>
<span class="nc" id="L2284">            lostCityRumours |= t.hasLostCityRumour();</span>
<span class="nc" id="L2285">            resources |= t.hasResource();</span>
<span class="nc" id="L2286">            nativeSettlements |= t.getSettlement() instanceof IndianSettlement;</span>
        }
<span class="nc bnc" id="L2288" title="All 8 branches missed.">        setLayer((rivers &amp;&amp; lostCityRumours &amp;&amp; resources &amp;&amp; nativeSettlements)</span>
<span class="nc" id="L2289">            ? Layer.ALL</span>
<span class="nc bnc" id="L2290" title="All 4 branches missed.">            : (nativeSettlements || lostCityRumours) ? Layer.NATIVES</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">            : (resources) ? Layer.RESOURCES</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">            : (rivers) ? Layer.RIVERS</span>
<span class="nc bnc" id="L2293" title="All 2 branches missed.">            : (regions) ? Layer.REGIONS</span>
<span class="nc" id="L2294">            : Layer.TERRAIN);</span>
<span class="nc" id="L2295">    }</span>

    /**
     * Fix the region parent/child relationships.
     */
    public void fixupRegions() {
<span class="fc bfc" id="L2301" title="All 2 branches covered.">        for (Region r : regions) {</span>
<span class="fc bfc" id="L2302" title="All 2 branches covered.">            if (r.isPacific()) continue;</span>
<span class="fc" id="L2303">            Region p = r.getParent();</span>
            // Mountains and Rivers were setting their parent to the
            // discoverable land region they are created within.  Move them
            // up to being children of the geographic region.
<span class="pc bpc" id="L2307" title="1 of 6 branches missed.">            if (r.getDiscoverable() &amp;&amp; p != null &amp;&amp; p.getDiscoverable()) {</span>
<span class="nc" id="L2308">                p = p.getParent();</span>
<span class="nc" id="L2309">                r.setParent(p);</span>
            }
<span class="fc bfc" id="L2311" title="All 4 branches covered.">            if (p != null &amp;&amp; !p.getChildren().contains(r)) p.addChild(r);</span>
        }
<span class="fc" id="L2313">    }</span>


    // Interface Location
    // getId() inherited.

    /**
     * Gets the location tile.  Obviously not applicable to a Map.
     *
     * @return Null.
     */
    @Override
    public Tile getTile() {
<span class="nc" id="L2326">        return null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabel() {
<span class="nc" id="L2334">        return StringTemplate.key(&quot;newWorld&quot;);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabelFor(Player player) {
<span class="nc" id="L2342">        String name = player.getNewLandName();</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        return (name == null) ? getLocationLabel() : StringTemplate.name(name);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(Locatable locatable) {
        // Used to add units to their entry location.  Dropped as this
        // is handled explicitly in the server.
<span class="nc bnc" id="L2353" title="All 2 branches missed.">        if (locatable instanceof Unit) {</span>
<span class="nc" id="L2354">            throw new RuntimeException(&quot;Disabled Map.add(Unit)&quot;);</span>
        }
<span class="nc" id="L2356">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Locatable locatable) {
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if (locatable instanceof Unit) {</span>
<span class="nc" id="L2365">            Tile tile = locatable.getTile();</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            if (tile != null) return tile.remove(locatable);</span>
        }
<span class="nc" id="L2368">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean contains(Locatable locatable) {
<span class="nc bnc" id="L2376" title="All 2 branches missed.">        return locatable instanceof Unit</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">            &amp;&amp; locatable.getLocation() != null</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">            &amp;&amp; locatable.getLocation().getTile() != null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean canAdd(Locatable locatable) {
<span class="nc" id="L2386">        return locatable instanceof Unit;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getUnitCount() {
<span class="nc" id="L2394">        return -1;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;Unit&gt; getUnitList() {
<span class="nc" id="L2402">        return Collections.&lt;Unit&gt;emptyList();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;Unit&gt; getUnitIterator() {
<span class="nc" id="L2410">        return getUnitList().iterator();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public GoodsContainer getGoodsContainer() {
<span class="nc" id="L2418">        return null; // Obviously irrelevant for a Map.</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Settlement getSettlement() {
<span class="nc" id="L2426">        return null; // Obviously irrelevant for a Map.</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Colony getColony() {
<span class="nc" id="L2434">        return null; // Obviously irrelevant for a Map.</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public IndianSettlement getIndianSettlement() {
<span class="nc" id="L2442">        return null; // Obviously irrelevant for a Map.</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Location up() {
<span class="nc" id="L2450">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getRank() {
<span class="nc" id="L2458">        return Location.LOCATION_RANK_NOWHERE;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toShortString() {
<span class="nc" id="L2466">        return &quot;Map&quot;;</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="fc" id="L2477">        int result = super.checkIntegrity(fix);</span>
<span class="fc bfc" id="L2478" title="All 2 branches covered.">        for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2479">            result = Math.min(result, t.checkIntegrity(fix));</span>
        }
<span class="fc" id="L2481">        return result;</span>
    }


    // Serialization

    private static final String HEIGHT_TAG = &quot;height&quot;;
    private static final String LAYER_TAG = &quot;layer&quot;;
    private static final String MAXIMUM_LATITUDE_TAG = &quot;maximumLatitude&quot;;
    private static final String MINIMUM_LATITUDE_TAG = &quot;minimumLatitude&quot;;
<span class="fc" id="L2491">    private static final String WIDTH_TAG = &quot;width&quot;;</span>
    // @compat 0.10.x, region remediation
<span class="pc" id="L2493">    private final List&lt;Tile&gt; missingRegions = new ArrayList&lt;&gt;();</span>
    // end @compat
    // @compat 0.10.5, nasty I/O hack
<span class="pc" id="L2496">    private boolean fixupHighSeas = false;</span>
    // end @compat


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2505">        super.writeAttributes(xw);</span>

<span class="fc" id="L2507">        xw.writeAttribute(WIDTH_TAG, getWidth());</span>

<span class="fc" id="L2509">        xw.writeAttribute(HEIGHT_TAG, getHeight());</span>

<span class="fc" id="L2511">        xw.writeAttribute(LAYER_TAG, layer);</span>

<span class="fc" id="L2513">        xw.writeAttribute(MINIMUM_LATITUDE_TAG, minimumLatitude);</span>

<span class="fc" id="L2515">        xw.writeAttribute(MAXIMUM_LATITUDE_TAG, maximumLatitude);</span>
<span class="fc" id="L2516">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L2523">        super.writeChildren(xw);</span>

<span class="fc bfc" id="L2525" title="All 2 branches covered.">        for (Region region : toSortedList(regions)) {</span>
<span class="fc" id="L2526">            region.toXML(xw);</span>
        }

<span class="fc bfc" id="L2529" title="All 2 branches covered.">        for (Tile tile: getAllTiles()) {</span>
<span class="fc" id="L2530">            tile.toXML(xw);</span>
        }
<span class="fc" id="L2532">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2539">        super.readAttributes(xr);</span>

<span class="fc" id="L2541">        setLayer(xr.getAttribute(LAYER_TAG, Layer.class, Layer.ALL));</span>

<span class="pc bpc" id="L2543" title="1 of 2 branches missed.">        if (tiles == null) {</span>
<span class="fc" id="L2544">            int width = xr.getAttribute(WIDTH_TAG, -1);</span>
<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">            if (width &lt; 0) {</span>
<span class="nc" id="L2546">                throw new XMLStreamException(&quot;Bogus width: &quot; + width);</span>
            }
               
<span class="fc" id="L2549">            int height = xr.getAttribute(HEIGHT_TAG, -1);</span>
<span class="pc bpc" id="L2550" title="1 of 2 branches missed.">            if (height &lt; 0) {</span>
<span class="nc" id="L2551">                throw new XMLStreamException(&quot;Bogus height: &quot; + height);</span>
            }

<span class="fc" id="L2554">            tiles = new Tile[width][height];</span>
        }

<span class="fc" id="L2557">        minimumLatitude = xr.getAttribute(MINIMUM_LATITUDE_TAG, -90);</span>

<span class="fc" id="L2559">        maximumLatitude = xr.getAttribute(MAXIMUM_LATITUDE_TAG, 90);</span>

<span class="fc" id="L2561">        calculateLatitudePerRow();</span>
<span class="fc" id="L2562">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // The tiles structure is large, and individually
        // overwriteable, so we do not clear it unlike most other containers.

        // @compat 0.10.5
<span class="fc" id="L2573">        fixupHighSeas = false;</span>
        // end @compat

        // @compat 0.10.x
<span class="fc" id="L2577">        missingRegions.clear();</span>
        // end @compat

<span class="fc" id="L2580">        super.readChildren(xr);</span>

        // @compat 0.10.x
<span class="pc bpc" id="L2583" title="2 of 4 branches missed.">        if (getGame().isInServer() &amp;&amp; !missingRegions.isEmpty()) {</span>
<span class="nc" id="L2584">            TerrainGenerator.makeLakes(this, missingRegions);</span>
        }
        // end @compat

        // @compat 0.10.5
<span class="fc bfc" id="L2589" title="All 2 branches covered.">        if (fixupHighSeas) resetHighSeasCount();</span>
        // end @compat

        // Fix up settlement tile ownership in one hit here, avoiding
        // complications with cached tiles within the Tile serialization.
<span class="fc bfc" id="L2594" title="All 2 branches covered.">        for (Tile t : getAllTiles()) {</span>
<span class="fc" id="L2595">            Settlement s = t.getOwningSettlement();</span>
<span class="fc bfc" id="L2596" title="All 2 branches covered.">            if (s != null) s.addTile(t);</span>
        }

        // @compat 0.11.3
        // Maps with incorrect parent/child chains were occurring.
<span class="fc" id="L2601">        fixupRegions();</span>
        // end @compat 0.11.3
<span class="fc" id="L2603">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L2610">        final Game game = getGame();</span>
<span class="fc" id="L2611">        final String tag = xr.getLocalName();</span>

<span class="fc bfc" id="L2613" title="All 2 branches covered.">        if (Region.getTagName().equals(tag)) {</span>
<span class="fc" id="L2614">            addRegion(xr.readFreeColGameObject(game, Region.class));</span>

<span class="pc bpc" id="L2616" title="1 of 2 branches missed.">        } else if (Tile.getTagName().equals(tag)) {</span>
<span class="fc" id="L2617">            Tile t = xr.readFreeColGameObject(game, Tile.class);</span>
<span class="fc" id="L2618">            setTile(t, t.getX(), t.getY());</span>

            // @compat 0.10.x
<span class="pc bpc" id="L2621" title="1 of 2 branches missed.">            if (t.getType() != null</span>
<span class="fc bfc" id="L2622" title="All 2 branches covered.">                &amp;&amp; &quot;model.tile.lake&quot;.equals(t.getType().getId())</span>
<span class="pc bpc" id="L2623" title="1 of 2 branches missed.">                &amp;&amp; t.getRegion() == null) missingRegions.add(t);</span>
            // end @compat

            // @compat 0.10.5
<span class="fc bfc" id="L2627" title="All 2 branches covered.">            if (t.getHighSeasCount() == Tile.FLAG_RECALCULATE) {</span>
<span class="fc" id="L2628">                fixupHighSeas = true;</span>
            }
            // end @compat

<span class="fc" id="L2632">        } else {</span>
<span class="nc" id="L2633">            super.readChild(xr);</span>
        }
<span class="fc" id="L2635">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
<span class="fc" id="L2641">    public String getXMLTagName() { return getTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;map&quot;.
     */
    public static String getTagName() {
<span class="fc" id="L2649">        return &quot;map&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>