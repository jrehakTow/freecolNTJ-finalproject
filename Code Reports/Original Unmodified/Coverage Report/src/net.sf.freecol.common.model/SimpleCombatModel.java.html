<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>SimpleCombatModel.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">SimpleCombatModel.java</span></div><h1>SimpleCombatModel.java</h1><pre class="source lang-java linenums">/**
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import net.sf.freecol.common.model.Modifier.ModifierType;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;
import static net.sf.freecol.common.util.RandomUtils.*;


/**
 * This class implements the original Colonization combat model.
 *
 * The name of this class is laughably wrong.
 *
 * Note that the damage part of any CombatResult is ignored throughout.
 */
public class SimpleCombatModel extends CombatModel {

<span class="fc" id="L47">    private static final Logger logger = Logger.getLogger(SimpleCombatModel.class.getName());</span>

    /**
     * The maximum attack power of a Colony's fortifications against a
     * naval unit.
     */
    public static final int MAXIMUM_BOMBARD_POWER = 48;

    /** A defence percentage bonus that disables the fortification bonus. */
    public static final int STRONG_DEFENCE_THRESHOLD = 150; // percent

<span class="fc" id="L58">    public static final Modifier UNKNOWN_DEFENCE_MODIFIER</span>
<span class="fc" id="L59">        = new Modifier(&quot;bogus&quot;, Modifier.UNKNOWN, ModifierType.ADDITIVE);</span>


    /**
     * Deliberately empty constructor.
     */
<span class="fc" id="L65">    public SimpleCombatModel() {}</span>


    /**
     * Calculates the odds of success in combat.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return The combat odds.
     */
    @Override
    public CombatOdds calculateCombatOdds(FreeColGameObject attacker,
                                          FreeColGameObject defender) {
<span class="fc" id="L78">        return calculateCombatOdds(attacker, defender, null);</span>
    }

    /**
     * Calculates the odds of success in combat.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return The combat odds.
     */
    private CombatOdds calculateCombatOdds(FreeColGameObject attacker,
                                           FreeColGameObject defender,
                                           LogBuilder lb) {
<span class="pc bpc" id="L92" title="2 of 4 branches missed.">        if (attacker == null || defender == null) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">            if (lb != null) lb.add(&quot; odds=unknowable&quot;);</span>
<span class="nc" id="L94">            return new CombatOdds(CombatOdds.UNKNOWN_ODDS);</span>
        }

<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (lb != null) lb.add(&quot; attacker=&quot;, attacker, &quot; &quot;);</span>
<span class="fc" id="L98">        double attackPower = getOffencePower(attacker, defender, lb);</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (lb != null) lb.add(&quot; defender=&quot;, defender, &quot; &quot;);</span>
<span class="fc" id="L100">        double defencePower = getDefencePower(attacker, defender, lb);</span>
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">        if (attackPower == 0.0 &amp;&amp; defencePower == 0.0) {</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (lb != null) lb.add(&quot; odds=unknown&quot;);</span>
<span class="nc" id="L103">            return new CombatOdds(CombatOdds.UNKNOWN_ODDS);</span>
        }
<span class="fc" id="L105">        double victory = attackPower / (attackPower + defencePower);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (lb != null) lb.add(&quot; odds=&quot;, victory);</span>
<span class="fc" id="L107">        return new CombatOdds(victory);</span>
    }

    /**
     * Get the offensive power of a unit attacking another.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return The offensive power.
     */
    @Override
    public double getOffencePower(FreeColGameObject attacker,
                                  FreeColGameObject defender) {
<span class="fc" id="L120">        return getOffencePower(attacker, defender, null);</span>
    }

    /**
     * Helper to log modifiers with.
     *
     * @param lb The &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @param modSet A set of &lt;code&gt;Modifiers&lt;/code&gt; to log.
     */   
    private void logModifiers(LogBuilder lb, Set&lt;Modifier&gt; modSet) {
<span class="fc" id="L130">        lb.addCollection(&quot; &quot;, toSortedList(modSet));</span>
<span class="fc" id="L131">    }</span>

    /**
     * Get the offensive power of a unit attacking another.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return The offensive power.
     */
    private double getOffencePower(FreeColGameObject attacker,
                                   FreeColGameObject defender,
                                   LogBuilder lb) {
<span class="fc" id="L144">        double result = 0.0;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (attacker == null) {</span>
<span class="nc" id="L146">            throw new IllegalStateException(&quot;Null attacker&quot;);</span>

<span class="fc bfc" id="L148" title="All 2 branches covered.">        } else if (combatIsAttackMeasurement(attacker, defender)</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            || combatIsAttack(attacker, defender)</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            || combatIsSettlementAttack(attacker, defender)) {</span>
<span class="fc" id="L151">            Set&lt;Modifier&gt; mods = getOffensiveModifiers(attacker, defender);</span>
<span class="fc" id="L152">            Turn turn = attacker.getGame().getTurn(); </span>
<span class="fc" id="L153">            result = FeatureContainer.applyModifiers(0.0f, turn, mods);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            if (lb != null) {</span>
<span class="fc" id="L155">                logModifiers(lb, mods);</span>
<span class="fc" id="L156">                lb.add(&quot; = &quot;, result);</span>
            }

<span class="pc bnc" id="L159" title="All 2 branches missed.">        } else if (combatIsBombard(attacker, defender)) {</span>
<span class="nc" id="L160">            Settlement attackerSettlement = (Settlement) attacker;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">            if (attackerSettlement.hasAbility(Ability.BOMBARD_SHIPS)) {</span>
<span class="nc" id="L162">                result += sumDouble(attackerSettlement.getTile().getUnitList(),</span>
<span class="nc" id="L163">                                    u -&gt; u.hasAbility(Ability.BOMBARD),</span>
<span class="nc" id="L164">                                    u -&gt; u.getType().getOffence());</span>
            }
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (result &gt; MAXIMUM_BOMBARD_POWER) result = MAXIMUM_BOMBARD_POWER;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (lb != null) lb.add(&quot; bombard=&quot;, result);</span>

<span class="nc" id="L169">        } else {</span>
<span class="nc" id="L170">            throw new IllegalArgumentException(&quot;Bogus combat&quot;);</span>
        }
<span class="fc" id="L172">        return result;</span>
    }

    /**
     * Get the defensive power wrt an attacker.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return The defensive power.
     */
    @Override
    public double getDefencePower(FreeColGameObject attacker,
                                  FreeColGameObject defender) {
<span class="fc" id="L185">        return getDefencePower(attacker, defender, null);</span>
    }

    /**
     * Get the defensive power wrt an attacker.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @param lb An optional &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return The defensive power.
     */
    public double getDefencePower(FreeColGameObject attacker,
                                  FreeColGameObject defender,
                                  LogBuilder lb) {
        double result;
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (combatIsDefenceMeasurement(attacker, defender)</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">            || combatIsAttack(attacker, defender)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            || combatIsSettlementAttack(attacker, defender)</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            || combatIsBombard(attacker, defender)) {</span>
<span class="fc" id="L204">            Set&lt;Modifier&gt; mods = getDefensiveModifiers(attacker, defender);</span>
<span class="fc" id="L205">            Turn turn = defender.getGame().getTurn();</span>
<span class="fc" id="L206">            result = FeatureContainer.applyModifiers(0.0f, turn, mods);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (lb != null) {</span>
<span class="fc" id="L208">                logModifiers(lb, mods);</span>
<span class="fc" id="L209">                lb.add(&quot; = &quot;, result);</span>
            }

<span class="fc" id="L212">        } else {</span>
<span class="nc" id="L213">            throw new IllegalArgumentException(&quot;Bogus combat&quot;);</span>
        }
<span class="fc" id="L215">        return result;</span>
    }

    /**
     * Collect all the offensive modifiers that apply to an attack.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return All the applicable offensive modifiers.
     */
    @Override
    public Set&lt;Modifier&gt; getOffensiveModifiers(FreeColGameObject attacker,
                                               FreeColGameObject defender) {
<span class="fc" id="L228">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
        Modifier m;
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        if (attacker == null) {</span>
<span class="nc" id="L231">            throw new IllegalStateException(&quot;Null attacker&quot;);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        } else if (combatIsAttackMeasurement(attacker, defender)</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">            || combatIsAttack(attacker, defender)</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">            || combatIsSettlementAttack(attacker, defender)) {</span>
<span class="fc" id="L235">            final Unit attackerUnit = (Unit)attacker;</span>
<span class="fc" id="L236">            final Turn turn = attackerUnit.getGame().getTurn();</span>

            // Base offense
<span class="fc" id="L239">            result.add(new Modifier(Modifier.OFFENCE,</span>
<span class="fc" id="L240">                                    attackerUnit.getType().getBaseOffence(),</span>
<span class="fc" id="L241">                                    ModifierType.ADDITIVE,</span>
<span class="fc" id="L242">                                    Specification.BASE_OFFENCE_SOURCE,</span>
<span class="fc" id="L243">                                    Modifier.BASE_COMBAT_INDEX));</span>

            // Unit offensive modifiers, including role+equipment,
            // qualified by unit type so that scopes work
            // @compat 0.11.0
            // getCombatModifiers -&gt; getModifiers one day
<span class="fc" id="L249">            result.addAll(attackerUnit.getCombatModifiers(Modifier.OFFENCE,</span>
<span class="fc" id="L250">                    attackerUnit.getType(), turn));</span>
            // end @compat 0.11.0

            // Special bonuses against certain nation types
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (defender instanceof Ownable) {</span>
<span class="fc" id="L255">                Player owner = ((Ownable)defender).getOwner();</span>
<span class="fc" id="L256">                result.addAll(attackerUnit</span>
<span class="fc" id="L257">                    .getModifiers(Modifier.OFFENCE_AGAINST,</span>
<span class="fc" id="L258">                                  owner.getNationType()));</span>
            }

            // Land/naval specific
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (attackerUnit.isNaval()) {</span>
<span class="fc" id="L263">                addNavalOffensiveModifiers(attackerUnit, result);</span>
<span class="fc" id="L264">            } else {</span>
<span class="fc" id="L265">                addLandOffensiveModifiers(attackerUnit, defender, result);</span>
            }

<span class="pc bnc" id="L268" title="All 2 branches missed.">        } else if (combatIsBombard(attacker, defender)) {</span>
            ; // Bombard strength handled by getOffensePower

<span class="nc" id="L271">        } else {</span>
<span class="nc" id="L272">            throw new IllegalArgumentException(&quot;Bogus combat&quot;);</span>
        }

        // @compat 0.11.0
        // Any modifier with the default modifier index needs to be fixed
<span class="fc bfc" id="L277" title="All 2 branches covered.">        for (Modifier r : result) {</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">            if (r.getModifierIndex() == Modifier.DEFAULT_MODIFIER_INDEX) {</span>
<span class="nc" id="L279">                r.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
            }
        }
        // end @compat 0.11.0

<span class="fc" id="L284">        return result;</span>
    }

    /**
     * Add all the offensive modifiers that apply to a naval attack.
     *
     * @param attacker The attacker.
     * @param result The set of modifiers to add to.
     */
    private void addNavalOffensiveModifiers(Unit attacker,
                                            Set&lt;Modifier&gt; result) {
        // Attack bonus
<span class="fc" id="L296">        final Specification spec = attacker.getSpecification();</span>
<span class="fc" id="L297">        result.addAll(spec.getModifiers(Modifier.ATTACK_BONUS));</span>

        // Goods penalty always applies
<span class="fc" id="L300">        int goodsCount = attacker.getGoodsSpaceTaken();</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (goodsCount &gt; 0) {</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            for (Modifier m : spec.getModifiers(Modifier.CARGO_PENALTY)) {</span>
<span class="fc" id="L303">                Modifier c = new Modifier(m);</span>
<span class="fc" id="L304">                c.setValue(c.getValue() * goodsCount);</span>
<span class="fc" id="L305">                result.add(c);</span>
            }
        }
<span class="fc" id="L308">    }</span>

    /**
     * Add the popular support bonus to the result set if applicable.
     *
     * @param colony The &lt;code&gt;Colony&lt;/code&gt; under attack.
     * @param attacker The attacking &lt;code&gt;Unit&lt;/code&gt;.
     * @param result The set of modifiers to add to.
     */
    private void addPopularSupportBonus(Colony colony, Unit attacker,
                                        Set&lt;Modifier&gt; result) {
<span class="nc" id="L319">        int bonus = colony.getSoL();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (bonus &gt;= 0) {</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (attacker.getOwner().isREF()) bonus = 100 - bonus;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (bonus &gt; 0) {</span>
<span class="nc" id="L323">                result.add(new Modifier(Modifier.POPULAR_SUPPORT,</span>
<span class="nc" id="L324">                                        bonus, ModifierType.PERCENTAGE, colony,</span>
<span class="nc" id="L325">                                        Modifier.GENERAL_COMBAT_INDEX));</span>
            }
        }
<span class="nc" id="L328">    }</span>

    /**
     * Add all the offensive modifiers that apply to a land attack.
     *
     * @param attacker The attacker &lt;code&gt;Unit&lt;/code&gt;.
     * @param defender The defender.
     * @param result The set of modifiers to add to.
     */
    private void addLandOffensiveModifiers(Unit attacker,
                                           FreeColGameObject defender,
                                           Set&lt;Modifier&gt; result) {
<span class="fc" id="L340">        final Specification spec = attacker.getSpecification();</span>

        // Attack bonus
<span class="fc" id="L343">        result.addAll(spec.getModifiers(Modifier.ATTACK_BONUS));</span>

        // Movement penalty
<span class="pc bpc" id="L346" title="1 of 3 branches missed.">        switch (attacker.getMovesLeft()) {</span>
        case 1:
<span class="fc" id="L348">            result.addAll(spec.getModifiers(Modifier.BIG_MOVEMENT_PENALTY));</span>
<span class="fc" id="L349">            break;</span>
        case 2:
<span class="nc" id="L351">            result.addAll(spec.getModifiers(Modifier.SMALL_MOVEMENT_PENALTY));</span>
<span class="nc" id="L352">            break;</span>
        default:
            break;
        }

        // Amphibious attack?
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (combatIsAmphibious(attacker, defender)) {</span>
<span class="nc" id="L359">            result.addAll(spec.getModifiers(Modifier.AMPHIBIOUS_ATTACK));</span>
        }

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (combatIsAttackMeasurement(attacker, defender)) {</span>
            ; // No defender information available

<span class="pc bfc" id="L365" title="All 2 branches covered.">        } else if (combatIsSettlementAttack(attacker, defender)) {</span>
            // Settlement present, apply bombardment bonus
<span class="fc" id="L367">            result.addAll(attacker.getModifiers(Modifier.BOMBARD_BONUS));</span>

            // Popular support bonus
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">            if (combatIsWarOfIndependence(attacker, defender)) {</span>
<span class="nc" id="L371">                addPopularSupportBonus((Colony)defender, attacker, result);</span>
            }

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        } else if (combatIsAttack(attacker, defender)) {</span>
<span class="fc" id="L375">            Unit defenderUnit = (Unit) defender;</span>
<span class="fc" id="L376">            Tile tile = defenderUnit.getTile();</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (tile != null) {</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                if (tile.hasSettlement()) {</span>
                    // Bombard bonus applies to settlement defence
<span class="fc" id="L380">                    result.addAll(attacker</span>
<span class="fc" id="L381">                                  .getModifiers(Modifier.BOMBARD_BONUS));</span>

                    // Popular support bonus
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">                    if (combatIsWarOfIndependence(attacker, defender)) {</span>
<span class="nc" id="L385">                        addPopularSupportBonus((Colony)tile.getSettlement(),</span>
<span class="nc" id="L386">                                               attacker, result);</span>
                    }
<span class="nc" id="L388">                } else {</span>
                    // Ambush bonus in the open = defender's defence
                    // bonus, if defender is REF, or attacker is indian.
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">                    if (isAmbush(attacker, defender)) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                        for (Modifier m : tile.getDefenceModifiers()) {</span>
<span class="nc" id="L393">                            Modifier mod = new Modifier(Modifier.OFFENCE, m);</span>
<span class="nc" id="L394">                            mod.setSource(Specification.AMBUSH_BONUS_SOURCE);</span>
<span class="nc" id="L395">                            result.add(mod);</span>
                        }
                    }
                }
            }

            // Artillery in the open penalty, attacker must be on a
            // tile and neither unit can be in a settlement.
<span class="fc bfc" id="L403" title="All 2 branches covered.">            if (attacker.hasAbility(Ability.BOMBARD)</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                &amp;&amp; attacker.getLocation() instanceof Tile</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                &amp;&amp; attacker.getSettlement() == null</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                &amp;&amp; attacker.getState() != Unit.UnitState.FORTIFIED</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">                &amp;&amp; defenderUnit.getSettlement() == null) {</span>
<span class="fc" id="L408">                result.addAll(spec.getModifiers(Modifier.ARTILLERY_IN_THE_OPEN));</span>
            }
<span class="fc" id="L410">        } else {</span>
<span class="nc" id="L411">            throw new IllegalStateException(&quot;Bogus combat&quot;);</span>
        }
<span class="fc" id="L413">    }</span>

    /**
     * Collect all defensive modifiers when defending against an attack.
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return All the applicable defensive modifiers.
     */
    @Override
    public Set&lt;Modifier&gt; getDefensiveModifiers(FreeColGameObject attacker,
                                               FreeColGameObject defender) {
<span class="fc" id="L425">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (combatIsDefenceMeasurement(attacker, defender)</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            || combatIsAttack(attacker, defender)</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            || combatIsBombard(attacker, defender)) {</span>
<span class="fc" id="L429">            final Unit defenderUnit = (Unit)defender;</span>
<span class="fc" id="L430">            final Turn turn = defenderUnit.getGame().getTurn();</span>

            // Base defence
<span class="fc" id="L433">            result.add(new Modifier(Modifier.DEFENCE,</span>
<span class="fc" id="L434">                                    defenderUnit.getType().getBaseDefence(),</span>
<span class="fc" id="L435">                                    ModifierType.ADDITIVE,</span>
<span class="fc" id="L436">                                    Specification.BASE_DEFENCE_SOURCE,</span>
<span class="fc" id="L437">                                    Modifier.BASE_COMBAT_INDEX));</span>

            // Unit specific
            // @compat 0.11.0
            // getCombatModifiers -&gt; getModifiers one day
<span class="fc" id="L442">            result.addAll(defenderUnit.getCombatModifiers(Modifier.DEFENCE,</span>
<span class="fc" id="L443">                    defenderUnit.getType(), turn));</span>
            // end @compat 0.11.0

            // Land/naval split
<span class="fc bfc" id="L447" title="All 2 branches covered.">            if (defenderUnit.isNaval()) {</span>
<span class="fc" id="L448">                addNavalDefensiveModifiers(defenderUnit, result);</span>
<span class="fc" id="L449">            } else {</span>
<span class="fc" id="L450">                addLandDefensiveModifiers(attacker, defenderUnit, result);</span>
            }

<span class="pc bnc" id="L453" title="All 2 branches missed.">        } else if (combatIsSettlementAttack(attacker, defender)) {</span>
<span class="nc" id="L454">            Settlement settlement = (Settlement)defender;</span>
            // Tile defence bonus
<span class="nc" id="L456">            Tile tile = settlement.getTile();</span>
<span class="nc" id="L457">            result.addAll(tile.getType().getDefenceModifiers());</span>

            // Settlement defence bonus
<span class="nc" id="L460">            result.addAll(settlement.getDefenceModifiers());</span>

            // Not allowed to see inside the settlement.  This only applies 
            // to the pre-combat dialog--- the actual attack is on the
            // unit chosen to defend.
<span class="nc" id="L465">            result.add(UNKNOWN_DEFENCE_MODIFIER);</span>

<span class="nc" id="L467">        } else {</span>
<span class="nc" id="L468">            throw new IllegalArgumentException(&quot;Bogus combat&quot;);</span>
        }

        // @compat 0.11.0
        // Any modifier with the default modifier index needs to be fixed
<span class="fc bfc" id="L473" title="All 2 branches covered.">        for (Modifier r : result) {</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (r.getModifierIndex() == Modifier.DEFAULT_MODIFIER_INDEX) {</span>
<span class="nc" id="L475">                r.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
            }
        }
        // end @compat 0.11.0

<span class="fc" id="L480">        return result;</span>
    }

    /**
     * Add all the defensive modifiers that apply to a naval attack.
     *
     * @param defender The defender &lt;code&gt;Unit&lt;/code&gt;.
     * @param result The set of modifiers to add to.
     */
    private void addNavalDefensiveModifiers(Unit defender,
                                            Set&lt;Modifier&gt; result) {
<span class="fc" id="L491">        final Specification spec = defender.getSpecification();</span>

        // Cargo penalty always applies
<span class="fc" id="L494">        int goodsCount = defender.getVisibleGoodsCount();</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">        if (goodsCount &gt; 0) {</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            for (Modifier m : spec.getModifiers(Modifier.CARGO_PENALTY)) {</span>
<span class="fc" id="L497">                Modifier c = new Modifier(m);</span>
<span class="fc" id="L498">                c.setValue(c.getValue() * goodsCount);</span>
<span class="fc" id="L499">                result.add(c);</span>
            }
        }
<span class="fc" id="L502">    }</span>

    /**
     * Does a given object provide a strong defence bonus?
     *
     * @param fco The &lt;code&gt;FreeColObject&lt;/code&gt; to check.
     * @return True if a strong defence bonus is present.
     */
    private boolean hasStrongDefenceModifier(FreeColObject fco) {
<span class="fc" id="L511">        return any(fco.getDefenceModifiers(),</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            m -&gt; m.getType() == ModifierType.PERCENTAGE</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">                &amp;&amp; m.getValue() &gt;= STRONG_DEFENCE_THRESHOLD);</span>
    }

    /**
     * Add all the defensive modifiers that apply to a land attack.
     *
     * @param attacker The attacker.
     * @param defender The defender &lt;code&gt;Unit&lt;/code&gt;.
     * @param result The set of modifiers to add to.
     */
    private void addLandDefensiveModifiers(FreeColGameObject attacker,
                                           Unit defender,
                                           Set&lt;Modifier&gt; result) {
<span class="fc" id="L526">        final Specification spec = defender.getSpecification();</span>
<span class="fc" id="L527">        final Tile tile = defender.getTile();</span>
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        final Settlement settlement = (tile == null) ? null</span>
<span class="fc" id="L529">            : tile.getSettlement();</span>

<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (tile != null) {</span>
<span class="fc" id="L532">            boolean disableFortified = false;</span>

            // Tile defence bonus
<span class="fc" id="L535">            disableFortified |= hasStrongDefenceModifier(tile.getType());</span>

<span class="fc bfc" id="L537" title="All 2 branches covered.">            if (settlement == null) {</span>
                // PF#73 demonstrated that tile modifiers do not apply
                // for colonies
<span class="fc" id="L540">                result.addAll(tile.getType().getDefenceModifiers());</span>

                // Artillery in the Open penalty
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">                if (defender.hasAbility(Ability.BOMBARD)</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                    &amp;&amp; defender.getState() != Unit.UnitState.FORTIFIED) {</span>
<span class="nc" id="L545">                    result.addAll(spec.getModifiers(Modifier.ARTILLERY_IN_THE_OPEN));</span>
                }

<span class="nc" id="L548">            } else { // In settlement</span>
                // Settlement defence bonus
<span class="fc" id="L550">                result.addAll(settlement.getDefenceModifiers());</span>

                // Artillery defence bonus against an Indian raid
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (defender.hasAbility(Ability.BOMBARD)</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">                    &amp;&amp; attacker != null</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                    &amp;&amp; ((Unit)attacker).getOwner().isIndian()) {</span>
<span class="nc" id="L556">                    result.addAll(spec.getModifiers(Modifier.ARTILLERY_AGAINST_RAID));</span>
                }

                // Automatic defensive role (e.g. Revere)
<span class="fc" id="L560">                Role autoRole = defender.getAutomaticRole();</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (autoRole != null) {</span>
<span class="fc" id="L562">                    result.addAll(autoRole.getDefenceModifiers());</span>
                }

<span class="fc bfc" id="L565" title="All 2 branches covered.">                if (settlement instanceof Colony) {</span>
<span class="fc" id="L566">                    Building stockade = ((Colony)settlement).getStockade();</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">                    if (stockade != null) {</span>
<span class="nc" id="L568">                        disableFortified |= hasStrongDefenceModifier(stockade.getType());</span>
                    }
                }
            }

            // Fortify bonus
<span class="fc bfc" id="L574" title="All 2 branches covered.">            if (defender.getState() == Unit.UnitState.FORTIFIED</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                &amp;&amp; !disableFortified) {</span>
<span class="fc" id="L576">                result.addAll(spec.getModifiers(Modifier.FORTIFIED));</span>
            }
        }
<span class="fc" id="L579">    }</span>

    /**
     * Generates a result of a unit attacking.
     * Takes care to only call the pseudo-random source *once*.
     *
     * @param random A pseudo-random number source.
     * @param attacker The attacker.
     * @param defender The defender.
     * @return The results of the combat.
     */
    @Override
    public List&lt;CombatResult&gt; generateAttackResult(Random random,
        FreeColGameObject attacker, FreeColGameObject defender) {
<span class="fc" id="L593">        LogBuilder lb = new LogBuilder(256);</span>
<span class="fc" id="L594">        lb.add(&quot;Combat&quot;);</span>
<span class="fc" id="L595">        ArrayList&lt;CombatResult&gt; crs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L596">        CombatOdds odds = calculateCombatOdds(attacker, defender, lb);</span>
<span class="fc" id="L597">        double r = randomDouble(logger, &quot;AttackResult&quot;, random);</span>
<span class="fc" id="L598">        lb.add(&quot; random(1.0)=&quot;, r);</span>
<span class="fc" id="L599">        boolean great = false; // Great win or loss?</span>
        String action;

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">        if (combatIsAttack(attacker, defender)) {</span>
<span class="fc" id="L603">            Unit attackerUnit = (Unit) attacker;</span>
<span class="fc" id="L604">            Unit defenderUnit = (Unit) defender;</span>
<span class="fc" id="L605">            action = &quot;Attack&quot;;</span>

            // For random double 0 &lt;= r &lt; 1.0:
            // Partition this range into wins &lt; odds.win and losses above.
            // Within the 0 &lt;= r &lt; odds.win range, partition the first 10%
            // to be great wins and the rest to be ordinary wins.
            //   r &lt; 0.1 * odds.win  =&gt; great win
            //   else r &lt; odds.win   =&gt; win
            // Within the odds.win &lt;= r &lt; 1.0 range, partition the first
            // 20% to be evasions (if defender has the evadeAttack ability),
            // the next 70% to be ordinary losses, and the rest great losses.
            //   r &lt; odds.win + 0.2 * (1.0 - odds.win) = 0.8 * odds.win + 0.2
            //     =&gt; evade
            //   else r &lt; odds.win + (0.2 + 0.7) * (1.0 - odds.win)
            //     = 0.1 * odds.win + 0.9 =&gt; loss
            //   else =&gt; great loss
            // ...and beached ships always lose.
<span class="pc bpc" id="L622" title="1 of 4 branches missed.">            if (r &lt; odds.win || defenderUnit.isBeached()) {</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                great = r &lt; 0.1 * odds.win; // Great Win</span>
<span class="fc" id="L624">                crs.add(CombatResult.WIN);</span>
<span class="fc" id="L625">                resolveAttack(attackerUnit, defenderUnit, great,</span>
                    // Rescale to 0 &lt;= r &lt; 1
<span class="fc" id="L627">                    r / (0.1 * odds.win), crs);</span>
<span class="fc bfc" id="L628" title="All 2 branches covered.">            } else if (r &lt; 0.8 * odds.win + 0.2</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                    &amp;&amp; defenderUnit.hasAbility(Ability.EVADE_ATTACK)) {</span>
<span class="nc" id="L630">                crs.add(CombatResult.NO_RESULT);</span>
<span class="nc" id="L631">                crs.add(CombatResult.EVADE_ATTACK);</span>
<span class="nc" id="L632">            } else {</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                great = r &gt;= 0.1 * odds.win + 0.9; // Great Loss</span>
<span class="fc" id="L634">                crs.add(CombatResult.LOSE);</span>
<span class="fc" id="L635">                resolveAttack(defenderUnit, attackerUnit, great,</span>
                    // Rescaling to 0 &lt;= r &lt; 1
                    // (rearrange: 0.8 * odds.win + 0.2 &lt;= r &lt; 1.0)
<span class="fc" id="L638">                    (1.25 * r - 0.25 - odds.win)/(1.0 - odds.win), crs);</span>
            }

<span class="pc bnc" id="L641" title="All 2 branches missed.">        } else if (combatIsBombard(attacker, defender)) {</span>
<span class="nc" id="L642">            Unit defenderUnit = (Unit) defender;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (!defenderUnit.isNaval()) {</span>
                // One day we might want:
                //   crs.add(CombatResult.SLAUGHTER_UNIT_BOMBARD);
<span class="nc" id="L646">                throw new IllegalStateException(&quot;Bombard of non-naval&quot;);</span>
            }
<span class="nc" id="L648">            action = &quot;Bombard&quot;;</span>

            // The bombard succeeds.
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (r &lt;= odds.win) {</span>
<span class="nc" id="L652">                crs.add(CombatResult.WIN);</span>

                // Great wins occur at most in 1 in 3 of successful bombards,
                // Good defences reduce this proportion.
<span class="nc" id="L656">                double offencePower = getOffencePower(attacker, defender);</span>
<span class="nc" id="L657">                double defencePower = getDefencePower(attacker, defender);</span>
<span class="nc" id="L658">                double diff = Math.max(3.0, defencePower * 2.0 - offencePower);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">                great = r &lt; odds.win / diff;</span>

                // Sink the defender on great wins or lack of repair
                // location, otherwise just damage.
<span class="nc bnc" id="L663" title="All 4 branches missed.">                if (great || defenderUnit.getRepairLocation() == null) {</span>
<span class="nc" id="L664">                    crs.add(CombatResult.SINK_SHIP_BOMBARD);</span>
<span class="nc" id="L665">                } else {</span>
<span class="nc" id="L666">                    crs.add(CombatResult.DAMAGE_SHIP_BOMBARD);</span>
                }

            // The bombard fails but this is not a win for the
            // defender, just an evasion, as it is not currently given
            // an opportunity to return fire.
<span class="nc" id="L672">            } else {</span>
<span class="nc" id="L673">                crs.add(CombatResult.NO_RESULT);</span>
<span class="nc" id="L674">                crs.add(CombatResult.EVADE_BOMBARD);</span>
            }

<span class="nc" id="L677">        } else {</span>
<span class="nc" id="L678">            throw new IllegalStateException(&quot;Bogus combat&quot;);</span>
        }

        // Log the results so that we have a solid record of combat
        // determinations for debugging and investigation of user
        // `I just lost N combats' complaints.
<span class="fc" id="L684">        lb.add(&quot; great=&quot;, great, &quot; &quot;, action);</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        for (CombatResult cr : crs) lb.add(&quot; &quot;, cr);</span>
<span class="fc" id="L686">        lb.log(logger, Level.INFO);</span>

<span class="fc" id="L688">        return crs;</span>
    }

    /**
     * Resolve all the consequences of a normal attack.
     *
     * @param winner The winning &lt;code&gt;Unit&lt;/code&gt;.
     * @param loser The losing &lt;code&gt;Unit&lt;/code&gt;.
     * @param great True if this is a great win/loss.
     * @param r A &quot;residual&quot; random value (for convert/burn mission).
     * @param crs A list of &lt;code&gt;CombatResult&lt;/code&gt;s to add to.
     */
    private void resolveAttack(Unit winner, Unit loser, boolean great,
                               double r, List&lt;CombatResult&gt; crs) {
<span class="fc" id="L702">        Player loserPlayer = loser.getOwner();</span>
<span class="fc" id="L703">        Tile tile = loser.getTile();</span>
<span class="fc" id="L704">        Player winnerPlayer = winner.getOwner();</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">        boolean attackerWon = crs.get(0) == CombatResult.WIN;</span>
<span class="fc" id="L706">        boolean loserMustDie = loser.hasAbility(Ability.DISPOSE_ON_COMBAT_LOSS);</span>

<span class="fc bfc" id="L708" title="All 2 branches covered.">        if (loser.isNaval()) {</span>
            // Naval victors get to loot the defenders hold.  Sink the
            // loser on great win/loss, lack of repair location, or
            // beached.
<span class="pc bpc" id="L712" title="2 of 4 branches missed.">            if (winner.isNaval() &amp;&amp; winner.canCaptureGoods()</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                &amp;&amp; !loser.getGoodsList().isEmpty()) {</span>
<span class="fc" id="L714">                crs.add(CombatResult.LOOT_SHIP);</span>
            }
<span class="pc bpc" id="L716" title="2 of 4 branches missed.">            if (great || loserMustDie</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">                || loser.getRepairLocation() == null</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">                || loser.isBeached()) {</span>
<span class="nc" id="L719">                crs.add(CombatResult.SINK_SHIP_ATTACK);</span>
<span class="nc" id="L720">            } else {</span>
<span class="fc" id="L721">                crs.add(CombatResult.DAMAGE_SHIP_ATTACK);</span>
            }

<span class="fc" id="L724">        } else { // loser is land unit</span>
            // Autoequip the defender?
<span class="fc bfc" id="L726" title="All 2 branches covered.">            Role autoRole = (attackerWon) ? loser.getAutomaticRole() : null;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">            if (autoRole != null) crs.add(CombatResult.AUTOEQUIP_UNIT);</span>

            // Special handling for settlements
<span class="fc" id="L730">            boolean done = false;</span>
<span class="fc" id="L731">            Settlement settlement = tile.getSettlement();</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">            if (settlement instanceof Colony) {</span>
<span class="fc" id="L733">                final Colony colony = (Colony)settlement;</span>
                // A Colony falls to Europeans when the last defender
                // is unarmed.  Natives will pillage if possible but
                // otherwise proceed to kill colonists incrementally
                // until the colony falls for lack of survivors.
                // Ships in a falling colony will be damaged or sunk
                // if they have no repair location.
<span class="fc bfc" id="L740" title="All 4 branches covered.">                if (!loser.isDefensiveUnit() &amp;&amp; autoRole == null) {</span>
<span class="fc" id="L741">                    List&lt;Unit&gt; ships = colony.getTile().getNavalUnits();</span>
<span class="fc bfc" id="L742" title="All 2 branches covered.">                    final CombatResult shipResult = (ships.isEmpty()) ? null</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">                        : (ships.get(0).getRepairLocation() == null)</span>
<span class="nc" id="L744">                        ? CombatResult.SINK_COLONY_SHIPS</span>
<span class="fc" id="L745">                        : CombatResult.DAMAGE_COLONY_SHIPS;</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">                    if (winnerPlayer.isEuropean()) {</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">                        if (loserMustDie) {</span>
<span class="nc" id="L749">                            crs.add(CombatResult.SLAUGHTER_UNIT);</span>
                        }
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">                        if (shipResult != null) crs.add(shipResult);</span>
<span class="fc" id="L752">                        crs.add(CombatResult.CAPTURE_COLONY);</span>
<span class="fc" id="L753">                        done = true;</span>

<span class="pc bpc" id="L755" title="1 of 4 branches missed.">                    } else if (!great &amp;&amp; colony.canBePillaged(winner)) {</span>
<span class="fc" id="L756">                        crs.add(CombatResult.PILLAGE_COLONY);</span>
<span class="fc" id="L757">                        done = true;</span>

<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                    } else if (colony.getUnitCount() &gt; 1</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">                        || loser.getLocation() == tile) {</span>
<span class="fc" id="L761">                        loserMustDie = true;</span>
<span class="fc" id="L762">                        done = false; // Treat as ordinary combat</span>

<span class="fc" id="L764">                    } else {</span>
<span class="fc" id="L765">                        crs.add(CombatResult.SLAUGHTER_UNIT);</span>
<span class="pc bpc" id="L766" title="1 of 2 branches missed.">                        if (shipResult != null) crs.add(shipResult);</span>
<span class="fc" id="L767">                        crs.add(CombatResult.DESTROY_COLONY);</span>
<span class="fc" id="L768">                        done = true;</span>
                    }
                }
 
<span class="fc bfc" id="L772" title="All 2 branches covered.">            } else if (settlement instanceof IndianSettlement) {</span>
<span class="fc" id="L773">                final IndianSettlement is = (IndianSettlement)settlement;</span>
                // Attacking and defeating the defender of a native
                // settlement with a mission may yield converts but
                // also may provoke the burning of all missions.
                // Native settlements fall when there are no units
                // present either in-settlement or on the settlement
                // tile.
<span class="fc" id="L780">                int lose = 0;</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">                if (loserMustDie) {</span>
                    // Add death of loser before any convert captures,
                    // or the RNG might randomly decide to convert the
                    // unit that is then slaughtered.
<span class="fc" id="L785">                    crs.add(CombatResult.SLAUGHTER_UNIT);</span>
<span class="fc" id="L786">                    lose++;</span>
                    // For now, no usual unit combat actions can proceed,
                    // which means we can not expect to capture equipment
                    // from settlements without untangling this dependency.
<span class="fc" id="L790">                    done = true;</span>
                }
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">                if (attackerWon) {</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">                    if (r &lt; winner.getConvertProbability()) {</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">                        if (is.getUnitCount() + tile.getUnitCount() &gt; lose</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">                            &amp;&amp; is.hasMissionary(winnerPlayer)</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                            &amp;&amp; !combatIsAmphibious(winner, loser)) {</span>
<span class="fc" id="L797">                            crs.add(CombatResult.CAPTURE_CONVERT);</span>
<span class="fc" id="L798">                            lose++;</span>
                        }
<span class="pc bnc" id="L800" title="All 2 branches missed.">                    } else if (r &gt;= 1.0 - winner.getBurnProbability()) {</span>
<span class="nc" id="L801">                        if (any(loserPlayer.getIndianSettlements(),</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">                                s -&gt; s.hasMissionary(winnerPlayer))) {</span>
<span class="nc" id="L803">                            crs.add(CombatResult.BURN_MISSIONS);</span>
                        }
                    }
                }
<span class="pc bpc" id="L807" title="1 of 2 branches missed.">                if (settlement.getUnitCount() + tile.getUnitCount() &lt;= lose) {</span>
<span class="nc" id="L808">                    crs.add(CombatResult.DESTROY_SETTLEMENT);</span>
<span class="nc" id="L809">                    done = true;</span>
                }
            }

<span class="fc bfc" id="L813" title="All 2 branches covered.">            if (!done) {</span>
<span class="fc" id="L814">                final Role loserRole = loser.getRole();</span>
                // First check if the loser was automatically armed, and
                // if so see if the winner can capture that equipment,
                // which may kill or demote the loser.
<span class="fc bfc" id="L818" title="All 2 branches covered.">                if (autoRole != null) {</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">                    crs.add((winner.canCaptureEquipment(autoRole) != null)</span>
<span class="nc" id="L820">                        ? CombatResult.CAPTURE_AUTOEQUIP</span>
<span class="fc" id="L821">                        : CombatResult.LOSE_AUTOEQUIP);</span>
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                    if (loserMustDie) {</span>
<span class="nc" id="L823">                        crs.add(CombatResult.SLAUGHTER_UNIT);</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">                    } else if (loser.hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST)) {</span>
<span class="nc" id="L825">                        crs.add(CombatResult.DEMOTE_UNIT);</span>
                    }

                // Some losers are just doomed (e.g. seasonedScout), do not
                // check for capture/demote/lose-equipment.
<span class="pc bfc" id="L830" title="All 2 branches covered.">                } else if (loserMustDie) {</span>
<span class="fc" id="L831">                    crs.add(CombatResult.SLAUGHTER_UNIT);</span>

                // Then check if the user had other offensive
                // role-equipment, that can be captured or lost, which
                // may kill or demote the loser.
<span class="fc bfc" id="L836" title="All 2 branches covered.">                } else if (loserRole.isOffensive()) {</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                    crs.add((winner.canCaptureEquipment(loserRole) != null)</span>
<span class="fc" id="L838">                        ? CombatResult.CAPTURE_EQUIP</span>
<span class="fc" id="L839">                        : CombatResult.LOSE_EQUIP);</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">                    if (loserMustDie</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">                        || loser.losingEquipmentKillsUnit()) {</span>
<span class="nc" id="L842">                        crs.add(CombatResult.SLAUGHTER_UNIT);</span>
<span class="pc bfc" id="L843" title="All 2 branches covered.">                    } else if (loser.losingEquipmentDemotesUnit()) {</span>
<span class="fc" id="L844">                        crs.add(CombatResult.DEMOTE_UNIT);</span>
                    }

                // But some can be captured.
<span class="fc bfc" id="L848" title="All 2 branches covered.">                } else if (loser.hasAbility(Ability.CAN_BE_CAPTURED)</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">                    &amp;&amp; winner.hasAbility(Ability.CAPTURE_UNITS)</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">                    &amp;&amp; !combatIsAmphibious(winner, loser)) {</span>
                    // Demotion on capture is handled by capture routine.
<span class="fc" id="L852">                    crs.add(CombatResult.CAPTURE_UNIT);</span>

                // Or losing just causes a demotion.
<span class="fc bfc" id="L855" title="All 2 branches covered.">                } else if (loser.getTypeChange(ChangeType.DEMOTION,</span>
<span class="fc" id="L856">                                               loserPlayer) != null) {</span>
<span class="fc" id="L857">                    crs.add(CombatResult.DEMOTE_UNIT);</span>

                // But finally, the default is to kill them.
<span class="fc" id="L860">                } else {</span>
<span class="fc" id="L861">                    crs.add(CombatResult.SLAUGHTER_UNIT);</span>
                }
            }
        }

        // Promote great winners or with automatic promotion, if possible.
<span class="fc" id="L867">        UnitTypeChange promotion = winner.getType()</span>
<span class="fc" id="L868">            .getUnitTypeChange(ChangeType.PROMOTION, winnerPlayer);</span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">        if (promotion != null</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">            &amp;&amp; (winner.hasAbility(Ability.AUTOMATIC_PROMOTION)</span>
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">                || (great</span>
<span class="nc" id="L872">                    &amp;&amp; (100 * (r - Math.floor(r))</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                        &lt;= promotion.getProbability(ChangeType.PROMOTION))))) {</span>
<span class="fc" id="L874">            crs.add(CombatResult.PROMOTE_UNIT);</span>
        }
<span class="fc" id="L876">    }</span>

    /**
     * Could this attack be an ambush?
     *
     * @param attacker The attacker.
     * @param defender The defender.
     * @return True if the attack can be an ambush.
     */
    private boolean isAmbush(FreeColGameObject attacker,
                             FreeColGameObject defender) {
<span class="pc bpc" id="L887" title="2 of 4 branches missed.">        if (attacker instanceof Unit &amp;&amp; defender instanceof Unit) {</span>
<span class="fc" id="L888">            Unit attackerUnit = (Unit)attacker;</span>
<span class="fc" id="L889">            Unit defenderUnit = (Unit)defender;</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">            return attackerUnit.getSettlement() == null</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">                &amp;&amp; attackerUnit.hasTile()</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">                &amp;&amp; defenderUnit.getSettlement() == null</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">                &amp;&amp; defenderUnit.getState() != Unit.UnitState.FORTIFIED</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">                &amp;&amp; defenderUnit.hasTile()</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">                &amp;&amp; (attackerUnit.hasAbility(Ability.AMBUSH_BONUS)</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                    || defenderUnit.hasAbility(Ability.AMBUSH_PENALTY))</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">                &amp;&amp; (attackerUnit.getTile().hasAbility(Ability.AMBUSH_TERRAIN)</span>
<span class="pc bpc" id="L898" title="1 of 2 branches missed.">                    || defenderUnit.getTile().hasAbility(Ability.AMBUSH_TERRAIN));</span>
        }
<span class="nc" id="L900">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>