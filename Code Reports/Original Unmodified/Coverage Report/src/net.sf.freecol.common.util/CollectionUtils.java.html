<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CollectionUtils.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.util</a> &gt; <span class="el_source">CollectionUtils.java</span></div><h1>CollectionUtils.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import net.sf.freecol.common.util.CachingFunction;


/**
 * Collection of small static helper methods using Collections.
 */
<span class="nc" id="L48">public class CollectionUtils {</span>

    /** Trivial integer accumulator. */
<span class="fc" id="L51">    public static final BinaryOperator&lt;Integer&gt; integerAccumulator</span>
<span class="pc" id="L52">        = (i1, i2) -&gt; i1 + i2;</span>

    /** Trivial double accumulator. */
<span class="fc" id="L55">    public static final BinaryOperator&lt;Double&gt; doubleAccumulator</span>
<span class="pc" id="L56">        = (d1, d2) -&gt; d1 + d2;</span>

    /** Useful comparators for mapEntriesBy* */
<span class="fc" id="L59">    public static final Comparator&lt;Integer&gt; ascendingIntegerComparator</span>
<span class="fc" id="L60">        = Comparator.comparingInt(i -&gt; i);</span>
<span class="fc" id="L61">    public static final Comparator&lt;Integer&gt; descendingIntegerComparator</span>
<span class="fc" id="L62">        = ascendingIntegerComparator.reversed();</span>
<span class="fc" id="L63">    public static final Comparator&lt;Double&gt; ascendingDoubleComparator</span>
<span class="fc" id="L64">        = Comparator.comparingDouble(d -&gt; d);</span>
<span class="fc" id="L65">    public static final Comparator&lt;Double&gt; descendingDoubleComparator</span>
<span class="fc" id="L66">        = ascendingDoubleComparator.reversed();</span>
<span class="fc" id="L67">    public static final Comparator&lt;List&lt;?&gt;&gt; ascendingListLengthComparator</span>
<span class="fc" id="L68">        = Comparator.comparingInt(l -&gt; l.size());</span>
<span class="fc" id="L69">    public static final Comparator&lt;List&lt;?&gt;&gt; descendingListLengthComparator</span>
<span class="fc" id="L70">        = ascendingListLengthComparator.reversed();</span>

    
    /**
     * Make an unmodifiable set with specified members.
     *
     * @param &lt;T&gt; The type of the set members.
     * @param members The set members.
     * @return An unmodifiable set containing the members.
     */
    @SafeVarargs
    public static &lt;T&gt; Set&lt;T&gt; makeUnmodifiableSet(T... members) {
<span class="nc" id="L82">        Set&lt;T&gt; tmp = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        for (T t : members) tmp.add(t);</span>
<span class="nc" id="L84">        return Collections.&lt;T&gt;unmodifiableSet(tmp);</span>
    }

    /**
     * Make an unmodifiable list with specified members.
     *
     * @param &lt;T&gt; The type of the list members.
     * @param members The list members.
     * @return An unmodifiable list containing the members.
     */
    @SafeVarargs
    public static &lt;T&gt; List&lt;T&gt; makeUnmodifiableList(T... members) {
<span class="fc" id="L96">        List&lt;T&gt; tmp = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (T t : members) tmp.add(t);</span>
<span class="fc" id="L98">        return Collections.&lt;T&gt;unmodifiableList(tmp);</span>
    }

    /**
     * Appends a value to a list member of a map with a given key.
     *
     * @param &lt;T&gt; The map value collection member type.
     * @param &lt;K&gt; The map key type.
     * @param map The &lt;code&gt;Map&lt;/code&gt; to add to.
     * @param key The key with which to look up the list in the map.
     * @param value The value to append.
     */
    public static &lt;T,K&gt; void appendToMapList(Map&lt;K, List&lt;T&gt;&gt; map,
                                             K key, T value) {
<span class="nc" id="L112">        List&lt;T&gt; l = map.get(key);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L114">            l = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L115">            l.add(value);</span>
<span class="nc" id="L116">            map.put(key, l);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        } else if (!l.contains(value)) {</span>
<span class="nc" id="L118">            l.add(value);</span>
        }
<span class="nc" id="L120">    }</span>

    public static &lt;K,V&gt; void accumulateToMap(Map&lt;K,V&gt; map, K key, V value,
                                             BinaryOperator&lt;V&gt; accumulator) {
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (map.containsKey(key)) {</span>
<span class="nc" id="L125">            map.put(key, accumulator.apply(map.get(key), value));</span>
<span class="nc" id="L126">        } else {</span>
<span class="nc" id="L127">            map.put(key, value);</span>
        }
<span class="nc" id="L129">    }</span>

    public static &lt;K,V&gt; void accumulateMap(Map&lt;K,V&gt; map1, Map&lt;K,V&gt; map2,
                                           BinaryOperator&lt;V&gt; accumulator) {
<span class="nc bnc" id="L133" title="All 2 branches missed.">        for (Entry&lt;K,V&gt; e : map2.entrySet()) {</span>
<span class="nc" id="L134">            accumulateToMap(map1, e.getKey(), e.getValue(), accumulator);</span>
        }
<span class="nc" id="L136">    }</span>

    /**
     * Increment the count in an integer valued map for a given key.
     *
     * @param &lt;K&gt; The map key type.
     * @param map The map to increment within.
     * @param key The key to increment the value for.
     * @return The new count associated with the key.
     */
    public static &lt;K&gt; int incrementMapCount(Map&lt;K, Integer&gt; map, K key) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">        int count = map.containsKey(key) ? map.get(key) : 0;</span>
<span class="nc" id="L148">        map.put(key, count+1);</span>
<span class="nc" id="L149">        return count+1;</span>
    }

    /**
     * Given a list, return an iterable that yields all permutations
     * of the original list.
     *
     * Obviously combinatorial explosion will occur, so use with
     * caution only on lists that are known to be short.
     *
     * @param &lt;T&gt; The list member type.
     * @param l The original list.
     * @return A iterable yielding all the permutations of the original list.
     */
    public static &lt;T&gt; Iterable&lt;List&lt;T&gt;&gt; getPermutations(final List&lt;T&gt; l) {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">        if (l == null) return null;</span>
<span class="fc" id="L165">        return new Iterable&lt;List&lt;T&gt;&gt;() {</span>
            @Override
            public Iterator&lt;List&lt;T&gt;&gt; iterator() {
<span class="fc" id="L168">                return new Iterator&lt;List&lt;T&gt;&gt;() {</span>
<span class="fc" id="L169">                    private final List&lt;T&gt; original = new ArrayList&lt;&gt;(l);</span>
<span class="fc" id="L170">                    private final int n = l.size();</span>
<span class="fc" id="L171">                    private final int np = factorial(n);</span>
<span class="fc" id="L172">                    private int index = 0;</span>

                    private int factorial(int n) {
<span class="fc" id="L175">                        int total = n;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">                        while (--n &gt; 1) total *= n;</span>
<span class="fc" id="L177">                        return total;</span>
                    }

                    @Override
                    public boolean hasNext() {
<span class="fc bfc" id="L182" title="All 2 branches covered.">                        return index &lt; np;</span>
                    }

                    // FIXME: see if we can do it with one array:-)
                    @Override
                    public List&lt;T&gt; next() {
<span class="fc" id="L188">                        List&lt;T&gt; pick = new ArrayList&lt;&gt;(original);</span>
<span class="fc" id="L189">                        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L190">                        int current = index++;</span>
<span class="fc" id="L191">                        int divisor = np;</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                        for (int i = n; i &gt; 0; i--) {</span>
<span class="fc" id="L193">                            divisor /= i;</span>
<span class="fc" id="L194">                            int j = current / divisor;</span>
<span class="fc" id="L195">                            result.add(pick.remove(j));</span>
<span class="fc" id="L196">                            current -= j * divisor;</span>
                        }
<span class="fc" id="L198">                        return result;</span>
                    }

                    @Override
                    public void remove() {
<span class="nc" id="L203">                        throw new RuntimeException(&quot;remove() not implemented&quot;);</span>
                    }
                };
            }
        };
    }

    /**
     * Are all members of a collection the same (in the sense of ==).
     *
     * @param &lt;T&gt; The collection member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to examine.
     * @return True if all members are the same.
     */
    public static &lt;T&gt; boolean allSame(final Collection&lt;T&gt; collection) {
<span class="nc" id="L218">        T datum = null;</span>
<span class="nc" id="L219">        boolean first = true;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        for (T t : collection) {</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">            if (first) datum = t; else if (t != datum) return false;</span>
<span class="nc" id="L222">            first = false;</span>
        }
<span class="nc" id="L224">        return true;</span>
    }

    /**
     * Rotate a list by N places.
     *
     * @param &lt;T&gt; The list member type.
     * @param list The &lt;code&gt;List&lt;/code&gt; to rotate.
     * @param n The number of places to rotate by (positive or negative).
     */
    public static &lt;T&gt; void rotate(final List&lt;T&gt; list, int n) {
<span class="nc" id="L235">        final int len = list.size();</span>
<span class="nc bnc" id="L236" title="All 4 branches missed.">        if (len &lt;= 0 || n == 0) return;</span>
<span class="nc" id="L237">        n %= len;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            for (; n &gt; 0; n--) {</span>
<span class="nc" id="L240">                T t = list.remove(0);</span>
<span class="nc" id="L241">                list.add(t);</span>
            }
<span class="nc" id="L243">        } else {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            for (; n &lt; 0; n++) {</span>
<span class="nc" id="L245">                T t = list.remove(n-1);</span>
<span class="nc" id="L246">                list.add(0, t);</span>
            }
        }
<span class="nc" id="L249">    }</span>

    /**
     * Reverse a list.
     *
     * @param &lt;T&gt; The list member type.
     * @param list The &lt;code&gt;List&lt;/code&gt; to reverse.
     */
    public static &lt;T&gt; void reverse(final List&lt;T&gt; list) {
<span class="nc" id="L258">        final int len = list.size();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (len &lt;= 0) return;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">        for (int i = 0, j = len-1; i &lt; j; i++, j--) {</span>
<span class="nc" id="L261">            T t = list.get(i);</span>
<span class="nc" id="L262">            list.set(i, list.get(j));</span>
<span class="nc" id="L263">            list.set(j, t);</span>
        }
<span class="nc" id="L265">    }</span>

    /**
     * Check if two lists contents are equal but also checks for null.
     *
     * @param &lt;T&gt; The list member type.
     * @param one First list to compare
     * @param two Second list to compare
     * @return True if the list contents are all either both null or
     *     equal in the sense of their equals() method.
     */
    public static &lt;T&gt; boolean listEquals(List&lt;T&gt; one, List&lt;T&gt; two) {
<span class="pc bpc" id="L277" title="3 of 4 branches missed.">        if (one == null) return two == null;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (two == null) return false;</span>
        
<span class="fc" id="L280">        Iterator&lt;T&gt; oneI = one.iterator();</span>
<span class="fc" id="L281">        Iterator&lt;T&gt; twoI = two.iterator();</span>
        for (;;) {
<span class="fc bfc" id="L283" title="All 2 branches covered.">            if (oneI.hasNext()) {</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                if (twoI.hasNext()) {</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">                    if (!Utils.equals(oneI.next(), twoI.next())) break;</span>
                } else {
                    break;
                }
            } else {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                return !twoI.hasNext();</span>
            }
        }
<span class="fc" id="L293">        return false;</span>
    }                

    /**
     * Get the entries in a map in a sorted order.
     *
     * @param &lt;K&gt; The map key type.
     * @param &lt;V&gt; The map value type.
     * @param map The &lt;code&gt;Map&lt;/code&gt; to extract entries from.
     * @return A list of entries from the map sorted by key.
     */
    public static &lt;K extends Comparable&lt;? super K&gt;,V&gt; List&lt;Entry&lt;K,V&gt;&gt;
        mapEntriesByKey(Map&lt;K, V&gt; map) {
<span class="fc" id="L306">        return toSortedList(map.entrySet().stream(),</span>
<span class="fc" id="L307">                            Comparator.comparing(Entry::getKey));</span>
    }

    /**
     * Get the entries in a map in a sorted order.
     *
     * @param &lt;K&gt; The map key type.
     * @param &lt;V&gt; The map value type.
     * @param map The &lt;code&gt;Map&lt;/code&gt; to extract entries from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; for the values.
     * @return A list of entries from the map sorted by key.
     */
    public static &lt;K,V&gt; List&lt;Entry&lt;K,V&gt;&gt;
        mapEntriesByKey(Map&lt;K, V&gt; map, final Comparator&lt;K&gt; comparator) {
<span class="nc" id="L321">        return toSortedList(map.entrySet().stream(),</span>
<span class="nc" id="L322">                            Comparator.comparing(Entry::getKey, comparator));</span>
    }

    /**
     * Get the entries in a map in a sorted order.
     *
     * @param &lt;K&gt; The map key type.
     * @param &lt;V&gt; The map value type.
     * @param map The &lt;code&gt;Map&lt;/code&gt; to extract entries from.
     * @return A list of entries from the map sorted by key.
     */
    public static &lt;K,V extends Comparable&lt;? super V&gt;&gt; List&lt;Entry&lt;K,V&gt;&gt;
        mapEntriesByValue(Map&lt;K, V&gt; map) {
<span class="fc" id="L335">        return toSortedList(map.entrySet().stream(),</span>
<span class="fc" id="L336">                            Comparator.comparing(Entry::getValue));</span>
    }

    /**
     * Get the entries in a map in a sorted order.
     *
     * @param &lt;K&gt; The map key type.
     * @param &lt;V&gt; The map value type.
     * @param map The &lt;code&gt;Map&lt;/code&gt; to extract entries from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; for the values.
     * @return A list of entries from the map sorted by value.
     */
    public static &lt;K,V&gt; List&lt;Entry&lt;K,V&gt;&gt;
        mapEntriesByValue(Map&lt;K, V&gt; map, final Comparator&lt;V&gt; comparator) {
<span class="fc" id="L350">        return toSortedList(map.entrySet().stream(),</span>
<span class="fc" id="L351">                            Comparator.comparing(Entry::getValue, comparator));</span>
    }

    public static &lt;T&gt; boolean all(T[] array, Predicate&lt;T&gt; predicate) {
<span class="nc" id="L355">        return all(Arrays.stream(array), predicate);</span>
    }

    public static &lt;T&gt; boolean all(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L359">        return all(c.stream(), predicate);</span>
    }

    public static &lt;T&gt; boolean all(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L363">        return stream.allMatch(predicate);</span>
    }

    public static &lt;T&gt; boolean any(T[] array, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L367">        return any(Arrays.stream(array), predicate);</span>
    }

    public static &lt;T&gt; boolean any(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L371">        return any(c.stream(), predicate);</span>
    }

    public static &lt;T&gt; boolean any(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L375">        return stream.anyMatch(predicate);</span>
    }

    public static &lt;T&gt; boolean none(T[] array, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L379">        return none(Arrays.stream(array), predicate);</span>
    }

    public static &lt;T&gt; boolean none(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L383">        return none(c.stream(), predicate);</span>
    }

    public static &lt;T&gt; boolean none(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L387">        return stream.noneMatch(predicate);</span>
    }

    /**
     * Helper to create a caching ToIntFunction.
     *
     * @param &lt;T&gt; The argument type to be converted to int.
     * @param f The integer valued function to cache.
     * @return A caching &lt;code&gt;ToIntFunction&lt;/code&gt;.
     */
    public static &lt;T&gt; ToIntFunction&lt;T&gt; cacheInt(Function&lt;T, Integer&gt; f) {
<span class="fc" id="L398">        return t -&gt; new CachingFunction&lt;T, Integer&gt;(f).apply(t);</span>
    }

    /**
     * Helper to create a caching comparator.
     *
     * @param &lt;T&gt; The argument type to be converted to int.
     * @param f The integer valued function to use in comparison.
     * @return A caching &lt;code&gt;Comparator&lt;/code&gt;.
     */
    public static &lt;T&gt; Comparator&lt;T&gt; cachingIntComparator(Function&lt;T, Integer&gt; f) {
<span class="fc" id="L409">        return Comparator.comparingInt(cacheInt(f));</span>
    }

    /**
     * Helper to create a caching ToDoubleFunction.
     *
     * @param &lt;T&gt; The argument type to be converted to double.
     * @param f The double valued function to cache.
     * @return A caching &lt;code&gt;ToDoubleFunction&lt;/code&gt;.
     */
    public static &lt;T&gt; ToDoubleFunction&lt;T&gt; cacheDouble(Function&lt;T, Double&gt; f) {
<span class="fc" id="L420">        return t -&gt; new CachingFunction&lt;T, Double&gt;(f).apply(t);</span>
    }

    /**
     * Helper to create a caching comparator.
     *
     * @param &lt;T&gt; The argument type to be converted to double.
     * @param f The double valued function to use in comparison.
     * @return A caching &lt;code&gt;Comparator&lt;/code&gt;.
     */
    public static &lt;T&gt; Comparator&lt;T&gt; cachingDoubleComparator(Function&lt;T, Double&gt; f) {
<span class="fc" id="L431">        return Comparator.comparingDouble(cacheDouble(f));</span>
    }

    /**
     * Does a collection contain at least one element that matches a predicate?
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to test with.
     * @return True if the predicate ever succeeds.
     */
    public static &lt;T&gt; boolean contains(Collection&lt;T&gt; c,
                                       Predicate&lt;T&gt; predicate) {
<span class="fc" id="L444">        return c.stream().filter(predicate).findFirst().isPresent();</span>
    }

    /**
     * Count the number of members of an array that match a predicate.
     *
     * @param &lt;T&gt; The array member type.
     * @param array The array to check.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to test with.
     * @return The number of items that matched.
     */
    public static &lt;T&gt; int count(T[] array, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L456">        return count(Arrays.stream(array), predicate);</span>
    }
        
    /**
     * Count the number of members of a collection that match a predicate.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to check.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to test with.
     * @return The number of items that matched.
     */
    public static &lt;T&gt; int count(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L468">        return count(c.stream(), predicate);</span>
    }
        
    /**
     * Count the number of members of a stream that match a predicate.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to check.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to test with.
     * @return The number of items that matched.
     */
    public static &lt;T&gt; int count(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L480">        return (int)stream.filter(predicate).count();</span>
    }
        
    /**
     * Simple stream search for the first item that matches a predicate.
     *
     * @param &lt;T&gt; The array member type.
     * @param array The array to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param fail The result to return on failure.
     * @return The item found, or fail if not found.
     */
    public static &lt;T&gt; T find(T[] array, Predicate&lt;T&gt; predicate, T fail) {
<span class="fc" id="L493">        return find(Arrays.stream(array), predicate, fail);</span>
    }

    /**
     * Simple stream search for the first item that matches a predicate.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @return The item found, or fail if not found.
     */
    public static &lt;T&gt; T find(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate) {
<span class="fc" id="L505">        return find(c, predicate, (T)null);</span>
    }

    /**
     * Simple stream search for the first item that matches a predicate.
     *
     * @param &lt;T&gt; The collection member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param fail The value to return if nothing is found.
     * @return The item found, or fail if not found.
     */
    public static &lt;T&gt; T find(Collection&lt;T&gt; collection, Predicate&lt;T&gt; predicate,
                             T fail) {
<span class="fc" id="L519">        return find(collection.stream(), predicate, fail);</span>
    }

    /**
     * Simple stream search for the first item that matches a predicate.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream A &lt;code&gt;Stream&lt;/code&gt; to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @return The item found, or null if not found.
     */
    public static &lt;T&gt; T find(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate) {
<span class="nc" id="L531">        return find(stream, predicate, null);</span>
    }

    /**
     * Simple stream search for the first item that matches a predicate.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream A &lt;code&gt;Stream&lt;/code&gt; to search.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param fail The value to return if nothing is found.
     * @return The item found, or fail if not found.
     */
    public static &lt;T&gt; T find(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate, T fail) {
<span class="fc" id="L544">        return stream.filter(predicate).findFirst().orElse(fail);</span>
    }

    /**
     * Flatten an array into a stream derived from component collections.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param array The array to flatten.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped collection.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(T[] array,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="nc" id="L558">        final Predicate&lt;T&gt; alwaysTrue = t -&gt; true;</span>
<span class="nc" id="L559">        return flatten(Arrays.stream(array), alwaysTrue, mapper);</span>
    }

    /**
     * Flatten an array into a stream derived from component collections.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param array The array to flatten.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to filter the collection with.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped collection.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(T[] array,
        Predicate&lt;T&gt; predicate,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="nc" id="L575">        return flatten(Arrays.stream(array), predicate, mapper);</span>
    }

    /**
     * Flatten a collection into a stream derived from component collections.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to flatten.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped collection.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(Collection&lt;T&gt; collection,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L589">        final Predicate&lt;T&gt; alwaysTrue = t -&gt; true;</span>
<span class="fc" id="L590">        return flatten(collection.stream(), alwaysTrue, mapper);</span>
    }

    /**
     * Flatten a collection into a stream derived from component collections.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to flatten.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to filter the collection with.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped collection.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(Collection&lt;T&gt; collection,
        Predicate&lt;T&gt; predicate,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L606">        return flatten(collection.stream(), predicate, mapper);</span>
    }

    /**
     * Flatten the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to flatten.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped stream.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(Stream&lt;T&gt; stream,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="nc" id="L620">        final Predicate&lt;T&gt; alwaysTrue = t -&gt; true;</span>
<span class="nc" id="L621">        return flatten(stream, alwaysTrue, mapper);</span>
    }

    /**
     * Flatten the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to flatten.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to filter the collection with.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return A stream of the mapped stream.
     */
    public static &lt;T, R&gt; Stream&lt;R&gt; flatten(Stream&lt;T&gt; stream,
        Predicate&lt;T&gt; predicate,
        Function&lt;? super T, Collection&lt;? extends R&gt;&gt; mapper) {
<span class="fc" id="L637">        return stream.filter(predicate).map(mapper).flatMap(r -&gt; r.stream());</span>
    }
    
    /**
     * Create a stream from an array and an immediate mapping transform.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param array The array to search.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return The resulting &lt;code&gt;Stream&lt;/code&gt;.
     */
    public static &lt;T,R&gt; Stream&lt;R&gt; map(T[] array,
                                      Function&lt;? super T,? extends R&gt; mapper) {
<span class="fc" id="L651">        return Arrays.stream(array).map(mapper);</span>
    }

    /**
     * Create a stream from a collection and an immediate mapping transform.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting stream member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to search.
     * @param mapper A mapping &lt;code&gt;Function&lt;/code&gt; to apply.
     * @return The resulting &lt;code&gt;Stream&lt;/code&gt;.
     */
    public static &lt;T,R&gt; Stream&lt;R&gt; map(Collection&lt;T&gt; collection,
                                      Function&lt;? super T,? extends R&gt; mapper) {
<span class="fc" id="L665">        return collection.stream().map(mapper);</span>
    }

    /**
     * Find the maximum int value in a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to check.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to map the stream to int with.
     * @return The maximum value found, or zero if the input is empty.
     */
    public static &lt;T&gt; int max(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate,
                              ToIntFunction&lt;T&gt; tif) {
<span class="fc" id="L679">        return max(c.stream(), predicate, tif);</span>
    }

    /**
     * Find the maximum int value in a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to check.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to map the stream to int with.
     * @return The maximum value found, or zero if the input is empty.
     */
    public static &lt;T&gt; int max(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                              ToIntFunction&lt;T&gt; tif) {
<span class="fc" id="L693">        return stream.filter(predicate).mapToInt(tif).max().orElse(0);</span>
    }

    /**
     * Find the selected member of a collection that maximizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to maximize from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The maximal value found, or null if none present.
     */
    public static &lt;T&gt; T maximize(Collection&lt;T&gt; c, Comparator&lt;T&gt; comparator) {
<span class="fc" id="L706">        return maximize(c.stream(), p -&gt; true, comparator);</span>
    }

    /**
     * Find the selected member of a collection that maximizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to maximize from.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The maximal value found, or null if none present.
     */
    public static &lt;T&gt; T maximize(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate,
                                 Comparator&lt;T&gt; comparator) {
<span class="fc" id="L721">        return maximize(c.stream(), predicate, comparator);</span>
    }

    /**
     * Find the selected member of a stream that maximizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to maximize from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The maximal value found, or null if none present.
     */
    public static &lt;T&gt; T maximize(Stream&lt;T&gt; stream, Comparator&lt;T&gt; comparator) {
<span class="nc" id="L734">        return maximize(stream, p -&gt; true, comparator);</span>
    }

    /**
     * Find the selected member of a stream that maximizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The collection member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to maximize from.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The maximal value found, or null if none present.
     */
    public static &lt;T&gt; T maximize(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                 Comparator&lt;T&gt; comparator) {
<span class="fc" id="L749">        return stream.filter(predicate).collect(Collectors.maxBy(comparator))</span>
<span class="fc" id="L750">            .orElse(null);</span>
    }

    /**
     * Find the selected member of a collection that minimizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to minimize from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The minimal value found, or null if none present.
     */
    public static &lt;T&gt; T minimize(Collection&lt;T&gt; c, Comparator&lt;T&gt; comparator) {
<span class="nc" id="L763">        return minimize(c.stream(), t -&gt; true, comparator);</span>
    }

    /**
     * Find the selected member of a collection that minimizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to minimize from.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The minimal value found, or null if none present.
     */
    public static &lt;T&gt; T minimize(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate,
                                 Comparator&lt;T&gt; comparator) {
<span class="fc" id="L778">        return minimize(c.stream(), predicate, comparator);</span>
    }

    /**
     * Find the selected member of a stream that minimizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to minimize from.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The minimal value found, or null if none present.
     */
    public static &lt;T&gt; T minimize(Stream&lt;T&gt; stream, Comparator&lt;T&gt; comparator) {
<span class="fc" id="L791">        return minimize(stream, t -&gt; true, comparator);</span>
    }

    /**
     * Find the selected member of a stream that minimizes according
     * to a given comparison.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to minimize from.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to compare with.
     * @return The minimal value found, or null if none present.
     */
    public static &lt;T&gt; T minimize(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                 Comparator&lt;T&gt; comparator) {
<span class="fc" id="L806">        return stream.filter(predicate).collect(Collectors.minBy(comparator))</span>
<span class="fc" id="L807">            .orElse(null);</span>
    }

    /**
     * Take the sum of the members of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to sum.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to convert members to an int.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; int sum(Collection&lt;T&gt; c, ToIntFunction&lt;T&gt; tif) {
<span class="fc" id="L819">        return sum(c.stream(), x -&gt; true, tif);</span>
    }

    /**
     * Take the sum of the members of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to sum.
     * @param tdf A &lt;code&gt;ToDoubleFunction&lt;/code&gt; to convert members
     *     to a double.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; double sumDouble(Collection&lt;T&gt; c,
                                       ToDoubleFunction&lt;T&gt; tdf) {
<span class="fc" id="L833">        return sumDouble(c.stream(), x -&gt; true, tdf);</span>
    }

    /**
     * Take the sum of the members of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to sum.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to map the stream to int with.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; int sum(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate,
                              ToIntFunction&lt;T&gt; tif) {
<span class="fc" id="L847">        return sum(c.stream(), predicate, tif);</span>
    }

    /**
     * Take the sum of the members of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param c The &lt;code&gt;Collection&lt;/code&gt; to sum.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to match with.
     * @param tdf A &lt;code&gt;ToDoubleFunction&lt;/code&gt; to map the stream to
     *     double with.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; double sumDouble(Collection&lt;T&gt; c, Predicate&lt;T&gt; predicate,
                                       ToDoubleFunction&lt;T&gt; tdf) {
<span class="fc" id="L862">        return sumDouble(c.stream(), predicate, tdf);</span>
    }

    /**
     * Take the sum of the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to sum.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to convert members to an int.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; int sum(Stream&lt;T&gt; stream, ToIntFunction&lt;T&gt; tif) {
<span class="nc" id="L874">        return sum(stream, x -&gt; true, tif);</span>
    }

    /**
     * Take the sum of the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to sum.
     * @param tdf A &lt;code&gt;ToDoubleFunction&lt;/code&gt; to convert members
     *     to a double.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; double sumDouble(Stream&lt;T&gt; stream,
                                       ToDoubleFunction&lt;T&gt; tdf) {
<span class="nc" id="L888">        return sumDouble(stream, x -&gt; true, tdf);</span>
    }

    /**
     * Take the sum of the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to sum.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select members.
     * @param tif A &lt;code&gt;ToIntFunction&lt;/code&gt; to convert members to an int.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; int sum(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                              ToIntFunction&lt;T&gt; tif) {
<span class="fc" id="L902">        return stream.filter(predicate).mapToInt(tif).sum();</span>
    }

    /**
     * Take the sum of the members of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to sum.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select members.
     * @param tdf A &lt;code&gt;ToIntFunction&lt;/code&gt; to convert members to a double.
     * @return The sum of the values found.
     */
    public static &lt;T&gt; double sumDouble(Stream&lt;T&gt; stream,
                                       Predicate&lt;T&gt; predicate,
                                       ToDoubleFunction&lt;T&gt; tdf) {
<span class="fc" id="L917">        return stream.filter(predicate).mapToDouble(tdf).sum();</span>
    }

    /**
     * Convenience function to convert an array to a list.
     *
     * @param &lt;T&gt; The array member type.
     * @param array The array to convert.
     * @return A map of the stream contents.
     */
    public static &lt;T&gt; List&lt;T&gt; toList(T[] array) {
<span class="nc" id="L928">        return toList(Arrays.stream(array));</span>
    }

    /**
     * Convenience function to convert a collection to a list.
     *
     * @param &lt;T&gt; The collection member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to convert.
     * @return A map of the stream contents.
     */
    public static &lt;T&gt; Collection&lt;T&gt; toList(Collection&lt;T&gt; collection) {
<span class="nc" id="L939">        return toList(collection.stream());</span>
    }

    /**
     * Convenience function to collect a stream to a list.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to collect.
     * @return A list of the stream contents.
     */
    public static &lt;T&gt; List&lt;T&gt; toList(Stream&lt;T&gt; stream) {
<span class="fc" id="L950">        return stream.collect(Collectors.toList());</span>
    }

    /**
     * Convenience function to convert an array to a sorted list.
     *
     * @param &lt;T&gt; The array member type.
     * @param array The array to convert.
     * @return A list of the stream contents.
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; List&lt;T&gt;
        toSortedList(T[] array) {
<span class="nc" id="L962">        return toSortedList(Arrays.stream(array));</span>
    }

    /**
     * Convenience function to convert a collection to a sorted list.
     *
     * @param &lt;T&gt; The collection member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to convert.
     * @return A list of the stream contents.
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; List&lt;T&gt;
        toSortedList(Collection&lt;T&gt; collection) {
<span class="fc" id="L974">        return toSortedList(collection.stream());</span>
    }

    /**
     * Convenience function to collect a stream to a list.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to collect.
     * @return A list of the stream contents.
     */
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; List&lt;T&gt;
        toSortedList(Stream&lt;T&gt; stream) {
<span class="fc" id="L986">        final Comparator&lt;T&gt; comparator = Comparator.naturalOrder();</span>
<span class="fc" id="L987">        return toSortedList(stream, comparator);</span>
    }

    /**
     * Convenience function to convert an array to a sorted list.
     *
     * @param &lt;T&gt; The array member type.
     * @param array The array to convert.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @return A list of the stream contents.
     */
    public static &lt;T&gt; List&lt;T&gt; toSortedList(T[] array,
                                           Comparator&lt;T&gt; comparator) {
<span class="nc" id="L1000">        return toSortedList(Arrays.stream(array), comparator);</span>
    }

    /**
     * Convenience function to convert a collection to a map.
     *
     * @param &lt;T&gt; The collection member type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to convert.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @return A map of the stream contents.
     */
    public static &lt;T&gt; List&lt;T&gt; toSortedList(Collection&lt;T&gt; collection,
                                           Comparator&lt;T&gt; comparator) {
<span class="nc" id="L1013">        return toSortedList(collection.stream(), comparator);</span>
    }

    /**
     * Convenience function to collect a stream to a list.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to collect.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @return A list of the stream contents.
     */
    public static &lt;T&gt; List&lt;T&gt; toSortedList(Stream&lt;T&gt; stream,
                                           Comparator&lt;T&gt; comparator) {
<span class="fc" id="L1026">        return stream.sorted(comparator).collect(Collectors.toList());</span>
    }

    /**
     * Convenience function to convert a collection to a map.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;K&gt; The key mapper function.
     * @param &lt;V&gt; The value mapper function.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to convert.
     * @param keyMapper A mapping function from datum to key.
     * @param valueMapper A mapping function from datum to value.
     * @return A map of the stream contents.
     */
    public static &lt;T,K,V&gt; Map&lt;K,V&gt; toMap(Collection&lt;T&gt; collection,
        Function&lt;? super T,? extends K&gt; keyMapper,
        Function&lt;? super T,? extends V&gt; valueMapper) {
<span class="fc" id="L1043">        return toMap(collection.stream(), keyMapper, valueMapper);</span>
    }

    /**
     * Convenience function to collect a stream to a map.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;K&gt; The key mapper function.
     * @param &lt;V&gt; The value mapper function.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to collect.
     * @param keyMapper A mapping function from datum to key.
     * @param valueMapper A mapping function from datum to value.
     * @return A map of the stream contents.
     */
    public static &lt;T,K,V&gt; Map&lt;K,V&gt; toMap(Stream&lt;T&gt; stream,
        Function&lt;? super T,? extends K&gt; keyMapper,
        Function&lt;? super T,? extends V&gt; valueMapper) {
<span class="fc" id="L1060">        return stream.collect(Collectors.toMap(keyMapper, valueMapper));</span>
    }

    /**
     * Convenience function to collect a stream to a set.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to collect.
     * @return A set of the stream contents.
     */
    public static &lt;T&gt; Set&lt;T&gt; toSet(Stream&lt;T&gt; stream) {
<span class="nc" id="L1071">        return stream.collect(Collectors.toSet());</span>
    }

    /**
     * Transform the contents of an array.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param array The array to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the predicate matches.
     */
    public static &lt;T,C&gt; C transform(T[] array, Predicate&lt;T&gt; predicate,
                                    Collector&lt;T,?,C&gt; collector) {
<span class="nc" id="L1086">        return fmc(Arrays.stream(array), predicate, i -&gt; i, collector);</span>
    }

    /**
     * Transform the contents of an array.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param array The array to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches.
     */
    public static &lt;T,R,C&gt; C transform(T[] array, Predicate&lt;T&gt; predicate,
                                      Function&lt;? super T, ? extends R&gt; mapper,
                                      Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1104">        return fmc(Arrays.stream(array), predicate, mapper, collector);</span>
    }

    /**
     * Transform the contents of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the predicate matches.
     */
    public static &lt;T,C&gt; C transform(Collection&lt;T&gt; collection,
                                    Predicate&lt;T&gt; predicate,
                                    Collector&lt;T,?,C&gt; collector) {
<span class="fc" id="L1120">        return fmc(collection.stream(), predicate, i -&gt; i, collector);</span>
    }

    /**
     * Transform the contents of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches.
     */
    public static &lt;T,R,C&gt; C transform(Collection&lt;T&gt; collection,
                                      Predicate&lt;T&gt; predicate,
                                      Function&lt;? super T, ? extends R&gt; mapper,
                                      Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1139">        return fmc(collection.stream(), predicate, mapper, collector);</span>
    }

    /**
     * Transform the contents of a stream.
     *
     * @param &lt;T&gt; The stream type.
     * @param &lt;C&gt; The resulting collection type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the predicate matches.
     */
    public static &lt;T,C&gt; C transform(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                    Collector&lt;T,?,C&gt; collector) {
<span class="fc" id="L1154">        return fmc(stream, predicate, i -&gt; i, collector);</span>
    }

    /**
     * Transform the contents of a stream.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches.
     */
    public static &lt;T,R,C&gt; C transform(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                      Function&lt;? super T, ? extends R&gt; mapper,
                                      Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1172">        return fmc(stream, predicate, mapper, collector);</span>
    }

    /**
     * Underlying implementation for the transform functions.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches.
     */
    private static &lt;T,R,C&gt; C fmc(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                 Function&lt;? super T, ? extends R&gt; mapper,
                                 Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1190">        return stream.filter(predicate).map(mapper).collect(collector);</span>
    }

    /**
     * Transform and sort the contents of an array.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param array The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    public static &lt;T,R extends Comparable&lt;? super R&gt;,C&gt; C
        transformAndSort(T[] array, Predicate&lt;T&gt; predicate,
                         Function&lt;? super T, ? extends R&gt; mapper,
                         Collector&lt;R,?,C&gt; collector) {
<span class="nc" id="L1209">        final Comparator&lt;? super R&gt; comparator = Comparator.naturalOrder();</span>
<span class="nc" id="L1210">        return fmcs(Arrays.stream(array), predicate, mapper, comparator,</span>
<span class="nc" id="L1211">                    collector);</span>
    }

    /**
     * Transform and sort the contents of an array.
     *
     * @param &lt;T&gt; The array member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param array The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    public static &lt;T,R,C&gt; C transformAndSort(T[] array, Predicate&lt;T&gt; predicate,
                                             Function&lt;? super T, ? extends R&gt; mapper,
                                             Comparator&lt;? super R&gt; comparator,
                                             Collector&lt;R,?,C&gt; collector) {
<span class="nc" id="L1231">        return fmcs(Arrays.stream(array), predicate, mapper, comparator,</span>
<span class="nc" id="L1232">                    collector);</span>
    }

    /**
     * Transform and sort the contents of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    public static &lt;T,R extends Comparable&lt;? super R&gt;,C&gt; C
        transformAndSort(Collection&lt;T&gt; collection,
                         Predicate&lt;T&gt; predicate,
                         Function&lt;? super T, ? extends R&gt; mapper,
                         Collector&lt;R,?,C&gt; collector) {
<span class="nc" id="L1252">        final Comparator&lt;? super R&gt; comparator = Comparator.naturalOrder();</span>
<span class="nc" id="L1253">        return fmcs(collection.stream(), predicate, mapper, comparator,</span>
<span class="nc" id="L1254">                    collector);</span>
    }

    /**
     * Transform and sort the contents of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    public static &lt;T extends Comparable&lt;? super T&gt;,C&gt; C
        transformAndSort(Collection&lt;T&gt; collection,
                         Predicate&lt;T&gt; predicate,
                         Comparator&lt;? super T&gt; comparator,
                         Collector&lt;T,?,C&gt; collector) {
<span class="fc" id="L1273">        return fmcs(collection.stream(), predicate, i -&gt; i, comparator,</span>
<span class="fc" id="L1274">                    collector);</span>
    }

    /**
     * Transform and sort the contents of a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    public static &lt;T,R,C&gt; C transformAndSort(Collection&lt;T&gt; collection,
                                             Predicate&lt;T&gt; predicate,
                                             Function&lt;? super T, ? extends R&gt; mapper,
                                             Comparator&lt;? super R&gt; comparator,
                                             Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1295">        return fmcs(collection.stream(), predicate, mapper, comparator,</span>
<span class="fc" id="L1296">                    collector);</span>
    }

    /**
     * Underlying implementation for the sorted transform functions.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param comparator A &lt;code&gt;Comparator&lt;/code&gt; to sort with.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The sorted result of collecting the mapped predicate matches.
     */
    private static &lt;T,R,C&gt; C fmcs(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                  Function&lt;? super T, ? extends R&gt; mapper,
                                  Comparator&lt;? super R&gt; comparator,
                                  Collector&lt;R,?,C&gt; collector) {
<span class="fc" id="L1316">        return stream.filter(predicate).map(mapper).sorted(comparator)</span>
<span class="fc" id="L1317">            .collect(collector);</span>
    }
    
    /**
     * Transform and return distinct items from a collection.
     *
     * @param &lt;T&gt; The collection member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param collection The &lt;code&gt;Collection&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches and
     *     removing duplicates.
     */
    public static &lt;T,R extends Comparable&lt;? super R&gt;,C&gt; C
        transformDistinct(Collection&lt;T&gt; collection, Predicate&lt;T&gt; predicate,
                          Function&lt;? super T, ? extends R&gt; mapper,
                          Collector&lt;R,?,C&gt; collector) {
<span class="nc" id="L1337">        final Comparator&lt;? super R&gt; comparator = Comparator.naturalOrder();</span>
<span class="nc" id="L1338">        return fmcd(collection.stream(), predicate, mapper, collector);</span>
    }

    /**
     * Underlying implementation for the distinct transform functions.
     *
     * @param &lt;T&gt; The stream member type.
     * @param &lt;R&gt; The resulting collection member type.
     * @param &lt;C&gt; The resulting collection type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to transform.
     * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; to select the items.
     * @param mapper A function to transform the selected items.
     * @param collector A &lt;code&gt;Collector&lt;/code&gt; to aggregate the results.
     * @return The result of collecting the mapped predicate matches and
     *     removing duplicates.
     */
    private static &lt;T,R,C&gt; C fmcd(Stream&lt;T&gt; stream, Predicate&lt;T&gt; predicate,
                                  Function&lt;? super T, ? extends R&gt; mapper,
                                  Collector&lt;R,?,C&gt; collector) {
<span class="nc" id="L1357">        return stream.filter(predicate).map(mapper).distinct()</span>
<span class="nc" id="L1358">            .collect(collector);</span>
    }
    
    /**
     * Convenience function to convert a stream to an iterable.
     *
     * @param &lt;T&gt; The stream member type.
     * @param stream The &lt;code&gt;Stream&lt;/code&gt; to convert.
     * @return The suitable &lt;code&gt;Iterable&lt;/code&gt;.
     */
    public static &lt;T&gt; Iterable&lt;T&gt; iterable(final Stream&lt;T&gt; stream) {
<span class="nc" id="L1369">        return new Iterable&lt;T&gt;() {</span>
<span class="nc" id="L1370">            public Iterator&lt;T&gt; iterator() { return stream.iterator(); }</span>
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>