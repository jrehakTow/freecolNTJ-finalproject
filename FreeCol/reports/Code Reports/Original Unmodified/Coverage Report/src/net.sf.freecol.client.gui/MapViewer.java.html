<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MapViewer.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.client.gui</a> &gt; <span class="el_source">MapViewer.java</span></div><h1>MapViewer.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.client.gui;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;

import net.sf.freecol.client.ClientOptions;
import net.sf.freecol.client.FreeColClient;
import net.sf.freecol.client.control.FreeColClientHolder;
import net.sf.freecol.common.debug.FreeColDebugger;
import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.BuildableType;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.Game;
import net.sf.freecol.common.model.IndianSettlement;
import net.sf.freecol.common.model.Map;
import net.sf.freecol.common.model.PathNode;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Region;
import net.sf.freecol.common.model.Settlement;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Turn;
import net.sf.freecol.common.model.Unit;

import static net.sf.freecol.common.util.StringUtils.*;


/**
 * MapViewer is a private helper class of Canvas and SwingGUI.
 * 
 * This class is responsible for drawing the map/background on the
 * &lt;code&gt;Canvas&lt;/code&gt;.
 * In addition, the graphical state of the map (focus, active unit..)
 * is currently handled by this class.
 */
public final class MapViewer extends FreeColClientHolder {

<span class="nc" id="L84">    private static final Logger logger = Logger.getLogger(MapViewer.class.getName());</span>

<span class="nc" id="L86">    private static enum BorderType { COUNTRY, REGION }</span>

    private static class TextSpecification {

        public final String text;
        public final Font font;

<span class="nc" id="L93">        public TextSpecification(String newText, Font newFont) {</span>
<span class="nc" id="L94">            text = newText;</span>
<span class="nc" id="L95">            font = newFont;</span>
<span class="nc" id="L96">        }</span>
    }


    private final SwingGUI gui;

    private Dimension size;

    /** Scaled ImageLibrary only used for map painting. */
    private ImageLibrary lib;

    private final TileViewer tv;

    private TerrainCursor cursor;

    private Tile selectedTile;
<span class="nc" id="L112">    private Tile focus = null;</span>
    private Unit activeUnit;

    /** The view mode in use. */
<span class="nc" id="L116">    private int viewMode = 0;</span>

    /** A path to be displayed on the map. */
    private PathNode currentPath;

    /** A path for a current goto order. */
<span class="nc" id="L122">    private PathNode gotoPath = null;</span>
<span class="nc" id="L123">    private boolean gotoStarted = false;</span>

    // Helper variables for displaying the map.
    private int tileHeight, tileWidth, halfHeight, halfWidth,
        topSpace, topRows, /*bottomSpace,*/ bottomRows, leftSpace, rightSpace;

    // The y-coordinate of the Tiles that will be drawn at the bottom
<span class="nc" id="L130">    private int bottomRow = -1;</span>

    // The y-coordinate of the Tiles that will be drawn at the top
    private int topRow;

    // The y-coordinate on the screen (in pixels) of the images of the
    // Tiles that will be drawn at the bottom
    private int bottomRowY;

    // The y-coordinate on the screen (in pixels) of the images of the
    // Tiles that will be drawn at the top
    private int topRowY;

    // The x-coordinate of the Tiles that will be drawn at the left side
    private int leftColumn;

    // The x-coordinate of the Tiles that will be drawn at the right side
    private int rightColumn;

    // The x-coordinate on the screen (in pixels) of the images of the
    // Tiles that will be drawn at the left (can be less than 0)
    private int leftColumnX;

    // Whether the map is currently aligned with the edge.
<span class="nc" id="L154">    private boolean alignedTop = false, alignedBottom = false,</span>
<span class="nc" id="L155">        alignedLeft = false, alignedRight = false;</span>

    // How the map can be scaled
    private static final float MAP_SCALE_MIN = 0.25f;
    private static final float MAP_SCALE_MAX = 2.0f;
    private static final float MAP_SCALE_STEP = 0.25f;

    // The height offset to paint a Unit at (in pixels).
    private static final int UNIT_OFFSET = 20,
        OTHER_UNITS_OFFSET_X = -5, // Relative to the state indicator.
        OTHER_UNITS_OFFSET_Y = 1,
        OTHER_UNITS_WIDTH = 3,
<span class="nc" id="L167">        MAX_OTHER_UNITS = 10;</span>

    private final java.util.Map&lt;Unit, Integer&gt; unitsOutForAnimation;
    private final java.util.Map&lt;Unit, JLabel&gt; unitsOutForAnimationLabels;

    // borders
<span class="nc" id="L173">    private final EnumMap&lt;Direction, Point2D.Float&gt; borderPoints =</span>
<span class="nc" id="L174">        new EnumMap&lt;&gt;(Direction.class);</span>

<span class="nc" id="L176">    private final EnumMap&lt;Direction, Point2D.Float&gt; controlPoints =</span>
<span class="nc" id="L177">        new EnumMap&lt;&gt;(Direction.class);</span>

<span class="nc" id="L179">    private Stroke borderStroke = new BasicStroke(4);</span>

<span class="nc" id="L181">    private Stroke gridStroke = new BasicStroke(1);</span>


    /**
     * The constructor to use.
     *
     * @param freeColClient The &lt;code&gt;FreeColClient&lt;/code&gt; for the game.
     */
    MapViewer(FreeColClient freeColClient) {
<span class="nc" id="L190">        super(freeColClient);</span>
        
<span class="nc" id="L192">        this.gui = (SwingGUI)getGUI();</span>
<span class="nc" id="L193">        this.size = null;</span>

<span class="nc" id="L195">        tv = new TileViewer(freeColClient);</span>
<span class="nc" id="L196">        setImageLibraryAndUpdateData(new ImageLibrary());</span>

<span class="nc" id="L198">        cursor = null;</span>

<span class="nc" id="L200">        unitsOutForAnimation = new HashMap&lt;&gt;();</span>
<span class="nc" id="L201">        unitsOutForAnimationLabels = new HashMap&lt;&gt;();</span>
<span class="nc" id="L202">    }</span>


    /**
     * Gets the contained &lt;code&gt;ImageLibrary&lt;/code&gt;.
     * 
     * @return The image library;
     */
    ImageLibrary getImageLibrary() {
<span class="nc" id="L211">        return lib;</span>
    }

    /**
     * Get the view mode.
     *
     * @return The view mode.
     */
    int getViewMode() {
<span class="nc" id="L220">        return viewMode;</span>
    }

    /**
     * Toggle the current view mode.
     */
    void toggleViewMode() {
<span class="nc" id="L227">        changeViewMode(1 - viewMode);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Change the view mode to a new one.
     *
     * @param newViewMode The new view mode.
     */
    void changeViewMode(int newViewMode) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (newViewMode != viewMode) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            logger.fine(&quot;Changed to &quot; + ((newViewMode == GUI.MOVE_UNITS_MODE)</span>
<span class="nc" id="L238">                    ? &quot;Move Units&quot; : &quot;View Terrain&quot;) + &quot; mode&quot;);</span>
<span class="nc" id="L239">            viewMode = newViewMode;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if(viewMode == GUI.MOVE_UNITS_MODE)</span>
<span class="nc" id="L241">                restartBlinking();</span>
            else
<span class="nc" id="L243">                stopBlinking();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if(activeUnit != null) {</span>
<span class="nc" id="L245">                Tile tile = activeUnit.getTile();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                if(isTileVisible(tile))</span>
<span class="nc" id="L247">                    gui.refreshTile(tile);</span>
<span class="nc bnc" id="L248" title="All 4 branches missed.">                if(selectedTile != tile &amp;&amp; isTileVisible(selectedTile))</span>
<span class="nc" id="L249">                    gui.refreshTile(selectedTile);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            } else if(isTileVisible(selectedTile))</span>
<span class="nc" id="L251">                gui.refreshTile(selectedTile);</span>
<span class="nc" id="L252">            gui.updateMapControls();</span>
        }
<span class="nc" id="L254">    }</span>

    /**
     * Centers the map on the selected unit.
     */
    void centerActiveUnit() {
<span class="nc bnc" id="L260" title="All 4 branches missed.">        if (activeUnit != null &amp;&amp; activeUnit.getTile() != null) {</span>
<span class="nc" id="L261">            gui.setFocus(activeUnit.getTile());</span>
        }
<span class="nc" id="L263">    }</span>

    /**
     * Converts the given screen coordinates to Map coordinates.
     * It checks to see to which Tile the given pixel 'belongs'.
     *
     * @param x The x-coordinate in pixels.
     * @param y The y-coordinate in pixels.
     * @return The Tile that is located at the given position on the screen.
     */
    Tile convertToMapTile(int x, int y) {
<span class="nc" id="L274">        final Game game = getGame();</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if (game == null || game.getMap() == null) return null;</span>

        int leftOffset;
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (focus.getX() &lt; getLeftColumns()) {</span>
            // we are at the left side of the map
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L281">                leftOffset = tileWidth * focus.getX() + halfWidth;</span>
<span class="nc" id="L282">            } else {</span>
<span class="nc" id="L283">                leftOffset = tileWidth * (focus.getX() + 1);</span>
            }
<span class="nc bnc" id="L285" title="All 2 branches missed.">        } else if (focus.getX() &gt;= (game.getMap().getWidth() - getRightColumns())) {</span>
            // we are at the right side of the map
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L288">                leftOffset = size.width - (game.getMap().getWidth() - focus.getX()) * tileWidth;</span>
<span class="nc" id="L289">            } else {</span>
<span class="nc" id="L290">                leftOffset = size.width - (game.getMap().getWidth() - focus.getX() - 1) * tileWidth - halfWidth;</span>
            }
<span class="nc" id="L292">        } else {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if ((focus.getY() &amp; 1) == 0) {</span>
<span class="nc" id="L294">                leftOffset = (size.width / 2);</span>
<span class="nc" id="L295">            } else {</span>
<span class="nc" id="L296">                leftOffset = (size.width / 2) + halfWidth;</span>
            }
        }

        int topOffset;
<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (focus.getY() &lt; topRows) {</span>
            // we are at the top of the map
<span class="nc" id="L303">            topOffset = (focus.getY() + 1) * (halfHeight);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        } else if (focus.getY() &gt;= (game.getMap().getHeight() - bottomRows)) {</span>
            // we are at the bottom of the map
<span class="nc" id="L306">            topOffset = size.height - (game.getMap().getHeight() - focus.getY()) * (halfHeight);</span>
<span class="nc" id="L307">        } else {</span>
<span class="nc" id="L308">            topOffset = (size.height / 2);</span>
        }

        // At this point (leftOffset, topOffset) is the center pixel
        // of the Tile that was on focus (= the Tile that should have
        // been drawn at the center of the screen if possible).

        // Next, we can calculate the center pixel of the tile-sized
        // rectangle that was clicked. First, we calculate the
        // difference in units of rows and columns.
<span class="nc bnc" id="L318" title="All 2 branches missed.">        int dcol = (x - leftOffset + (x &gt; leftOffset ? halfWidth : -halfWidth))</span>
<span class="nc" id="L319">            / tileWidth;</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">        int drow = (y - topOffset + (y &gt; topOffset ? halfHeight : -halfHeight))</span>
<span class="nc" id="L321">            / tileHeight;</span>
<span class="nc" id="L322">        int px = leftOffset + dcol * tileWidth;</span>
<span class="nc" id="L323">        int py = topOffset + drow * tileHeight;</span>
        // Since rows are shifted, we need to correct.
<span class="nc" id="L325">        int newCol = focus.getX() + dcol;</span>
<span class="nc" id="L326">        int newRow = focus.getY() + drow * 2;</span>
<span class="nc" id="L327">        logger.finest(&quot;Old focus was &quot; + focus.getX() + &quot;, &quot; + focus.getY()</span>
<span class="nc" id="L328">                      + &quot;. Preliminary focus is &quot; + newCol + &quot;, &quot; + newRow + &quot;.&quot;);</span>
        // Now, we check whether the central diamond of the calculated
        // rectangle was clicked, and adjust rows and columns
        // accordingly. See Direction.
<span class="nc" id="L332">        Direction direction = null;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (x &gt; px) {</span>
            // right half of the rectangle
<span class="nc bnc" id="L335" title="All 2 branches missed.">            if (y &gt; py) {</span>
                // bottom right
<span class="nc bnc" id="L337" title="All 2 branches missed.">                if ((y - py) &gt; halfHeight - (x - px)/2) {</span>
<span class="nc" id="L338">                    direction = Direction.SE;</span>
                }
<span class="nc" id="L340">            } else {</span>
                // top right
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if ((y - py) &lt; (x - px)/2 - halfHeight) {</span>
<span class="nc" id="L343">                    direction = Direction.NE;</span>
                }

            }
<span class="nc" id="L347">        } else {</span>
            // left half of the rectangle
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (y &gt; py) {</span>
                // bottom left
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if ((y - py) &gt; (x - px)/2 + halfHeight) {</span>
<span class="nc" id="L352">                    direction = Direction.SW;</span>
                }
<span class="nc" id="L354">            } else {</span>
                // top left
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if ((y - py) &lt; (px - x)/2 - halfHeight) {</span>
<span class="nc" id="L357">                    direction = Direction.NW;</span>
                }
            }
        }
<span class="nc" id="L361">        int col = newCol;</span>
<span class="nc" id="L362">        int row = newRow;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (direction != null) {</span>
<span class="nc" id="L364">            Map.Position step = direction.step(newCol, newRow);</span>
<span class="nc" id="L365">            col = step.x;</span>
<span class="nc" id="L366">            row = step.y;</span>
        }
<span class="nc" id="L368">        logger.finest(&quot;Direction is &quot; + direction</span>
<span class="nc" id="L369">                      + &quot;, new focus is &quot; + col + &quot;, &quot; + row);</span>
<span class="nc" id="L370">        return getGame().getMap().getTile(col, row);</span>

    }

    /**
     * Run some code with the given unit made invisible.  You can nest
     * several of these method calls in order to hide multiple
     * units.  There are no problems related to nested calls with the
     * same unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to be hidden.
     * @param sourceTile The source &lt;code&gt;Tile&lt;/code&gt;.
     * @param r The code to be executed.
     */
    void executeWithUnitOutForAnimation(final Unit unit,
                                        final Tile sourceTile,
                                        final OutForAnimationCallback r) {
<span class="nc" id="L387">        final JLabel unitLabel = enterUnitOutForAnimation(unit, sourceTile);</span>
        try {
<span class="nc" id="L389">            r.executeWithUnitOutForAnimation(unitLabel);</span>
<span class="nc" id="L390">        } finally {</span>
<span class="nc" id="L391">            releaseUnitOutForAnimation(unit);</span>
<span class="nc" id="L392">        }</span>
<span class="nc" id="L393">    }</span>

    private JLabel enterUnitOutForAnimation(final Unit unit,
                                            final Tile sourceTile) {
<span class="nc" id="L397">        Integer i = unitsOutForAnimation.get(unit);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (i == null) {</span>
<span class="nc" id="L399">            final JLabel unitLabel = createUnitLabel(unit);</span>

<span class="nc" id="L401">            i = 1;</span>
<span class="nc" id="L402">            unitLabel.setLocation(calculateUnitLabelPositionInTile(</span>
<span class="nc" id="L403">                    unitLabel.getWidth(), unitLabel.getHeight(),</span>
<span class="nc" id="L404">                    calculateTilePosition(sourceTile)));</span>
<span class="nc" id="L405">            unitsOutForAnimationLabels.put(unit, unitLabel);</span>
<span class="nc" id="L406">            gui.getCanvas().add(unitLabel, JLayeredPane.DEFAULT_LAYER);</span>
<span class="nc" id="L407">        } else {</span>
<span class="nc" id="L408">            i++;</span>
        }
<span class="nc" id="L410">        unitsOutForAnimation.put(unit, i);</span>
<span class="nc" id="L411">        return unitsOutForAnimationLabels.get(unit);</span>
    }

    private void releaseUnitOutForAnimation(final Unit unit) {
<span class="nc" id="L415">        Integer i = unitsOutForAnimation.get(unit);</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (i == null) {</span>
<span class="nc" id="L417">            throw new IllegalStateException(&quot;Tried to release unit that was not out for animation&quot;);</span>
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (i == 1) {</span>
<span class="nc" id="L420">            unitsOutForAnimation.remove(unit);</span>
<span class="nc" id="L421">            gui.getCanvas().removeFromCanvas(unitsOutForAnimationLabels.remove(unit));</span>
<span class="nc" id="L422">        } else {</span>
<span class="nc" id="L423">            i--;</span>
<span class="nc" id="L424">            unitsOutForAnimation.put(unit, i);</span>
        }
<span class="nc" id="L426">    }</span>

    /**
     * Returns true if the given Unit is being animated.
     *
     * @param unit an &lt;code&gt;Unit&lt;/code&gt;
     * @return a &lt;code&gt;boolean&lt;/code&gt;
     */
    private boolean isOutForAnimation(final Unit unit) {
<span class="nc" id="L435">        return unitsOutForAnimation.containsKey(unit);</span>
    }

    /**
     * Draw the unit's image and occupation indicator in one JLabel object.
     *
     * @param unit The unit to be drawn
     * @return A JLabel object with the unit's image.
     */
    private JLabel createUnitLabel(Unit unit) {
<span class="nc" id="L445">        final BufferedImage unitImg = lib.getUnitImage(unit);</span>
<span class="nc" id="L446">        final int width = halfWidth + unitImg.getWidth()/2;</span>
<span class="nc" id="L447">        final int height = unitImg.getHeight();</span>

<span class="nc" id="L449">        BufferedImage img = new BufferedImage(width, height,</span>
<span class="nc" id="L450">                                              BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L451">        Graphics2D g = img.createGraphics();</span>

<span class="nc" id="L453">        final int unitX = (width - unitImg.getWidth()) / 2;</span>
<span class="nc" id="L454">        g.drawImage(unitImg, unitX, 0, null);</span>

<span class="nc" id="L456">        Player player = getMyPlayer();</span>
<span class="nc" id="L457">        String text = Messages.message(unit.getOccupationLabel(player, false));</span>
<span class="nc" id="L458">        g.drawImage(lib.getOccupationIndicatorChip(g, unit, text), 0, 0, null);</span>

<span class="nc" id="L460">        final JLabel label = new JLabel(new ImageIcon(img));</span>
<span class="nc" id="L461">        label.setSize(width, height);</span>

<span class="nc" id="L463">        g.dispose();</span>
<span class="nc" id="L464">        return label;</span>
    }

    /**
     * Calculate the bounds of the rectangle containing a Tile on the
     * screen, and return it.  If the Tile is not on-screen a maximal
     * rectangle is returned.  The bounds includes a one-tile padding
     * area above the Tile, to include the space needed by any units
     * in the Tile.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; on the screen.
     * @return The bounds &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    Rectangle calculateTileBounds(Tile tile) {
<span class="nc" id="L478">        Rectangle result = new Rectangle(0, 0, size.width, size.height);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (isTileVisible(tile)) {</span>
<span class="nc" id="L480">            result.x = ((tile.getX() - leftColumn) * tileWidth) + leftColumnX;</span>
<span class="nc" id="L481">            result.y = ((tile.getY() - topRow) * halfHeight) + topRowY - tileHeight;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">            if ((tile.getY() &amp; 1) != 0) {</span>
<span class="nc" id="L483">                result.x += halfWidth;</span>
            }
<span class="nc" id="L485">            result.width = tileWidth;</span>
<span class="nc" id="L486">            result.height = tileHeight * 2;</span>
        }
<span class="nc" id="L488">        return result;</span>
    }

    /**
     * Gets the position of the given &lt;code&gt;Tile&lt;/code&gt;
     * on the drawn map.
     *
     * @param t The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return The position of the given &lt;code&gt;Tile&lt;/code&gt;, or
     *     &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;Tile&lt;/code&gt; is not drawn on
     *     the mapboard.
     */
    Point calculateTilePosition(Tile t) {
<span class="nc" id="L501">        repositionMapIfNeeded();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (!isTileVisible(t)) return null;</span>

<span class="nc" id="L504">        int x = ((t.getX() - leftColumn) * tileWidth) + leftColumnX;</span>
<span class="nc" id="L505">        int y = ((t.getY() - topRow) * halfHeight) + topRowY;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if ((t.getY() &amp; 1) != 0) x += halfWidth;</span>
<span class="nc" id="L507">        return new Point(x, y);</span>
    }

    int getTileWidth() {
<span class="nc" id="L511">        return tileWidth;</span>
    }

    /**
     * Gets the position where a unitLabel located at tile should be drawn.
     *
     * @param labelWidth The width of the unit label.
     * @param labelHeight The width of the unit label.
     * @param tileP The position of the Tile on the screen.
     * @return The position where to put the label, null if tileP is null.
     */
    Point calculateUnitLabelPositionInTile(int labelWidth,int labelHeight,
                                           Point tileP) {
<span class="nc bnc" id="L524" title="All 2 branches missed.">        if (tileP != null) {</span>
<span class="nc" id="L525">            int labelX = tileP.x + tileWidth</span>
<span class="nc" id="L526">                / 2 - labelWidth / 2;</span>
<span class="nc" id="L527">            int labelY = tileP.y + tileHeight</span>
<span class="nc" id="L528">                / 2 - labelHeight / 2</span>
<span class="nc" id="L529">                - (int) (UNIT_OFFSET * lib.getScaleFactor());</span>
<span class="nc" id="L530">            return new Point(labelX, labelY);</span>
        } else {
<span class="nc" id="L532">            return null;</span>
        }
    }

    /**
     * Checks if the Tile/Units at the given coordinates are displayed
     * on the screen (or, if the map is already displayed and the focus
     * has been changed, whether they will be displayed on the screen
     * the next time it'll be redrawn).
     *
     * @param tileToCheck The position of the Tile in question.
     * @return &lt;i&gt;true&lt;/i&gt; if the Tile will be drawn on the screen,
     *     &lt;i&gt;false&lt;/i&gt; otherwise.
     */
    boolean onScreen(Tile tileToCheck) {
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (tileToCheck == null) return false;</span>
<span class="nc" id="L548">        repositionMapIfNeeded();</span>
<span class="nc bnc" id="L549" title="All 4 branches missed.">        return (tileToCheck.getY() - 2 &gt; topRow || alignedTop)</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">            &amp;&amp; (tileToCheck.getY() + 4 &lt; bottomRow || alignedBottom)</span>
<span class="nc bnc" id="L551" title="All 4 branches missed.">            &amp;&amp; (tileToCheck.getX() - 1 &gt; leftColumn || alignedLeft)</span>
<span class="nc bnc" id="L552" title="All 4 branches missed.">            &amp;&amp; (tileToCheck.getX() + 2 &lt; rightColumn || alignedRight);</span>
    }

    /**
     * Starts the unit-selection-cursor blinking animation.
     */
    void startCursorBlinking() {
<span class="nc" id="L559">        cursor = new TerrainCursor();</span>
<span class="nc" id="L560">        cursor.addActionListener((ActionEvent ae) -&gt; {</span>
<span class="nc" id="L561">                Unit unit = activeUnit;</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                if (unit != null) {</span>
<span class="nc" id="L563">                    Tile tile = unit.getTile();</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                    if (isTileVisible(tile)) gui.refreshTile(tile);</span>
                }
<span class="nc" id="L566">            });</span>
<span class="nc" id="L567">        cursor.startBlinking();</span>
<span class="nc" id="L568">    }</span>

    void stopBlinking() {
<span class="nc" id="L571">        cursor.stopBlinking();</span>
<span class="nc" id="L572">    }</span>

    void restartBlinking() {
<span class="nc" id="L575">        cursor.startBlinking();</span>
<span class="nc" id="L576">    }</span>

    /**
     * Gets the focus of the map. That is the center tile of the displayed
     * map.
     *
     * @return The center tile of the displayed map
     * @see #setFocus(Tile)
     */
    Tile getFocus() {
<span class="nc" id="L586">        return focus;</span>
    }

    /**
     * Sets the focus of the map.
     *
     * @param focus The &lt;code&gt;Position&lt;/code&gt; of the center tile of the
     *     displayed map.
     * @see #getFocus
     */
    void setFocus(Tile focus) {
<span class="nc" id="L597">        this.focus = focus;</span>
<span class="nc" id="L598">        forceReposition();</span>
<span class="nc" id="L599">    }</span>

    /**
     * Sets the focus of the map but offset to the left or right so
     * that the focus position can still be visible when a popup is
     * raised.  If successful, the supplied position will either be at
     * the center of the left or right half of the map.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to display.
     * @return Positive if the focus is on the right hand side, negative
     *     if on the left, zero on failure.
     * @see #getFocus
     */
    int setOffsetFocus(Tile tile) {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (tile == null) return 0;</span>
        int where;
<span class="nc" id="L615">        final Map map = getGame().getMap();</span>
<span class="nc" id="L616">        final int tx = tile.getX(), ty = tile.getY(),</span>
<span class="nc" id="L617">            width = rightColumn - leftColumn;</span>
<span class="nc" id="L618">        int moveX = -1;</span>
<span class="nc" id="L619">        gui.setFocus(tile);</span>
<span class="nc" id="L620">        positionMap(tile);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (leftColumn &lt;= 0) { // At left edge already</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (tx &lt;= width / 4) {</span>
<span class="nc" id="L623">                where = -1;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            } else if (tx &gt;= 3 * width / 4) {</span>
<span class="nc" id="L625">                where = 1;</span>
<span class="nc" id="L626">            } else {</span>
<span class="nc" id="L627">                moveX = tx + width / 4;</span>
<span class="nc" id="L628">                where = -1;</span>
            }
<span class="nc bnc" id="L630" title="All 2 branches missed.">        } else if (rightColumn &gt;= width - 1) { // At right edge</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (tx &gt;= rightColumn - width / 4) {</span>
<span class="nc" id="L632">                where = 1;</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            } else if (tx &lt;= rightColumn - 3 * width / 4) {</span>
<span class="nc" id="L634">                where = -1;</span>
<span class="nc" id="L635">            } else {</span>
<span class="nc" id="L636">                moveX = tx - width / 4;</span>
<span class="nc" id="L637">                where = 1;</span>
            }
<span class="nc" id="L639">        } else { // Move focus left 1/4 screen</span>
<span class="nc" id="L640">            moveX = tx - width / 4;</span>
<span class="nc" id="L641">            where = 1;</span>
        }
<span class="nc bnc" id="L643" title="All 2 branches missed.">        if (moveX &gt;= 0) {</span>
<span class="nc" id="L644">            Tile other = map.getTile(moveX, ty);</span>
<span class="nc" id="L645">            gui.setFocus(other);</span>
<span class="nc" id="L646">            positionMap(other);</span>
        }
<span class="nc" id="L648">        return where;</span>
    }

    /**
     * Force the next screen repaint to reposition the tiles on the window.
     */
    void forceReposition() {
<span class="nc" id="L655">        bottomRow = -1;</span>
<span class="nc" id="L656">    }</span>

    private void repositionMapIfNeeded() {
<span class="nc bnc" id="L659" title="All 4 branches missed.">        if (bottomRow &lt; 0 &amp;&amp; focus != null) positionMap(focus);</span>
<span class="nc" id="L660">    }</span>

    /**
     * Position the map so that the supplied tile is displayed at the center.
     *
     * @param pos The &lt;code&gt;Tile&lt;/code&gt; to center at.
     */
    private void positionMap(Tile pos) {
<span class="nc" id="L668">        final Game game = getGame();</span>
<span class="nc" id="L669">        int x = pos.getX(), y = pos.getY();</span>
<span class="nc" id="L670">        int leftColumns = getLeftColumns(), rightColumns = getRightColumns();</span>

        /*
          PART 1
          ======
          Calculate: bottomRow, topRow, bottomRowY, topRowY
          This will tell us which rows need to be drawn on the screen (from
          bottomRow until and including topRow).
          bottomRowY will tell us at which height the bottom row needs to be
          drawn.
        */
<span class="nc" id="L681">        alignedTop = false;</span>
<span class="nc" id="L682">        alignedBottom = false;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (y &lt; topRows) {</span>
<span class="nc" id="L684">            alignedTop = true;</span>
            // We are at the top of the map
<span class="nc" id="L686">            bottomRow = (size.height / (halfHeight)) - 1;</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if ((size.height % (halfHeight)) != 0) {</span>
<span class="nc" id="L688">                bottomRow++;</span>
            }
<span class="nc" id="L690">            topRow = 0;</span>
<span class="nc" id="L691">            bottomRowY = bottomRow * (halfHeight);</span>
<span class="nc" id="L692">            topRowY = 0;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        } else if (y &gt;= (game.getMap().getHeight() - bottomRows)) {</span>
<span class="nc" id="L694">            alignedBottom = true;</span>
            // We are at the bottom of the map
<span class="nc" id="L696">            bottomRow = game.getMap().getHeight() - 1;</span>

<span class="nc" id="L698">            topRow = size.height / (halfHeight);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if ((size.height % (halfHeight)) &gt; 0) {</span>
<span class="nc" id="L700">                topRow++;</span>
            }
<span class="nc" id="L702">            topRow = game.getMap().getHeight() - topRow;</span>

<span class="nc" id="L704">            bottomRowY = size.height - tileHeight;</span>
<span class="nc" id="L705">            topRowY = bottomRowY - (bottomRow - topRow) * (halfHeight);</span>
<span class="nc" id="L706">        } else {</span>
            // We are not at the top of the map and not at the bottom
<span class="nc" id="L708">            bottomRow = y + bottomRows - 1;</span>
<span class="nc" id="L709">            topRow = y - topRows;</span>
<span class="nc" id="L710">            bottomRowY = topSpace + (halfHeight) * bottomRows;</span>
<span class="nc" id="L711">            topRowY = topSpace - topRows * (halfHeight);</span>
        }

        /*
          PART 2
          ======
          Calculate: leftColumn, rightColumn, leftColumnX
          This will tell us which columns need to be drawn on the screen (from
          leftColumn until and including rightColumn).
          leftColumnX will tell us at which x-coordinate the left
          column needs to be drawn (this is for the Tiles where y&amp;1 == 0;
          the others should be halfWidth more to the right).
        */

<span class="nc" id="L725">        alignedLeft = false;</span>
<span class="nc" id="L726">        alignedRight = false;</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (x &lt; leftColumns) {</span>
            // We are at the left side of the map
<span class="nc" id="L729">            leftColumn = 0;</span>

<span class="nc" id="L731">            rightColumn = size.width / tileWidth - 1;</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if ((size.width % tileWidth) &gt; 0) {</span>
<span class="nc" id="L733">                rightColumn++;</span>
            }

<span class="nc" id="L736">            leftColumnX = 0;</span>
<span class="nc" id="L737">            alignedLeft = true;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        } else if (x &gt;= (game.getMap().getWidth() - rightColumns)) {</span>
            // We are at the right side of the map
<span class="nc" id="L740">            rightColumn = game.getMap().getWidth() - 1;</span>

<span class="nc" id="L742">            leftColumn = size.width / tileWidth;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if ((size.width % tileWidth) &gt; 0) {</span>
<span class="nc" id="L744">                leftColumn++;</span>
            }

<span class="nc" id="L747">            leftColumnX = size.width - tileWidth - halfWidth -</span>
<span class="nc" id="L748">                leftColumn * tileWidth;</span>
<span class="nc" id="L749">            leftColumn = rightColumn - leftColumn;</span>
<span class="nc" id="L750">            alignedRight = true;</span>
<span class="nc" id="L751">        } else {</span>
            // We are not at the left side of the map and not at the right side
<span class="nc" id="L753">            leftColumn = x - leftColumns;</span>
<span class="nc" id="L754">            rightColumn = x + rightColumns;</span>
<span class="nc" id="L755">            leftColumnX = (size.width - tileWidth) / 2</span>
<span class="nc" id="L756">                - leftColumns * tileWidth;</span>
        }
<span class="nc" id="L758">    }</span>

    /**
     * Scroll the map in the given direction.
     *
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; to scroll in.
     * @return True if scrolling occurred.
     */
    boolean scrollMap(Direction direction) {
<span class="nc" id="L767">        Tile t = focus;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (t == null) return false;</span>
<span class="nc" id="L769">        int fx = t.getX(), fy = t.getY();</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if ((t = t.getNeighbourOrNull(direction)) == null) return false;</span>
<span class="nc" id="L771">        int tx = t.getX(), ty = t.getY();</span>
        int x, y;

        // When already close to an edge, resist moving the focus closer,
        // but if moving away immediately jump out of the `nearTo' area.
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if (isMapNearTop(ty) &amp;&amp; isMapNearTop(fy)) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">            y = (ty &lt;= fy) ? fy : topRows;</span>
<span class="nc bnc" id="L778" title="All 4 branches missed.">        } else if (isMapNearBottom(ty) &amp;&amp; isMapNearBottom(fy)) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            y = (ty &gt;= fy) ? fy : getGame().getMap().getWidth()</span>
<span class="nc" id="L780">                - bottomRows;</span>
<span class="nc" id="L781">        } else {</span>
<span class="nc" id="L782">            y = ty;</span>
        }
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if (isMapNearLeft(tx, ty) &amp;&amp; isMapNearLeft(fx, fy)) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            x = (tx &lt;= fx) ? fx : getLeftColumns(ty);</span>
<span class="nc bnc" id="L786" title="All 4 branches missed.">        } else if (isMapNearRight(tx, ty) &amp;&amp; isMapNearRight(fx, fy)) {</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            x = (tx &gt;= fx) ? fx : getGame().getMap().getWidth()</span>
<span class="nc" id="L788">                - getRightColumns(ty);</span>
<span class="nc" id="L789">        } else {</span>
<span class="nc" id="L790">            x = tx;</span>
        }

<span class="nc bnc" id="L793" title="All 4 branches missed.">        if (x == fx &amp;&amp; y == fy) return false;</span>
<span class="nc" id="L794">        gui.setFocus(getGame().getMap().getTile(x,y));</span>
<span class="nc" id="L795">        return true;</span>
    }

    /**
     * Is a y-coordinate near the bottom?
     *
     * @param y The y-coordinate.
     * @return True if near the bottom.
     */
    private boolean isMapNearBottom(int y) {
<span class="nc bnc" id="L805" title="All 2 branches missed.">        return y &gt;= getGame().getMap().getHeight() - bottomRows;</span>
    }

    /**
     * Is an x,y coordinate near the left?
     *
     * @param x The x-coordinate.
     * @param y The y-coordinate.
     * @return True if near the left.
     */
    private boolean isMapNearLeft(int x, int y) {
<span class="nc bnc" id="L816" title="All 2 branches missed.">        return x &lt; getLeftColumns(y);</span>
    }

    /**
     * Is an x,y coordinate near the right?
     *
     * @param x The x-coordinate.
     * @param y The y-coordinate.
     * @return True if near the right.
     */
    private boolean isMapNearRight(int x, int y) {
<span class="nc bnc" id="L827" title="All 2 branches missed.">        return x &gt;= getGame().getMap().getWidth() - getRightColumns(y);</span>
    }

    /**
     * Returns the amount of columns that are to the left of the Tile
     * that is displayed in the center of the Map.
     *
     * @return The amount of columns that are to the left of the Tile
     *     that is displayed in the center of the Map.
     */
    private int getLeftColumns() {
<span class="nc" id="L838">        return getLeftColumns(focus.getY());</span>
    }

    /**
     * Returns the amount of columns that are to the left of the Tile
     * with the given y-coordinate.
     *
     * @param y The y-coordinate of the Tile in question.
     * @return The amount of columns that are to the left of the Tile
     *     with the given y-coordinate.
     */
    private int getLeftColumns(int y) {
<span class="nc" id="L850">        int leftColumns = leftSpace / tileWidth + 1;</span>

<span class="nc bnc" id="L852" title="All 2 branches missed.">        if ((y &amp; 1) == 0) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            if ((leftSpace % tileWidth) &gt; 32) {</span>
<span class="nc" id="L854">                leftColumns++;</span>
            }
<span class="nc" id="L856">        } else {</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if ((leftSpace % tileWidth) == 0) {</span>
<span class="nc" id="L858">                leftColumns--;</span>
            }
        }

<span class="nc" id="L862">        return leftColumns;</span>
    }

    /**
     * Returns the amount of columns that are to the right of the Tile
     * that is displayed in the center of the Map.
     *
     * @return The amount of columns that are to the right of the Tile
     *     that is displayed in the center of the Map.
     */
    private int getRightColumns() {
<span class="nc" id="L873">        return getRightColumns(focus.getY());</span>
    }

    /**
     * Returns the amount of columns that are to the right of the Tile
     * with the given y-coordinate.
     *
     * @param y The y-coordinate of the Tile in question.
     * @return The amount of columns that are to the right of the Tile
     *     with the given y-coordinate.
     */
    private int getRightColumns(int y) {
<span class="nc" id="L885">        int rightColumns = rightSpace / tileWidth + 1;</span>

<span class="nc bnc" id="L887" title="All 2 branches missed.">        if ((y &amp; 1) == 0) {</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">            if ((rightSpace % tileWidth) == 0) {</span>
<span class="nc" id="L889">                rightColumns--;</span>
            }
<span class="nc" id="L891">        } else {</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if ((rightSpace % tileWidth) &gt; 32) {</span>
<span class="nc" id="L893">                rightColumns++;</span>
            }
        }

<span class="nc" id="L897">        return rightColumns;</span>
    }

    /**
     * Is a y-coordinate near the top?
     *
     * @param y The y-coordinate.
     * @return True if near the top.
     */
    private boolean isMapNearTop(int y) {
<span class="nc bnc" id="L907" title="All 2 branches missed.">        return y &lt; topRows;</span>
    }

    private boolean isTileVisible(Tile tile) {
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (tile == null) return false;</span>
<span class="nc bnc" id="L912" title="All 6 branches missed.">        return tile.getY() &gt;= topRow &amp;&amp; tile.getY() &lt;= bottomRow</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">            &amp;&amp; tile.getX() &gt;= leftColumn &amp;&amp; tile.getX() &lt;= rightColumn;</span>
    }

    /**
     * Gets the selected tile.
     *
     * @return The &lt;code&gt;Tile&lt;/code&gt; selected.
     */
    Tile getSelectedTile() {
<span class="nc" id="L922">        return selectedTile;</span>
    }

    /**
     * Selects the tile at the specified position.  There are two
     * possible cases:
     *
     * &lt;ol&gt;
     *   &lt;li&gt;If the tile contains a unit that can become active, then
     *       that unit will be set as the active unit.
     *   &lt;li&gt;If not, the &lt;code&gt;selectedTile&lt;/code&gt; will become the map focus.
     * &lt;/ol&gt;
     *
     * If a unit is active and is located on the selected tile,
     * then nothing (except perhaps a map reposition) will happen.
     *
     * @param newTile The &lt;code&gt;Tile&lt;/code&gt;, the tile to be selected
     * @return True if the focus was set.
     * @see #getSelectedTile
     * @see #setActiveUnit
     * @see #setFocus(Tile)
     */
    boolean setSelectedTile(Tile newTile) {
<span class="nc" id="L945">        Tile oldTile = this.selectedTile;</span>
<span class="nc" id="L946">        boolean ret = false;</span>
<span class="nc" id="L947">        selectedTile = newTile;</span>

<span class="nc bnc" id="L949" title="All 2 branches missed.">        if (viewMode == GUI.MOVE_UNITS_MODE) {</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">            if (activeUnit == null || activeUnit.getTile() != newTile) {</span>
                // select a unit on the selected tile
<span class="nc" id="L952">                Unit unitInFront = findUnitInFront(newTile);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                if (unitInFront != null) {</span>
<span class="nc" id="L954">                    ret = gui.setActiveUnit(unitInFront);</span>
<span class="nc" id="L955">                    updateCurrentPathForActiveUnit();</span>
<span class="nc" id="L956">                } else {</span>
<span class="nc" id="L957">                    gui.setFocus(newTile);</span>
<span class="nc" id="L958">                    ret = true;</span>
                }
            }
        }

        // Check for refocus
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (!onScreen(newTile)</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            || getClientOptions().getBoolean(ClientOptions.ALWAYS_CENTER)) {</span>
<span class="nc" id="L966">            gui.setFocus(newTile);</span>
<span class="nc" id="L967">            ret = true;</span>
<span class="nc" id="L968">        } else {</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">            if (oldTile != null) {</span>
<span class="nc" id="L970">                gui.refreshTile(oldTile);</span>
            }

<span class="nc bnc" id="L973" title="All 2 branches missed.">            if (newTile != null) {</span>
<span class="nc" id="L974">                gui.refreshTile(newTile);</span>
            }
        }
<span class="nc" id="L977">        return ret;</span>
    }

    /**
     * Gets the unit that should be displayed on the given tile.
     *
     * @param unitTile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return The &lt;code&gt;Unit&lt;/code&gt; to display or null if none found.
     */
    private Unit findUnitInFront(Tile unitTile) {
        Unit result;

<span class="nc bnc" id="L989" title="All 4 branches missed.">        if (unitTile == null || unitTile.isEmpty()) {</span>
<span class="nc" id="L990">            result = null;</span>

<span class="nc bnc" id="L992" title="All 4 branches missed.">        } else if (activeUnit != null &amp;&amp; activeUnit.getTile() == unitTile) {</span>
<span class="nc" id="L993">            result = activeUnit;</span>

<span class="nc bnc" id="L995" title="All 2 branches missed.">        } else if (unitTile.hasSettlement()) {</span>
<span class="nc" id="L996">            result = null;</span>

<span class="nc bnc" id="L998" title="All 4 branches missed.">        } else if (activeUnit != null &amp;&amp; activeUnit.isOffensiveUnit()) {</span>
<span class="nc" id="L999">            result = unitTile.getDefendingUnit(activeUnit);</span>

<span class="nc" id="L1001">        } else {</span>
            // Find the unit with the most moves left, preferring
            // active units.
<span class="nc" id="L1004">            List&lt;Unit&gt; units = unitTile.getUnitList();</span>
<span class="nc" id="L1005">            result = units.remove(0);</span>
<span class="nc" id="L1006">            int best = result.getMovesLeft();</span>
            boolean carrier,
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                active = result.getState() == Unit.UnitState.ACTIVE;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            for (Unit u : units) {</span>
<span class="nc" id="L1010">                carrier = false;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                if (active) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                    if (u.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                        if (best &lt; u.getMovesLeft()) {</span>
<span class="nc" id="L1014">                            best = u.getMovesLeft();</span>
<span class="nc" id="L1015">                            result = u;</span>
                        }
<span class="nc" id="L1017">                    } else {</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">                        carrier = !u.isEmpty();</span>
                    }
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                } else if (u.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc" id="L1021">                    active = true;</span>
<span class="nc" id="L1022">                    best = u.getMovesLeft();</span>
<span class="nc" id="L1023">                    result = u;</span>
<span class="nc" id="L1024">                } else {</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">                    if (best &lt; u.getMovesLeft()) {</span>
<span class="nc" id="L1026">                        best = u.getMovesLeft();</span>
<span class="nc" id="L1027">                        result = u;</span>
                    }
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                    carrier = !u.isEmpty();</span>
                }
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                if (carrier) {</span>
                    // Check for active units on carriers.  Usually the
                    // carrier takes precedence.
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                    for (Unit c : u.getUnitList()) {</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                        if (active) {</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                            if (best &lt; c.getMovesLeft()) {</span>
<span class="nc" id="L1037">                                best = c.getMovesLeft();</span>
<span class="nc" id="L1038">                                result = c;</span>
                            }
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                        } else if (c.getState() == Unit.UnitState.ACTIVE) {</span>
<span class="nc" id="L1041">                            active = true;</span>
<span class="nc" id="L1042">                            best = c.getMovesLeft();</span>
<span class="nc" id="L1043">                            result = c;</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L1049">        return result;</span>
    }

    /**
     * Gets the active unit.
     *
     * @return The &lt;code&gt;Unit&lt;/code&gt;.
     * @see #setActiveUnit
     */
    Unit getActiveUnit() {
<span class="nc" id="L1059">        return activeUnit;</span>
    }

    /**
     * Sets the active unit.
     *
     * @param activeUnit The new active &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if the focus was set.
     */
    boolean setActiveUnit(Unit activeUnit) {
        // Don't select a unit with zero moves left. -sjm
        // The user might what to check the status of a unit - SG
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        Tile tile = (activeUnit == null) ? null : activeUnit.getTile();</span>
<span class="nc" id="L1072">        this.activeUnit = activeUnit;</span>

        // The user activated a unit
<span class="nc bnc" id="L1075" title="All 4 branches missed.">        if (viewMode == GUI.VIEW_TERRAIN_MODE &amp;&amp; activeUnit != null) {</span>
<span class="nc" id="L1076">            changeViewMode(GUI.MOVE_UNITS_MODE);</span>
        }

<span class="nc bnc" id="L1079" title="All 4 branches missed.">        if (activeUnit == null || tile == null) {</span>
<span class="nc" id="L1080">            gui.getCanvas().stopGoto();</span>
<span class="nc" id="L1081">        } else {</span>
<span class="nc" id="L1082">            updateCurrentPathForActiveUnit();</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (!gui.setSelectedTile(tile)</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                || getClientOptions().getBoolean(ClientOptions.JUMP_TO_ACTIVE_UNIT)) {</span>
<span class="nc" id="L1085">                gui.setFocus(tile);</span>
<span class="nc" id="L1086">                return true;</span>
            }
        }
<span class="nc" id="L1089">        return false;</span>
    }

    /**
     * Checks if there is currently a goto operation on the mapboard.
     *
     * @return True if a goto operation is in progress.
     */
    boolean isGotoStarted() {
<span class="nc" id="L1098">        return gotoStarted;</span>
    }

    /**
     * Starts a goto operation on the mapboard.
     * 
     * Dont use this directly, call the method in canvas!
     */
    void startGoto() {
<span class="nc" id="L1107">        gotoStarted = true;</span>
<span class="nc" id="L1108">        setGotoPath(null);</span>
<span class="nc" id="L1109">    }</span>

    /**
     * Stops any ongoing goto operation on the mapboard.
     * 
     * Dont use this directly, call the method in canvas!
     */
    void stopGoto() {
<span class="nc" id="L1117">        setGotoPath(null);</span>
<span class="nc" id="L1118">        updateCurrentPathForActiveUnit();</span>
<span class="nc" id="L1119">        gotoStarted = false;</span>
<span class="nc" id="L1120">    }</span>

    /**
     * Gets the path to be drawn on the map.
     *
     * @return The path that should be drawn on the map or
     *     &lt;code&gt;null&lt;/code&gt; if no path should be drawn.
     */
    PathNode getGotoPath() {
<span class="nc" id="L1129">        return gotoPath;</span>
    }

    /**
     * Sets the path to be drawn on the map.
     * 
     * Dont use this directly, call the method in canvas!
     *
     * @param gotoPath The path that should be drawn on the map
     *     or &lt;code&gt;null&lt;/code&gt; if no path should be drawn.
     */
    void setGotoPath(PathNode gotoPath) {
<span class="nc" id="L1141">        this.gotoPath = gotoPath;</span>
<span class="nc" id="L1142">        forceReposition();</span>
<span class="nc" id="L1143">    }</span>

    /**
     * Sets the path of the active unit to display it.
     */
    void updateCurrentPathForActiveUnit() {
        PathNode path;
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (activeUnit == null</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            || activeUnit.getDestination() == null</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">            || ((FreeColGameObject)activeUnit.getDestination()).isDisposed()</span>
<span class="nc" id="L1153">            || Map.isSameLocation(activeUnit.getLocation(),</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                                  activeUnit.getDestination())) {</span>
<span class="nc" id="L1155">            path = null;</span>
<span class="nc" id="L1156">        } else {</span>
            try {
<span class="nc" id="L1158">                path = activeUnit.findPath(activeUnit.getDestination());</span>
<span class="nc" id="L1159">            } catch (Exception e) {</span>
<span class="nc" id="L1160">                logger.log(Level.WARNING, &quot;Path fail&quot;, e);</span>
<span class="nc" id="L1161">                path = null;</span>
<span class="nc" id="L1162">                activeUnit.setDestination(null);</span>
            }
        }
<span class="nc" id="L1165">        setCurrentPath(path);</span>
<span class="nc" id="L1166">    }</span>

    /**
     * Set the current active unit path.
     *
     * @param path The current &lt;code&gt;PathNode&lt;/code&gt;.
     */
    void setCurrentPath(PathNode path) {
<span class="nc" id="L1174">        this.currentPath = path;</span>
<span class="nc" id="L1175">    }</span>

    void setSize(Dimension size) {
<span class="nc" id="L1178">        this.size = size;</span>
<span class="nc" id="L1179">        updateMapDisplayVariables();</span>
<span class="nc" id="L1180">    }</span>

    /**
     * Reset the scale of the map to the default.
     */
    void resetMapScale() {
<span class="nc" id="L1186">        setImageLibraryAndUpdateData(new ImageLibrary());</span>
<span class="nc" id="L1187">        updateMapDisplayVariables();</span>
<span class="nc" id="L1188">    }</span>

    boolean isAtMaxMapScale() {
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        return lib.getScaleFactor() == MAP_SCALE_MAX;</span>
    }

    boolean isAtMinMapScale() {
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        return lib.getScaleFactor() == MAP_SCALE_MIN;</span>
    }

    void increaseMapScale() {
<span class="nc" id="L1199">        float newScale = lib.getScaleFactor() + MAP_SCALE_STEP;</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (newScale &gt;= MAP_SCALE_MAX)</span>
<span class="nc" id="L1201">            newScale = MAP_SCALE_MAX;</span>
<span class="nc" id="L1202">        setImageLibraryAndUpdateData(new ImageLibrary(newScale));</span>
<span class="nc" id="L1203">        updateMapDisplayVariables();</span>
<span class="nc" id="L1204">    }</span>

    void decreaseMapScale() {
<span class="nc" id="L1207">        float newScale = lib.getScaleFactor() - MAP_SCALE_STEP;</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        if (newScale &lt;= MAP_SCALE_MIN)</span>
<span class="nc" id="L1209">            newScale = MAP_SCALE_MIN;</span>
<span class="nc" id="L1210">        setImageLibraryAndUpdateData(new ImageLibrary(newScale));</span>
<span class="nc" id="L1211">        updateMapDisplayVariables();</span>
<span class="nc" id="L1212">    }</span>

    private void updateMapDisplayVariables() {
        // Calculate the amount of rows that will be drawn above the
        // central Tile
<span class="nc" id="L1217">        topSpace = (size.height - tileHeight) / 2;</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if ((topSpace % (halfHeight)) != 0) {</span>
<span class="nc" id="L1219">            topRows = topSpace / (halfHeight) + 2;</span>
<span class="nc" id="L1220">        } else {</span>
<span class="nc" id="L1221">            topRows = topSpace / (halfHeight) + 1;</span>
        }
<span class="nc" id="L1223">        bottomRows = topRows;</span>
<span class="nc" id="L1224">        leftSpace = (size.width - tileWidth) / 2;</span>
<span class="nc" id="L1225">        rightSpace = leftSpace;</span>
<span class="nc" id="L1226">    }</span>

    /**
     * Sets the ImageLibrary and calculates various items that depend
     * on tile size.
     *
     * @param lib an &lt;code&gt;ImageLibrary&lt;/code&gt; value
     */
    private void setImageLibraryAndUpdateData(ImageLibrary lib) {
<span class="nc" id="L1235">        this.lib = lib;</span>
<span class="nc" id="L1236">        tv.setImageLibraryAndUpdateData(lib);</span>
        // ATTENTION: we assume that all base tiles have the same size
<span class="nc" id="L1238">        Dimension tileSize = lib.tileSize;</span>
<span class="nc" id="L1239">        tileHeight = tileSize.height;</span>
<span class="nc" id="L1240">        tileWidth = tileSize.width;</span>
<span class="nc" id="L1241">        halfHeight = tileHeight/2;</span>
<span class="nc" id="L1242">        halfWidth = tileWidth/2;</span>

<span class="nc" id="L1244">        int dx = tileWidth/16;</span>
<span class="nc" id="L1245">        int dy = tileHeight/16;</span>
<span class="nc" id="L1246">        int ddx = dx + dx/2;</span>
<span class="nc" id="L1247">        int ddy = dy + dy/2;</span>

        // small corners
<span class="nc" id="L1250">        controlPoints.put(Direction.N, new Point2D.Float(halfWidth, dy));</span>
<span class="nc" id="L1251">        controlPoints.put(Direction.E, new Point2D.Float(tileWidth - dx, halfHeight));</span>
<span class="nc" id="L1252">        controlPoints.put(Direction.S, new Point2D.Float(halfWidth, tileHeight - dy));</span>
<span class="nc" id="L1253">        controlPoints.put(Direction.W, new Point2D.Float(dx, halfHeight));</span>
        // big corners
<span class="nc" id="L1255">        controlPoints.put(Direction.SE, new Point2D.Float(halfWidth, tileHeight));</span>
<span class="nc" id="L1256">        controlPoints.put(Direction.NE, new Point2D.Float(tileWidth, halfHeight));</span>
<span class="nc" id="L1257">        controlPoints.put(Direction.SW, new Point2D.Float(0, halfHeight));</span>
<span class="nc" id="L1258">        controlPoints.put(Direction.NW, new Point2D.Float(halfWidth, 0));</span>
        // small corners
<span class="nc" id="L1260">        borderPoints.put(Direction.NW, new Point2D.Float(dx + ddx, halfHeight - ddy));</span>
<span class="nc" id="L1261">        borderPoints.put(Direction.N,  new Point2D.Float(halfWidth - ddx, dy + ddy));</span>
<span class="nc" id="L1262">        borderPoints.put(Direction.NE, new Point2D.Float(halfWidth + ddx, dy + ddy));</span>
<span class="nc" id="L1263">        borderPoints.put(Direction.E,  new Point2D.Float(tileWidth - dx - ddx, halfHeight - ddy));</span>
<span class="nc" id="L1264">        borderPoints.put(Direction.SE, new Point2D.Float(tileWidth - dx - ddx, halfHeight + ddy));</span>
<span class="nc" id="L1265">        borderPoints.put(Direction.S,  new Point2D.Float(halfWidth + ddx, tileHeight - dy - ddy));</span>
<span class="nc" id="L1266">        borderPoints.put(Direction.SW, new Point2D.Float(halfWidth - ddx, tileHeight - dy - ddy));</span>
<span class="nc" id="L1267">        borderPoints.put(Direction.W,  new Point2D.Float(dx + ddx, halfHeight + ddy));</span>

<span class="nc" id="L1269">        borderStroke = new BasicStroke(dy);</span>
<span class="nc" id="L1270">        gridStroke = new BasicStroke(lib.getScaleFactor());</span>
<span class="nc" id="L1271">    }</span>

    /**
     * Displays the Map.
     *
     * @param g The Graphics2D object on which to draw the Map.
     */
    void displayMap(Graphics2D g) {
<span class="nc" id="L1279">        final ClientOptions options = getClientOptions();</span>
<span class="nc" id="L1280">        final Game game = getGame();</span>
<span class="nc" id="L1281">        Map map = game.getMap();</span>

        // Remember transform
<span class="nc" id="L1284">        AffineTransform originTransform = g.getTransform();</span>
<span class="nc" id="L1285">        Rectangle clipBounds = g.getClipBounds();</span>

        // Position the map if it is not positioned yet
<span class="nc" id="L1288">        repositionMapIfNeeded();</span>

        // Determine which tiles need to be redrawn
<span class="nc" id="L1291">        int firstRow = (clipBounds.y - topRowY) / (halfHeight) - 1;</span>
<span class="nc" id="L1292">        int clipTopY = topRowY + firstRow * (halfHeight);</span>
<span class="nc" id="L1293">        firstRow = topRow + firstRow;</span>

<span class="nc" id="L1295">        int firstColumn = (clipBounds.x - leftColumnX) / tileWidth - 1;</span>
<span class="nc" id="L1296">        int clipLeftX = leftColumnX + firstColumn * tileWidth;</span>
<span class="nc" id="L1297">        firstColumn = leftColumn + firstColumn;</span>

<span class="nc" id="L1299">        int lastRow = (clipBounds.y + clipBounds.height - topRowY)</span>
<span class="nc" id="L1300">            / (halfHeight);</span>
<span class="nc" id="L1301">        lastRow = topRow + lastRow;</span>

<span class="nc" id="L1303">        int lastColumn = (clipBounds.x + clipBounds.width - leftColumnX)</span>
<span class="nc" id="L1304">            / tileWidth;</span>
<span class="nc" id="L1305">        lastColumn = leftColumn + lastColumn;</span>

        // Clear background
<span class="nc" id="L1308">        g.setColor(Color.black);</span>
<span class="nc" id="L1309">        g.fillRect(clipBounds.x, clipBounds.y,</span>
<span class="nc" id="L1310">                   clipBounds.width, clipBounds.height);</span>

        // Set and remember transform for upper left corner
<span class="nc" id="L1313">        g.translate(clipLeftX, clipTopY);</span>
<span class="nc" id="L1314">        AffineTransform baseTransform = g.getTransform();</span>

<span class="nc" id="L1316">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
<span class="nc" id="L1317">                           RenderingHints.VALUE_ANTIALIAS_ON);</span>

        // Display the base Tiles
<span class="nc" id="L1320">        final int x0 = firstColumn;</span>
<span class="nc" id="L1321">        final int y0 = firstRow;</span>
<span class="nc" id="L1322">        map.forSubMap(x0, y0, lastColumn-firstColumn+1, lastRow-firstRow+1,</span>
<span class="nc" id="L1323">            (Tile tile) -&gt; {</span>
<span class="nc" id="L1324">                final int x = tile.getX();</span>
<span class="nc" id="L1325">                final int y = tile.getY();</span>
<span class="nc" id="L1326">                final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1327">                final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1328">                g.translate(xt, yt);</span>

<span class="nc" id="L1330">                tv.displayTileWithBeachAndBorder(g, tile);</span>
<span class="nc" id="L1331">                tv.displayUnknownTileBorder(g, tile);</span>

<span class="nc" id="L1333">                g.translate(-xt, -yt);</span>
<span class="nc" id="L1334">            });</span>

        // Draw the grid, if needed
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (options.getBoolean(ClientOptions.DISPLAY_GRID)) {</span>
            // Generate a zigzag GeneralPath
<span class="nc" id="L1339">            GeneralPath gridPath = new GeneralPath();</span>
<span class="nc" id="L1340">            gridPath.moveTo(0, 0);</span>
<span class="nc" id="L1341">            int nextX = halfWidth;</span>
<span class="nc" id="L1342">            int nextY = -halfHeight;</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">            for (int i = 0; i &lt;= ((lastColumn - firstColumn) * 2 + 1); i++) {</span>
<span class="nc" id="L1344">                gridPath.lineTo(nextX, nextY);</span>
<span class="nc" id="L1345">                nextX += halfWidth;</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">                nextY = (nextY == 0 ? -halfHeight : 0);</span>
            }

            // Display the grid
<span class="nc" id="L1350">            g.setStroke(gridStroke);</span>
<span class="nc" id="L1351">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            for (int row = firstRow; row &lt;= lastRow; row++) {</span>
<span class="nc" id="L1353">                g.translate(0, halfHeight);</span>
<span class="nc" id="L1354">                AffineTransform rowTransform = g.getTransform();</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">                if ((row &amp; 1) == 1) {</span>
<span class="nc" id="L1356">                    g.translate(halfWidth, 0);</span>
                }
<span class="nc" id="L1358">                g.draw(gridPath);</span>
<span class="nc" id="L1359">                g.setTransform(rowTransform);</span>
            }
<span class="nc" id="L1361">            g.setTransform(baseTransform);</span>
        }

        // Paint full region borders
<span class="nc bnc" id="L1365" title="All 2 branches missed.">        if (options.getInteger(ClientOptions.DISPLAY_TILE_TEXT) ==</span>
<span class="nc" id="L1366">                ClientOptions.DISPLAY_TILE_TEXT_REGIONS) {</span>
<span class="nc" id="L1367">            map.forSubMap(x0, y0-1, lastColumn-firstColumn+1, lastRow-firstRow+1+1,</span>
<span class="nc" id="L1368">                (Tile tile) -&gt; {</span>
<span class="nc" id="L1369">                    final int x = tile.getX();</span>
<span class="nc" id="L1370">                    final int y = tile.getY();</span>
<span class="nc" id="L1371">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1372">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1373">                    g.translate(xt, yt);</span>
<span class="nc" id="L1374">                    displayTerritorialBorders(g, tile, BorderType.REGION, true);</span>
<span class="nc" id="L1375">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1376">                });</span>
        }

        // Paint full country borders
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (options.getBoolean(ClientOptions.DISPLAY_BORDERS)) {</span>
<span class="nc" id="L1381">            map.forSubMap(x0, y0-1, lastColumn-firstColumn+1, lastRow-firstRow+1+1,</span>
<span class="nc" id="L1382">                (Tile tile) -&gt; {</span>
<span class="nc" id="L1383">                    final int x = tile.getX();</span>
<span class="nc" id="L1384">                    final int y = tile.getY();</span>
<span class="nc" id="L1385">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1386">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1387">                    g.translate(xt, yt);</span>
<span class="nc" id="L1388">                    displayTerritorialBorders(g, tile, BorderType.COUNTRY, true);</span>
<span class="nc" id="L1389">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1390">                });</span>
        }

        // Display the Tile overlays
<span class="nc" id="L1394">        Set&lt;String&gt; overlayCache = ImageLibrary.createOverlayCache();</span>
<span class="nc" id="L1395">        int colonyLabels = options.getInteger(ClientOptions.COLONY_LABELS);</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        boolean withNumbers = colonyLabels == ClientOptions.COLONY_LABELS_CLASSIC;</span>
<span class="nc" id="L1397">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
<span class="nc" id="L1398">                           RenderingHints.VALUE_ANTIALIAS_OFF);</span>
<span class="nc" id="L1399">        map.forSubMap(x0, y0, lastColumn-firstColumn+1, lastRow-firstRow+1,</span>
<span class="nc" id="L1400">            (Tile tile) -&gt; {</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                if (!tile.isExplored())</span>
<span class="nc" id="L1402">                    return;</span>

<span class="nc" id="L1404">                final int x = tile.getX();</span>
<span class="nc" id="L1405">                final int y = tile.getY();</span>
<span class="nc" id="L1406">                final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1407">                final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1408">                g.translate(xt, yt);</span>

<span class="nc" id="L1410">                BufferedImage overlayImage = lib.getOverlayImage(tile, overlayCache);</span>
<span class="nc" id="L1411">                tv.displayTileItems(g, tile, overlayImage);</span>
<span class="nc" id="L1412">                tv.displaySettlementWithChipsOrPopulationNumber(</span>
<span class="nc" id="L1413">                    g, tile, withNumbers);</span>
<span class="nc" id="L1414">                tv.displayFogOfWar(g, tile);</span>
<span class="nc" id="L1415">                tv.displayOptionalTileText(g, tile);</span>

<span class="nc" id="L1417">                g.translate(-xt, -yt);</span>
<span class="nc" id="L1418">            });</span>
<span class="nc" id="L1419">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
<span class="nc" id="L1420">                           RenderingHints.VALUE_ANTIALIAS_ON);</span>

        // Paint transparent region borders
<span class="nc bnc" id="L1423" title="All 2 branches missed.">        if (options.getInteger(ClientOptions.DISPLAY_TILE_TEXT) ==</span>
<span class="nc" id="L1424">                ClientOptions.DISPLAY_TILE_TEXT_REGIONS) {</span>
<span class="nc" id="L1425">            map.forSubMap(x0, y0-1, lastColumn-firstColumn+1, lastRow-firstRow+1+1,</span>
<span class="nc" id="L1426">                (Tile tile) -&gt; {</span>
<span class="nc" id="L1427">                    final int x = tile.getX();</span>
<span class="nc" id="L1428">                    final int y = tile.getY();</span>
<span class="nc" id="L1429">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1430">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1431">                    g.translate(xt, yt);</span>
<span class="nc" id="L1432">                    displayTerritorialBorders(g, tile, BorderType.REGION, false);</span>
<span class="nc" id="L1433">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1434">                });</span>
        }

        // Paint transparent country borders
<span class="nc bnc" id="L1438" title="All 2 branches missed.">        if (options.getBoolean(ClientOptions.DISPLAY_BORDERS)) {</span>
<span class="nc" id="L1439">            map.forSubMap(x0, y0-1, lastColumn-firstColumn+1, lastRow-firstRow+1+1,</span>
<span class="nc" id="L1440">                (Tile tile) -&gt; {</span>
<span class="nc" id="L1441">                    final int x = tile.getX();</span>
<span class="nc" id="L1442">                    final int y = tile.getY();</span>
<span class="nc" id="L1443">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1444">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1445">                    g.translate(xt, yt);</span>
<span class="nc" id="L1446">                    displayTerritorialBorders(g, tile, BorderType.COUNTRY, false);</span>
<span class="nc" id="L1447">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1448">                });</span>
        }

        // Display cursor for selected tile or active unit
<span class="nc" id="L1452">        Tile cursorTile = null;</span>
<span class="nc bnc" id="L1453" title="All 3 branches missed.">        switch (viewMode) {</span>
            case GUI.MOVE_UNITS_MODE:
<span class="nc bnc" id="L1455" title="All 2 branches missed.">                if (activeUnit != null &amp;&amp;</span>
<span class="nc bnc" id="L1456" title="All 4 branches missed.">                        (cursor.isActive() || activeUnit.getMovesLeft() &lt;= 0))</span>
<span class="nc" id="L1457">                    cursorTile = activeUnit.getTile();</span>
<span class="nc" id="L1458">                break;</span>
            case GUI.VIEW_TERRAIN_MODE:
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                if (selectedTile != null)</span>
<span class="nc" id="L1461">                    cursorTile = selectedTile;</span>
        }
<span class="nc bnc" id="L1463" title="All 2 branches missed.">        if (cursorTile != null) {</span>
<span class="nc" id="L1464">            final int x = cursorTile.getX();</span>
<span class="nc" id="L1465">            final int y = cursorTile.getY();</span>
<span class="nc bnc" id="L1466" title="All 8 branches missed.">            if(x &gt;= x0 &amp;&amp; y &gt;= y0 &amp;&amp; x &lt;= lastColumn &amp;&amp; y &lt;= lastRow) {</span>
<span class="nc" id="L1467">                final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1468">                final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1469">                g.translate(xt, yt);</span>
<span class="nc" id="L1470">                displayCursor(g);</span>
<span class="nc" id="L1471">                g.translate(-xt, -yt);</span>
            }
        }

        // Display units
<span class="nc" id="L1476">        g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if(!game.isInRevengeMode()) {</span>
<span class="nc" id="L1478">            map.forSubMap(x0, y0, lastColumn-firstColumn+1, lastRow-firstRow+1,</span>
<span class="nc" id="L1479">                (Tile tile) -&gt; {</span>
                    // check for units
<span class="nc" id="L1481">                    Unit unit = findUnitInFront(tile);</span>
<span class="nc bnc" id="L1482" title="All 4 branches missed.">                    if (unit == null || isOutForAnimation(unit))</span>
<span class="nc" id="L1483">                        return;</span>

<span class="nc" id="L1485">                    final int x = tile.getX();</span>
<span class="nc" id="L1486">                    final int y = tile.getY();</span>
<span class="nc" id="L1487">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1488">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1489">                    g.translate(xt, yt);</span>

<span class="nc" id="L1491">                    displayUnit(g, unit);</span>

<span class="nc" id="L1493">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1494">                });</span>
<span class="nc" id="L1495">        } else {</span>
            /* Add extra rows and colums, as the dark halo is huge to enable
               a very slow fade into transparency, see BR#2580 */
<span class="nc" id="L1498">            map.forSubMap(x0-2, y0-4, lastColumn-firstColumn+1+4, lastRow-firstRow+1+8,</span>
<span class="nc" id="L1499">                (Tile tile) -&gt; {</span>
                    // check for units
<span class="nc" id="L1501">                    Unit unit = findUnitInFront(tile);</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">                    if (unit == null)</span>
<span class="nc" id="L1503">                        return;</span>

<span class="nc" id="L1505">                    final int x = tile.getX();</span>
<span class="nc" id="L1506">                    final int y = tile.getY();</span>
<span class="nc" id="L1507">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1508">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1509">                    g.translate(xt, yt);</span>

<span class="nc bnc" id="L1511" title="All 2 branches missed.">                    if (unit.isUndead()) {</span>
                        // Rescale dark halo only in rare case its needed!
<span class="nc" id="L1513">                        BufferedImage darkness = lib.getMiscImage(ImageLibrary.DARKNESS);</span>
<span class="nc" id="L1514">                        tv.displayCenteredImage(g, darkness);</span>
                    }
<span class="nc bnc" id="L1516" title="All 2 branches missed.">                    if (!isOutForAnimation(unit))</span>
<span class="nc" id="L1517">                        displayUnit(g, unit);</span>

<span class="nc" id="L1519">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1520">                });</span>
        }

        // Display the colony names, if needed
<span class="nc bnc" id="L1524" title="All 2 branches missed.">        if (colonyLabels != ClientOptions.COLONY_LABELS_NONE) {</span>
<span class="nc" id="L1525">            final Player player = getMyPlayer();</span>
<span class="nc" id="L1526">            FontLibrary fontLibrary = new FontLibrary(lib.getScaleFactor());</span>
<span class="nc" id="L1527">            Font font = fontLibrary.createScaledFont(</span>
<span class="nc" id="L1528">                FontLibrary.FontType.NORMAL, FontLibrary.FontSize.SMALLER,</span>
<span class="nc" id="L1529">                Font.BOLD);</span>
<span class="nc" id="L1530">            Font italicFont = fontLibrary.createScaledFont(</span>
<span class="nc" id="L1531">                FontLibrary.FontType.NORMAL, FontLibrary.FontSize.SMALLER,</span>
<span class="nc" id="L1532">                Font.BOLD | Font.ITALIC);</span>
<span class="nc" id="L1533">            Font productionFont = fontLibrary.createScaledFont(</span>
<span class="nc" id="L1534">                FontLibrary.FontType.NORMAL, FontLibrary.FontSize.TINY,</span>
<span class="nc" id="L1535">                Font.BOLD);</span>

            /* For settlement names and territorial borders 1 extra row needs
               to be drawn in north to prevent missing parts on partial redraws,
               as they can reach below their tiles, see BR#2580 */
<span class="nc" id="L1540">            map.forSubMap(x0, y0-1, lastColumn-firstColumn+1, lastRow-firstRow+1+1,</span>
<span class="nc" id="L1541">                (Tile tile) -&gt; {</span>
<span class="nc" id="L1542">                    Settlement settlement = tile.getSettlement();</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                    if(settlement == null)</span>
<span class="nc" id="L1544">                        return;</span>

<span class="nc" id="L1546">                    final int x = tile.getX();</span>
<span class="nc" id="L1547">                    final int y = tile.getY();</span>
<span class="nc" id="L1548">                    final int xt = (x-x0) * tileWidth + (y&amp;1) * halfWidth;</span>
<span class="nc" id="L1549">                    final int yt = (y-y0) * halfHeight;</span>
<span class="nc" id="L1550">                    g.translate(xt, yt);</span>

<span class="nc" id="L1552">                    displaySettlementLabels(g, settlement, player, colonyLabels,</span>
<span class="nc" id="L1553">                                            font, italicFont, productionFont);</span>

<span class="nc" id="L1555">                    g.translate(-xt, -yt);</span>
<span class="nc" id="L1556">                });</span>
        }

        // Restore original transform to allow for more drawing
<span class="nc" id="L1560">        g.setTransform(originTransform);</span>

        // Display goto path
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (currentPath != null) {</span>
<span class="nc" id="L1564">            displayPath(g, currentPath);</span>
        }
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (gotoPath != null) {</span>
<span class="nc" id="L1567">            displayPath(g, gotoPath);</span>
        }
<span class="nc" id="L1569">    }</span>

    private void displaySettlementLabels(Graphics2D g, Settlement settlement,
                                         Player player, int colonyLabels,
                                         Font font, Font italicFont,
                                         Font productionFont) {
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        if (settlement.isDisposed()) {</span>
<span class="nc" id="L1576">            logger.warning(&quot;Settlement display race detected: &quot;</span>
<span class="nc" id="L1577">                           + settlement.getName());</span>
<span class="nc" id="L1578">            return;</span>
        }
<span class="nc" id="L1580">        String name = Messages.message(settlement.getLocationLabelFor(player));</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">        if (name == null) return;</span>

<span class="nc" id="L1583">        Color backgroundColor = settlement.getOwner().getNationColor();</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">        if (backgroundColor == null) backgroundColor = Color.WHITE;</span>
        // int yOffset = lib.getSettlementImage(settlement).getHeight() + 1;
<span class="nc" id="L1586">        int yOffset = tileHeight;</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        switch (colonyLabels) {</span>
        case ClientOptions.COLONY_LABELS_CLASSIC:
<span class="nc" id="L1589">            BufferedImage img = lib.getStringImage(g, name, backgroundColor, font);</span>
<span class="nc" id="L1590">            g.drawImage(img, (tileWidth - img.getWidth())/2 + 1,</span>
<span class="nc" id="L1591">                        yOffset, null);</span>
<span class="nc" id="L1592">            break;</span>

        case ClientOptions.COLONY_LABELS_MODERN:
        default:
<span class="nc" id="L1596">            backgroundColor = new Color(backgroundColor.getRed(),</span>
<span class="nc" id="L1597">                                        backgroundColor.getGreen(),</span>
<span class="nc" id="L1598">                                        backgroundColor.getBlue(), 128);</span>
<span class="nc" id="L1599">            TextSpecification[] specs = new TextSpecification[1];</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">            if (settlement instanceof Colony</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">                &amp;&amp; settlement.getOwner() == player) {</span>
<span class="nc" id="L1602">                Colony colony = (Colony) settlement;</span>
<span class="nc" id="L1603">                BuildableType buildable = colony.getCurrentlyBuilding();</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                if (buildable != null) {</span>
<span class="nc" id="L1605">                    specs = new TextSpecification[2];</span>
<span class="nc" id="L1606">                    String t = Messages.getName(buildable) + &quot; &quot; +</span>
<span class="nc" id="L1607">                        Turn.getTurnsText(colony.getTurnsToComplete(buildable));</span>
<span class="nc" id="L1608">                    specs[1] = new TextSpecification(t, productionFont);</span>
                }
            }
<span class="nc" id="L1611">            specs[0] = new TextSpecification(name, font);</span>

<span class="nc" id="L1613">            BufferedImage nameImage = createLabel(g, specs, backgroundColor);</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            if (nameImage != null) {</span>
<span class="nc" id="L1615">                int spacing = 3;</span>
<span class="nc" id="L1616">                BufferedImage leftImage = null;</span>
<span class="nc" id="L1617">                BufferedImage rightImage = null;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                if (settlement instanceof Colony) {</span>
<span class="nc" id="L1619">                    Colony colony = (Colony)settlement;</span>
<span class="nc" id="L1620">                    String string = Integer.toString(</span>
<span class="nc" id="L1621">                        colony.getDisplayUnitCount());</span>
<span class="nc" id="L1622">                    leftImage = createLabel(g, string,</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                        ((colony.getPreferredSizeChange() &gt; 0)</span>
<span class="nc" id="L1624">                            ? italicFont : font),</span>
<span class="nc" id="L1625">                        backgroundColor);</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                    if (player.owns(settlement)) {</span>
<span class="nc" id="L1627">                        int bonusProduction = colony.getProductionBonus();</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">                        if (bonusProduction != 0) {</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                            String bonus = (bonusProduction &gt; 0)</span>
<span class="nc" id="L1630">                                ? &quot;+&quot; + bonusProduction</span>
<span class="nc" id="L1631">                                : Integer.toString(bonusProduction);</span>
<span class="nc" id="L1632">                            rightImage = createLabel(g, bonus, font,</span>
<span class="nc" id="L1633">                                                     backgroundColor);</span>
                        }
                    }
<span class="nc bnc" id="L1636" title="All 2 branches missed.">                } else if (settlement instanceof IndianSettlement) {</span>
<span class="nc" id="L1637">                    IndianSettlement is = (IndianSettlement) settlement;</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                    if (is.getType().isCapital()) {</span>
<span class="nc" id="L1639">                        leftImage = createCapitalLabel(</span>
<span class="nc" id="L1640">                            nameImage.getHeight(), 5, backgroundColor);</span>
                    }

<span class="nc" id="L1643">                    Unit missionary = is.getMissionary();</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">                    if (missionary != null) {</span>
<span class="nc" id="L1645">                        boolean expert = missionary.hasAbility(</span>
<span class="nc" id="L1646">                            Ability.EXPERT_MISSIONARY);</span>
<span class="nc" id="L1647">                        backgroundColor = missionary.getOwner()</span>
<span class="nc" id="L1648">                                                    .getNationColor();</span>
<span class="nc" id="L1649">                        backgroundColor = new Color(</span>
<span class="nc" id="L1650">                            backgroundColor.getRed(),</span>
<span class="nc" id="L1651">                            backgroundColor.getGreen(),</span>
<span class="nc" id="L1652">                            backgroundColor.getBlue(), 128);</span>
<span class="nc" id="L1653">                        rightImage = createReligiousMissionLabel(</span>
<span class="nc" id="L1654">                            nameImage.getHeight(), 5,</span>
<span class="nc" id="L1655">                            backgroundColor, expert);</span>
                    }
                }

<span class="nc" id="L1659">                int width = (int)((nameImage.getWidth()</span>
<span class="nc" id="L1660">                        * lib.getScaleFactor())</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">                    + ((leftImage != null)</span>
<span class="nc" id="L1662">                        ? (leftImage.getWidth()</span>
<span class="nc" id="L1663">                            * lib.getScaleFactor()) + spacing</span>
<span class="nc" id="L1664">                        : 0)</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                    + ((rightImage != null)</span>
<span class="nc" id="L1666">                        ? (rightImage.getWidth()</span>
<span class="nc" id="L1667">                            * lib.getScaleFactor()) + spacing</span>
<span class="nc" id="L1668">                        : 0));</span>
<span class="nc" id="L1669">                int labelOffset = (tileWidth - width)/2;</span>
<span class="nc" id="L1670">                yOffset -= (nameImage.getHeight()</span>
<span class="nc" id="L1671">                    * lib.getScaleFactor())/2;</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">                if (leftImage != null) {</span>
<span class="nc" id="L1673">                    g.drawImage(leftImage, labelOffset, yOffset, null);</span>
<span class="nc" id="L1674">                    labelOffset += (leftImage.getWidth()</span>
<span class="nc" id="L1675">                        * lib.getScaleFactor()) + spacing;</span>
                }
<span class="nc" id="L1677">                g.drawImage(nameImage, labelOffset, yOffset, null);</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                if (rightImage != null) {</span>
<span class="nc" id="L1679">                    labelOffset += (nameImage.getWidth()</span>
<span class="nc" id="L1680">                        * lib.getScaleFactor()) + spacing;</span>
<span class="nc" id="L1681">                    g.drawImage(rightImage, labelOffset, yOffset, null);</span>
                }
                break;
            }
        }
<span class="nc" id="L1686">    }</span>

    /**
     * Draws the pentagram indicating a native capital.
     *
     * @param extent The nominal height of the image.
     * @param padding Padding to add around the image.
     * @param backgroundColor The image background color.
     * @return A suitable &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    private static BufferedImage createCapitalLabel(int extent, int padding,
                                                    Color backgroundColor) {
        // create path
<span class="nc" id="L1699">        double deg2rad = Math.PI/180.0;</span>
<span class="nc" id="L1700">        double angle = -90.0 * deg2rad;</span>
<span class="nc" id="L1701">        double offset = extent * 0.5;</span>
<span class="nc" id="L1702">        double size1 = (extent - padding - padding) * 0.5;</span>

<span class="nc" id="L1704">        GeneralPath path = new GeneralPath();</span>
<span class="nc" id="L1705">        path.moveTo(Math.cos(angle) * size1 + offset, Math.sin(angle) * size1 + offset);</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">        for (int i = 0; i &lt; 4; i++) {</span>
<span class="nc" id="L1707">            angle += 144 * deg2rad;</span>
<span class="nc" id="L1708">            path.lineTo(Math.cos(angle) * size1 + offset, Math.sin(angle) * size1 + offset);</span>
        }
<span class="nc" id="L1710">        path.closePath();</span>

        // draw everything
<span class="nc" id="L1713">        BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1714">        Graphics2D g = bi.createGraphics();</span>
<span class="nc" id="L1715">        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1716">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1717">        g.setColor(backgroundColor);</span>
<span class="nc" id="L1718">        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));</span>
<span class="nc" id="L1719">        g.setColor(Color.BLACK);</span>
<span class="nc" id="L1720">        g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
<span class="nc" id="L1721">        g.draw(path);</span>
<span class="nc" id="L1722">        g.setColor(Color.WHITE);</span>
<span class="nc" id="L1723">        g.fill(path);</span>
<span class="nc" id="L1724">        g.dispose();</span>
<span class="nc" id="L1725">        return bi;</span>
    }

    /**
     * Creates an BufferedImage that shows the given text centred on a
     * translucent rounded rectangle with the given color.
     *
     * @param g a &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param text a &lt;code&gt;String&lt;/code&gt;
     * @param font a &lt;code&gt;Font&lt;/code&gt;
     * @param backgroundColor a &lt;code&gt;Color&lt;/code&gt;
     * @return an &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    private static BufferedImage createLabel(Graphics2D g, String text,
                                             Font font, Color backgroundColor) {
<span class="nc" id="L1740">        TextSpecification[] specs = new TextSpecification[1];</span>
<span class="nc" id="L1741">        specs[0] = new TextSpecification(text, font);</span>
<span class="nc" id="L1742">        return createLabel(g, specs, backgroundColor);</span>
    }

    /**
     * Creates an BufferedImage that shows the given text centred on a
     * translucent rounded rectangle with the given color.
     *
     * @param g a &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param textSpecs a &lt;code&gt;TextSpecification&lt;/code&gt; array
     * @param backgroundColor a &lt;code&gt;Color&lt;/code&gt;
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    private static BufferedImage createLabel(Graphics2D g,
                                             TextSpecification[] textSpecs,
                                             Color backgroundColor) {
<span class="nc" id="L1757">        int hPadding = 15;</span>
<span class="nc" id="L1758">        int vPadding = 10;</span>
<span class="nc" id="L1759">        int linePadding = 5;</span>
<span class="nc" id="L1760">        int width = 0;</span>
<span class="nc" id="L1761">        int height = vPadding;</span>
        int i;

        TextSpecification spec;
<span class="nc" id="L1765">        TextLayout[] labels = new TextLayout[textSpecs.length];</span>
        TextLayout label;

<span class="nc bnc" id="L1768" title="All 2 branches missed.">        for (i = 0; i &lt; textSpecs.length; i++) {</span>
<span class="nc" id="L1769">            spec = textSpecs[i];</span>
<span class="nc" id="L1770">            label = new TextLayout(spec.text, spec.font, g.getFontRenderContext());</span>
<span class="nc" id="L1771">            labels[i] = label;</span>
<span class="nc" id="L1772">            Rectangle textRectangle = label.getPixelBounds(null, 0, 0);</span>
<span class="nc" id="L1773">            width = Math.max(width, textRectangle.width + hPadding);</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">            if (i &gt; 0) height += linePadding;</span>
<span class="nc" id="L1775">            height += (int) (label.getAscent() + label.getDescent());</span>
        }

<span class="nc" id="L1778">        int radius = Math.min(hPadding, vPadding);</span>

<span class="nc" id="L1780">        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1781">        Graphics2D g2 = bi.createGraphics();</span>
<span class="nc" id="L1782">        g2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1783">        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1784">        g2.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);</span>

<span class="nc" id="L1786">        g2.setColor(backgroundColor);</span>
<span class="nc" id="L1787">        g2.fill(new RoundRectangle2D.Float(0, 0, width, height, radius, radius));</span>
<span class="nc" id="L1788">        g2.setColor(ImageLibrary.getForegroundColor(backgroundColor));</span>
<span class="nc" id="L1789">        float y = vPadding / 2;</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        for (i = 0; i &lt; labels.length; i++) {</span>
<span class="nc" id="L1791">            Rectangle textRectangle = labels[i].getPixelBounds(null, 0, 0);</span>
<span class="nc" id="L1792">            float x = (width - textRectangle.width) / 2;</span>
<span class="nc" id="L1793">            y += labels[i].getAscent();</span>
<span class="nc" id="L1794">            labels[i].draw(g2, x, y);</span>
<span class="nc" id="L1795">            y += labels[i].getDescent() + linePadding;</span>
        }
<span class="nc" id="L1797">        g2.dispose();</span>
<span class="nc" id="L1798">        return bi;</span>
    }

    /**
     * Draws a cross indicating a religious mission is present in the
     * native village.
     *
     * @param extent The nominal height of the image.
     * @param padding Padding to add around the image.
     * @param backgroundColor The image background color.
     * @param expertMissionary True if the label should show expertise.
     * @return A suitable &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    private static BufferedImage createReligiousMissionLabel(int extent,
            int padding, Color backgroundColor, boolean expertMissionary) {
        // create path
<span class="nc" id="L1814">        double offset = extent * 0.5;</span>
<span class="nc" id="L1815">        double size1 = extent - padding - padding;</span>
<span class="nc" id="L1816">        double bar = size1 / 3.0;</span>
<span class="nc" id="L1817">        double inset = 0.0;</span>
<span class="nc" id="L1818">        double kludge = 0.0;</span>

<span class="nc" id="L1820">        GeneralPath circle = new GeneralPath();</span>
<span class="nc" id="L1821">        GeneralPath cross = new GeneralPath();</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (expertMissionary) {</span>
            // this is meant to represent the eucharist (the -1, +1 thing is a nasty kludge)
<span class="nc" id="L1824">            circle.append(new Ellipse2D.Double(padding-1, padding-1, size1+1, size1+1), false);</span>
<span class="nc" id="L1825">            inset = 4.0;</span>
<span class="nc" id="L1826">            bar = (size1 - inset - inset) / 3.0;</span>
            // more nasty -1, +1 kludges
<span class="nc" id="L1828">            kludge = 1.0;</span>
        }
<span class="nc" id="L1830">        offset -= 1.0;</span>
<span class="nc" id="L1831">        cross.moveTo(offset, padding + inset - kludge);</span>
<span class="nc" id="L1832">        cross.lineTo(offset, extent - padding - inset);</span>
<span class="nc" id="L1833">        cross.moveTo(offset - bar, padding + bar + inset);</span>
<span class="nc" id="L1834">        cross.lineTo(offset + bar + 1, padding + bar + inset);</span>

        // draw everything
<span class="nc" id="L1837">        BufferedImage bi = new BufferedImage(extent, extent, BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L1838">        Graphics2D g = bi.createGraphics();</span>
<span class="nc" id="L1839">        g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);</span>
<span class="nc" id="L1840">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L1841">        g.setColor(backgroundColor);</span>
<span class="nc" id="L1842">        g.fill(new RoundRectangle2D.Float(0, 0, extent, extent, padding, padding));</span>
<span class="nc" id="L1843">        g.setColor(ImageLibrary.getForegroundColor(backgroundColor));</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (expertMissionary) {</span>
<span class="nc" id="L1845">            g.setStroke(new BasicStroke(2.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
<span class="nc" id="L1846">            g.draw(circle);</span>
<span class="nc" id="L1847">            g.setStroke(new BasicStroke(1.6f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
<span class="nc" id="L1848">        } else {</span>
<span class="nc" id="L1849">            g.setStroke(new BasicStroke(2.4f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));</span>
        }
<span class="nc" id="L1851">        g.draw(cross);</span>
<span class="nc" id="L1852">        g.dispose();</span>
<span class="nc" id="L1853">        return bi;</span>
    }


    /**
     * Display a path.
     *
     * @param g The &lt;code&gt;Graphics2D&lt;/code&gt; to display on.
     * @param path The &lt;code&gt;PathNode&lt;/code&gt; to display.
     */
    private void displayPath(Graphics2D g, PathNode path) {
<span class="nc" id="L1864">        final Font font = FontLibrary.createFont(FontLibrary.FontType.NORMAL,</span>
<span class="nc" id="L1865">            FontLibrary.FontSize.TINY, lib.getScaleFactor());</span>
<span class="nc" id="L1866">        final boolean debug = FreeColDebugger</span>
<span class="nc" id="L1867">            .isInDebugMode(FreeColDebugger.DebugMode.PATHS);</span>

<span class="nc bnc" id="L1869" title="All 2 branches missed.">        for (PathNode p = path; p != null; p = p.next) {</span>
<span class="nc" id="L1870">            Tile tile = p.getTile();</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            if (tile == null) continue;</span>
<span class="nc" id="L1872">            Point point = calculateTilePosition(tile);</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">            if (point == null) continue;</span>

<span class="nc bnc" id="L1875" title="All 2 branches missed.">            BufferedImage image = (p.isOnCarrier())</span>
<span class="nc" id="L1876">                ? ImageLibrary.getPathImage(ImageLibrary.PathType.NAVAL)</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                : (activeUnit != null)</span>
<span class="nc" id="L1878">                ? ImageLibrary.getPathImage(activeUnit)</span>
<span class="nc" id="L1879">                : null;</span>

<span class="nc bnc" id="L1881" title="All 2 branches missed.">            BufferedImage turns = (p.getTurns() &lt;= 0) ? null</span>
<span class="nc" id="L1882">                : lib.getStringImage(g, Integer.toString(p.getTurns()),</span>
<span class="nc" id="L1883">                                      Color.WHITE, font);</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">            g.setColor((turns == null) ? Color.GREEN : Color.RED);</span>

<span class="nc bnc" id="L1886" title="All 2 branches missed.">            if (debug) { // More detailed display</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">                if (activeUnit != null) {</span>
<span class="nc" id="L1888">                    image = ImageLibrary.getPathNextTurnImage(activeUnit);</span>
                }
<span class="nc" id="L1890">                turns = lib.getStringImage(g, Integer.toString(p.getTurns())</span>
<span class="nc" id="L1891">                    + &quot;/&quot; + Integer.toString(p.getMovesLeft()),</span>
<span class="nc" id="L1892">                    Color.WHITE, font);</span>
            }

<span class="nc" id="L1895">            g.translate(point.x, point.y);</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if (image == null) {</span>
<span class="nc" id="L1897">                g.fillOval(halfWidth, halfHeight, 10, 10);</span>
<span class="nc" id="L1898">                g.setColor(Color.BLACK);</span>
<span class="nc" id="L1899">                g.drawOval(halfWidth, halfHeight, 10, 10);</span>
<span class="nc" id="L1900">            } else {</span>
<span class="nc" id="L1901">                tv.displayCenteredImage(g, image);</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">                if (turns != null) {</span>
<span class="nc" id="L1903">                    tv.displayCenteredImage(g, turns);</span>
                }
            }
<span class="nc" id="L1906">            g.translate(-point.x, -point.y);</span>
        }
<span class="nc" id="L1908">    }</span>

    /**
     * Displays the given Unit onto the given Graphics2D object at the
     * location specified by the coordinates.
     *
     * @param g The Graphics2D object on which to draw the Unit.
     * @param unit The Unit to draw.
     */
    private void displayUnit(Graphics2D g, Unit unit) {
<span class="nc" id="L1918">        final Player player = getMyPlayer();</span>

        // Draw the unit.
        // If unit is sentry, draw in grayscale
<span class="nc bnc" id="L1922" title="All 2 branches missed.">        boolean fade = (unit.getState() == Unit.UnitState.SENTRY)</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">            || (unit.hasTile()</span>
<span class="nc bnc" id="L1924" title="All 4 branches missed.">                &amp;&amp; player != null &amp;&amp; !player.canSee(unit.getTile()));</span>
<span class="nc" id="L1925">        BufferedImage image = lib.getUnitImage(unit, fade);</span>
<span class="nc" id="L1926">        Point p = calculateUnitImagePositionInTile(image);</span>
<span class="nc" id="L1927">        g.drawImage(image, p.x, p.y, null);</span>

        // Draw an occupation and nation indicator.
<span class="nc" id="L1930">        String text = Messages.message(unit.getOccupationLabel(player, false));</span>
<span class="nc" id="L1931">        g.drawImage(lib.getOccupationIndicatorChip(g, unit, text),</span>
<span class="nc" id="L1932">                    (int)(TileViewer.STATE_OFFSET_X * lib.getScaleFactor()), 0,</span>
<span class="nc" id="L1933">                    null);</span>

        // Draw one small line for each additional unit (like in civ3).
<span class="nc" id="L1936">        int unitsOnTile = 0;</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">        if (unit.hasTile()) {</span>
            // When a unit is moving from tile to tile, it is
            // removed from the source tile.  So the unit stack
            // indicator cannot be drawn during the movement see
            // UnitMoveAnimation.animate() for details
<span class="nc" id="L1942">            unitsOnTile = unit.getTile().getTotalUnitCount();</span>
        }
<span class="nc bnc" id="L1944" title="All 2 branches missed.">        if (unitsOnTile &gt; 1) {</span>
<span class="nc" id="L1945">            g.setColor(Color.WHITE);</span>
<span class="nc" id="L1946">            int unitLinesY = OTHER_UNITS_OFFSET_Y;</span>
<span class="nc" id="L1947">            int x1 = (int)((TileViewer.STATE_OFFSET_X + OTHER_UNITS_OFFSET_X)</span>
<span class="nc" id="L1948">                * lib.getScaleFactor());</span>
<span class="nc" id="L1949">            int x2 = (int)((TileViewer.STATE_OFFSET_X + OTHER_UNITS_OFFSET_X</span>
<span class="nc" id="L1950">                    + OTHER_UNITS_WIDTH) * lib.getScaleFactor());</span>
<span class="nc bnc" id="L1951" title="All 4 branches missed.">            for (int i = 0; i &lt; unitsOnTile &amp;&amp; i &lt; MAX_OTHER_UNITS; i++) {</span>
<span class="nc" id="L1952">                g.drawLine(x1, unitLinesY, x2, unitLinesY);</span>
<span class="nc" id="L1953">                unitLinesY += 2;</span>
            }
        }

        // FOR DEBUGGING
        net.sf.freecol.server.ai.AIUnit au;
<span class="nc bnc" id="L1959" title="All 2 branches missed.">        if (FreeColDebugger.isInDebugMode(FreeColDebugger.DebugMode.MENUS)</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">            &amp;&amp; player != null</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">            &amp;&amp; !player.owns(unit)</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">            &amp;&amp; unit.getOwner().isAI()</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">            &amp;&amp; getFreeColServer() != null</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">            &amp;&amp; (au = getFreeColServer().getAIMain().getAIUnit(unit)) != null) {</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            if (FreeColDebugger.debugShowMission()) {</span>
<span class="nc" id="L1966">                g.setColor(Color.WHITE);</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">                g.drawString((!au.hasMission()) ? &quot;No mission&quot;</span>
<span class="nc" id="L1968">                    : lastPart(au.getMission().getClass().toString(), &quot;.&quot;),</span>
<span class="nc" id="L1969">                    0, 0);</span>
            }
<span class="nc bnc" id="L1971" title="All 4 branches missed.">            if (FreeColDebugger.debugShowMissionInfo() &amp;&amp; au.hasMission()) {</span>
<span class="nc" id="L1972">                g.setColor(Color.WHITE);</span>
<span class="nc" id="L1973">                g.drawString(au.getMission().toString(), 0, 25);</span>
            }
        }
<span class="nc" id="L1976">    }</span>

    /**
     * Gets the coordinates to draw a unit in a given tile.
     *
     * @param unitImage The unit's image
     * @return The coordinates where the unit should be drawn onscreen
     */
    private Point calculateUnitImagePositionInTile(BufferedImage unitImage) {
<span class="nc" id="L1985">        int unitX = (tileWidth - unitImage.getWidth()) / 2;</span>
<span class="nc" id="L1986">        int unitY = (tileHeight - unitImage.getHeight()) / 2 -</span>
<span class="nc" id="L1987">                    (int) (UNIT_OFFSET * lib.getScaleFactor());</span>

<span class="nc" id="L1989">        return new Point(unitX, unitY);</span>
    }

    private void displayCursor(Graphics2D g) {
<span class="nc" id="L1993">        BufferedImage cursorImage = lib.getMiscImage(ImageLibrary.UNIT_SELECT);</span>
<span class="nc" id="L1994">        g.drawImage(cursorImage, 0, 0, null);</span>
<span class="nc" id="L1995">    }</span>

    /**
     * Draws the borders of a territory on the given Tile. The
     * territory is either a country or a region.
     *
     * @param g a &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param tile a &lt;code&gt;Tile&lt;/code&gt;
     * @param type a &lt;code&gt;BorderType&lt;/code&gt;
     * @param opaque a &lt;code&gt;boolean&lt;/code&gt;
     */
    private void displayTerritorialBorders(Graphics2D g, Tile tile, BorderType type, boolean opaque) {
<span class="nc" id="L2007">        Player owner = tile.getOwner();</span>
<span class="nc" id="L2008">        Region region = tile.getRegion();</span>
<span class="nc bnc" id="L2009" title="All 4 branches missed.">        if ((type == BorderType.COUNTRY &amp;&amp; owner != null)</span>
<span class="nc bnc" id="L2010" title="All 4 branches missed.">            || (type == BorderType.REGION &amp;&amp; region != null)) {</span>
<span class="nc" id="L2011">            Stroke oldStroke = g.getStroke();</span>
<span class="nc" id="L2012">            g.setStroke(borderStroke);</span>
<span class="nc" id="L2013">            Color oldColor = g.getColor();</span>
<span class="nc" id="L2014">            Color c = null;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">            if (type == BorderType.COUNTRY)</span>
<span class="nc" id="L2016">                c = owner.getNationColor();</span>
<span class="nc bnc" id="L2017" title="All 2 branches missed.">            if (c == null)</span>
<span class="nc" id="L2018">                c = Color.WHITE;</span>
<span class="nc" id="L2019">            Color newColor = new Color(c.getRed(), c.getGreen(), c.getBlue(),</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">                                 (opaque) ? 255 : 100);</span>
<span class="nc" id="L2021">            g.setColor(newColor);</span>
<span class="nc" id="L2022">            GeneralPath path = new GeneralPath(GeneralPath.WIND_EVEN_ODD);</span>
<span class="nc" id="L2023">            path.moveTo(borderPoints.get(Direction.longSides.get(0)).x,</span>
<span class="nc" id="L2024">                        borderPoints.get(Direction.longSides.get(0)).y);</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">            for (Direction d : Direction.longSides) {</span>
<span class="nc" id="L2026">                Tile otherTile = tile.getNeighbourOrNull(d);</span>
<span class="nc" id="L2027">                Direction next = d.getNextDirection();</span>
<span class="nc" id="L2028">                Direction next2 = next.getNextDirection();</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">                if (otherTile == null</span>
<span class="nc bnc" id="L2030" title="All 4 branches missed.">                    || (type == BorderType.COUNTRY &amp;&amp; !owner.owns(otherTile))</span>
<span class="nc bnc" id="L2031" title="All 4 branches missed.">                    || (type == BorderType.REGION &amp;&amp; otherTile.getRegion() != region)) {</span>
<span class="nc" id="L2032">                    Tile tile1 = tile.getNeighbourOrNull(next);</span>
<span class="nc" id="L2033">                    Tile tile2 = tile.getNeighbourOrNull(next2);</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                    if (tile2 == null</span>
<span class="nc bnc" id="L2035" title="All 4 branches missed.">                        || (type == BorderType.COUNTRY &amp;&amp; !owner.owns(tile2))</span>
<span class="nc bnc" id="L2036" title="All 4 branches missed.">                        || (type == BorderType.REGION &amp;&amp; tile2.getRegion() != region)) {</span>
                        // small corner
<span class="nc" id="L2038">                        path.lineTo(borderPoints.get(next).x,</span>
<span class="nc" id="L2039">                                    borderPoints.get(next).y);</span>
<span class="nc" id="L2040">                        path.quadTo(controlPoints.get(next).x,</span>
<span class="nc" id="L2041">                                    controlPoints.get(next).y,</span>
<span class="nc" id="L2042">                                    borderPoints.get(next2).x,</span>
<span class="nc" id="L2043">                                    borderPoints.get(next2).y);</span>
<span class="nc" id="L2044">                    } else {</span>
<span class="nc" id="L2045">                        int dx = 0, dy = 0;</span>
<span class="nc bnc" id="L2046" title="All 5 branches missed.">                        switch(d) {</span>
<span class="nc" id="L2047">                        case NW: dx = halfWidth; dy = -halfHeight; break;</span>
<span class="nc" id="L2048">                        case NE: dx = halfWidth; dy = halfHeight; break;</span>
<span class="nc" id="L2049">                        case SE: dx = -halfWidth; dy = halfHeight; break;</span>
<span class="nc" id="L2050">                        case SW: dx = -halfWidth; dy = -halfHeight; break;</span>
                        default: break;
                        }
<span class="nc bnc" id="L2053" title="All 2 branches missed.">                        if (tile1 != null</span>
<span class="nc bnc" id="L2054" title="All 4 branches missed.">                            &amp;&amp; ((type == BorderType.COUNTRY &amp;&amp; owner.owns(tile1))</span>
<span class="nc bnc" id="L2055" title="All 4 branches missed.">                                || (type == BorderType.REGION &amp;&amp; tile1.getRegion() == region))) {</span>
                            // short straight line
<span class="nc" id="L2057">                            path.lineTo(borderPoints.get(next).x,</span>
<span class="nc" id="L2058">                                        borderPoints.get(next).y);</span>
                            // big corner
<span class="nc" id="L2060">                            Direction previous = d.getPreviousDirection();</span>
<span class="nc" id="L2061">                            Direction previous2 = previous.getPreviousDirection();</span>
<span class="nc" id="L2062">                            int ddx = 0, ddy = 0;</span>
<span class="nc bnc" id="L2063" title="All 5 branches missed.">                            switch(d) {</span>
<span class="nc" id="L2064">                            case NW: ddy = -tileHeight; break;</span>
<span class="nc" id="L2065">                            case NE: ddx = tileWidth; break;</span>
<span class="nc" id="L2066">                            case SE: ddy = tileHeight; break;</span>
<span class="nc" id="L2067">                            case SW: ddx = -tileWidth; break;</span>
                            default: break;
                            }
<span class="nc" id="L2070">                            path.quadTo(controlPoints.get(previous).x + dx,</span>
<span class="nc" id="L2071">                                        controlPoints.get(previous).y + dy,</span>
<span class="nc" id="L2072">                                        borderPoints.get(previous2).x + ddx,</span>
<span class="nc" id="L2073">                                        borderPoints.get(previous2).y + ddy);</span>
<span class="nc" id="L2074">                        } else {</span>
                            // straight line
<span class="nc" id="L2076">                            path.lineTo(borderPoints.get(d).x + dx,</span>
<span class="nc" id="L2077">                                        borderPoints.get(d).y + dy);</span>
                        }
                    }
<span class="nc" id="L2080">                } else {</span>
<span class="nc" id="L2081">                    path.moveTo(borderPoints.get(next2).x,</span>
<span class="nc" id="L2082">                                borderPoints.get(next2).y);</span>
                }
            }
<span class="nc" id="L2085">            g.draw(path);</span>
<span class="nc" id="L2086">            g.setColor(oldColor);</span>
<span class="nc" id="L2087">            g.setStroke(oldStroke);</span>
        }
<span class="nc" id="L2089">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>