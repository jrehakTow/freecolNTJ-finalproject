<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Unit.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Unit.java</span></div><h1>Unit.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.ToIntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.CombatModel;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import net.sf.freecol.common.networking.DOMMessage;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;


import org.w3c.dom.Element;


/**
 * Represents all pieces that can be moved on the map-board. This includes:
 * colonists, ships, wagon trains e.t.c.
 *
 * Every &lt;code&gt;Unit&lt;/code&gt; is owned by a {@link Player} and has a
 * {@link Location}.
 */
public class Unit extends GoodsLocation
    implements Consumer, Locatable, Movable, Nameable, Ownable {

<span class="fc" id="L64">    private static final Logger logger = Logger.getLogger(Unit.class.getName());</span>

    /**
     * A large number of turns, denoting pathfinding failure.  Do not use
     * INFINITY as further calculation might use this.
     */
    public static final int MANY_TURNS = 10000;

    public static final String CARGO_CHANGE = &quot;CARGO_CHANGE&quot;;
    public static final String MOVE_CHANGE = &quot;MOVE_CHANGE&quot;;
    public static final String ROLE_CHANGE = &quot;ROLE_CHANGE&quot;;

    /** Compare units by location. */
<span class="fc" id="L77">    public static final Comparator&lt;Unit&gt; locComparator</span>
<span class="pc" id="L78">        = Comparator.comparingInt(u -&gt; Location.getRank(u));</span>

    /** A comparator to compare units by type then role. */
<span class="fc" id="L81">    public static final Comparator&lt;Unit&gt; typeRoleComparator</span>
<span class="fc" id="L82">        = Comparator.comparing(Unit::getType)</span>
<span class="fc" id="L83">            .thenComparing(Comparator.comparing(Unit::getRole));</span>
    
    /** A state a Unit can have. */
<span class="fc" id="L86">    public static enum UnitState {</span>
<span class="fc" id="L87">        ACTIVE,</span>
<span class="fc" id="L88">        FORTIFIED,</span>
<span class="fc" id="L89">        SENTRY,</span>
<span class="fc" id="L90">        IN_COLONY,</span>
<span class="fc" id="L91">        IMPROVING,</span>
<span class="fc" id="L92">        // @compat 0.10.0</span>
<span class="fc" id="L93">        TO_EUROPE,</span>
<span class="fc" id="L94">        TO_AMERICA,</span>
<span class="fc" id="L95">        // end @compat</span>
<span class="fc" id="L96">        FORTIFYING,</span>
<span class="fc" id="L97">        SKIPPED;</span>

        /**
         * Get the stem key for this unit state.
         *
         * @return The stem key.
         */
        public String getKey() {
<span class="nc" id="L105">            return &quot;unitState.&quot; + getEnumKey(this);</span>
        }
    }

    /** The individual name of this unit, not of the unit type. */
<span class="pc" id="L110">    protected String name = null;</span>

    /** The owner player. */
    protected Player owner;

    /** The unit type. */
    protected UnitType unitType;

    /** Current unit state. */
<span class="pc" id="L119">    protected UnitState state = UnitState.ACTIVE;</span>

    /** Current unit role. */
    protected Role role;

    /**
     * The amount of role-equipment this unit carries, subject to
     * role.getMaximumCount().  Currently zero or one except for pioneers.
     */
    protected int roleCount;

    /** The current unit location. */
    protected Location location;

    /** The last entry location used by this unit. */
    protected Location entryLocation;

    /** The number of moves this unit has left this turn. */
    protected int movesLeft;

    /** What type of goods this unit produces in its occupation. */
    protected GoodsType workType;

    /** What type of goods this unit last earned experience producing. */
    protected GoodsType experienceType;

    /** The mount of experience a unit has earned. */
<span class="pc" id="L146">    protected int experience = 0;</span>

    /**
     * The number of turns until the work is finished (e.g. sailing,
     * improving), or '-1' if a Unit can stay in its state forever.
     */
    protected int workLeft;

    /**
     * What is being improved (to be used only for PIONEERs - where
     * they are working.
     */
    protected TileImprovement workImprovement;

    /** The student of this Unit, if it has one. */
    protected Unit student;

    /** The teacher of this Unit, if it has one. */
    protected Unit teacher;

    /** Number of turns of training needed by this unit. */
<span class="pc" id="L167">    protected int turnsOfTraining = 0;</span>

    /** The original nationality. */
<span class="pc" id="L170">    protected String nationality = null;</span>

    /** The original ethnicity. */
<span class="pc" id="L173">    protected String ethnicity = null;</span>

    /** The home settlement of a native unit. */
<span class="pc" id="L176">    protected IndianSettlement indianSettlement = null;</span>

    /** For now; only used by ships when repairing. */
    protected int hitPoints;

    /** A destination for go-to moves. */
<span class="pc" id="L182">    protected Location destination = null;</span>

    /** The trade route this unit has. */
<span class="pc" id="L185">    protected TradeRoute tradeRoute = null;</span>

    /** Which stop in a trade route the unit is going to. */
<span class="pc" id="L188">    protected int currentStop = -1;</span>

    /** To be used only for type == TREASURE_TRAIN */
    protected int treasureAmount;

    /**
     * The attrition this unit has accumulated.  At the moment, this
     * equals the number of turns it has spent in the open.
     */
<span class="pc" id="L197">    protected int attrition = 0;</span>

    /**
     * The amount of goods carried by this unit.  This variable is
     * only used by the clients.  A negative value signals that the
     * variable is not in use.
     *
     * @see #getVisibleGoodsCount()
     */
    protected int visibleGoodsCount;


    /**
     * Constructor for ServerUnit.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     */
    protected Unit(Game game) {
<span class="fc" id="L215">        super(game);</span>
<span class="fc" id="L216">    }</span>

    /**
     * Initialize this object from an XML-representation of this object.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param e An XML-element that will be used to initialize this object.
     */
    public Unit(Game game, Element e) {
<span class="nc" id="L225">        super(game, null);// Must override identifier when called client side</span>

<span class="nc" id="L227">        DOMMessage.readFromXMLElement(this, e);</span>
<span class="nc" id="L228">    }</span>

    /**
     * Creates a new &lt;code&gt;Unit&lt;/code&gt; with the given
     * identifier.  The object should later be initialized by calling
     * {@link #readFromXML(FreeColXMLReader)}.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param id The object identifier.
     */
    public Unit(Game game, String id) {
<span class="fc" id="L239">        super(game, id);</span>
<span class="fc" id="L240">    }</span>


    /**
     * Get the individual name of this unit.
     *
     * @return The individual name.
     */
    @Override
    public String getName() {
<span class="fc" id="L250">        return name;</span>
    }

    /**
     * Set the individual name of this unit.
     *
     * @param newName The new name.
     */
    @Override
    public void setName(String newName) {
<span class="fc" id="L260">        this.name = newName;</span>
<span class="fc" id="L261">    }</span>

    /**
     * Get the name of the apparent owner of this Unit,
     * (like getOwner().getNationAsString() but handles pirates).
     *
     * @return The name of the apparent owner of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public StringTemplate getApparentOwnerName() {
<span class="fc bfc" id="L270" title="All 2 branches covered.">        Player own = (hasAbility(Ability.PIRACY)) ? getGame().getUnknownEnemy()</span>
<span class="fc" id="L271">            : owner;</span>
<span class="fc" id="L272">        return own.getNationLabel();</span>
    }

    /** What type of unit label do we want? */
<span class="fc" id="L276">    public static enum UnitLabelType {</span>
<span class="fc" id="L277">        PLAIN,      // Just the basics</span>
<span class="fc" id="L278">        NATIONAL,   // Add the nation</span>
<span class="fc" id="L279">        FULL        // Add the equipment and extras</span>
    }

    /**
     * Get a plain string template for a unit.
     *
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel() {
<span class="fc" id="L288">        return getLabel(UnitLabelType.PLAIN);</span>
    }

    /**
     * Get a string template for a unit.
     *
     * The PLAIN template contains:
     * - The type of the unit
     * - A role if not the default
     * - The specific name of the unit if it has one
     * The NATIONAL template adds the nation
     * The FULL template adds equipment annotations
     *
     * @param ult The type of label to get.
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel(UnitLabelType ult) {
<span class="fc" id="L305">        final UnitType type = getType();</span>
<span class="fc" id="L306">        final Role role = getRole();</span>
<span class="fc" id="L307">        final Player owner = getOwner();</span>
<span class="pc bpc" id="L308" title="3 of 6 branches missed.">        if (type == null || role == null || owner == null) {</span>
<span class="nc" id="L309">            return null; // Probably disposed</span>
        }

<span class="pc bpc" id="L312" title="1 of 4 branches missed.">        switch (ult) {</span>
        case PLAIN:
<span class="fc" id="L314">            return Messages.getUnitLabel(getName(), type.getId(), 1, null,</span>
<span class="fc" id="L315">                                         role.getId(), null);</span>

        case NATIONAL:
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (role.getMaximumCount() &gt; 1) {</span>
                // If the amount of equipment can vary an equipment
                // label is required, so fall through into the FULL case.
            } else {
<span class="fc" id="L322">                return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L323">                                             owner.getNationId(), role.getId(),</span>
<span class="fc" id="L324">                                             null);</span>
            }
            // Fall through

        case FULL:
<span class="fc" id="L329">            StringTemplate extra = null;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            if (role.isDefaultRole()) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                if (canCarryTreasure()) {</span>
<span class="fc" id="L332">                    extra = StringTemplate.template(&quot;goldAmount&quot;)</span>
<span class="fc" id="L333">                        .addAmount(&quot;%amount%&quot;, getTreasureAmount());</span>
<span class="fc" id="L334">                } else {</span>
<span class="fc" id="L335">                    boolean noEquipment = false;</span>
                    // unequipped expert has no-equipment label
<span class="fc" id="L337">                    List&lt;Role&gt; expertRoles = type.getExpertRoles();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">                    for (Role someRole : expertRoles) {</span>
<span class="fc" id="L339">                        String key = someRole.getId() + &quot;.noequipment&quot;;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                        if (Messages.containsKey(key)) {</span>
<span class="fc" id="L341">                            extra = StringTemplate.key(key);</span>
<span class="fc" id="L342">                            break;</span>
                        }
                    }
                }
<span class="fc" id="L346">            } else {</span>
<span class="fc" id="L347">                String equipmentKey = role.getId() + &quot;.equipment&quot;;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (Messages.containsKey(equipmentKey)) {</span>
                    // Currently only used for missionary which does not
                    // have equipment that directly corresponds to goods.
<span class="fc" id="L351">                    extra = AbstractGoods.getLabel(equipmentKey, 1);</span>
<span class="fc" id="L352">                } else {</span>
                    // Other roles can be characterized by their goods.
<span class="fc" id="L354">                    List&lt;AbstractGoods&gt; requiredGoods</span>
<span class="fc" id="L355">                        = role.getRequiredGoods(getRoleCount());</span>
<span class="fc" id="L356">                    boolean first = true;</span>
<span class="fc" id="L357">                    extra = StringTemplate.label(&quot;&quot;);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">                    for (AbstractGoods ag : requiredGoods) {</span>
<span class="fc bfc" id="L359" title="All 2 branches covered.">                        if (first) first = false; else extra.addName(&quot; &quot;);</span>
<span class="fc" id="L360">                        extra.addStringTemplate(ag.getLabel());</span>
                    }
                }
            }
<span class="fc" id="L364">            return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L365">                                         owner.getNationId(), role.getId(),</span>
<span class="fc" id="L366">                                         extra);</span>
        default: // Can not happen
            break;
        }
<span class="nc" id="L370">        return null;</span>
    }

    /**
     * Get the basic i18n description for this unit.
     *
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription() {
<span class="fc" id="L379">        return Messages.message(getLabel());</span>
    }

    /**
     * Get the basic i18n description for this unit.
     *
     * @param ult The label type required.
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription(UnitLabelType ult) {
<span class="fc" id="L389">        return Messages.message(getLabel(ult));</span>
    }

    /**
     * Get a label for the chance of success in a potential combat.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to attack into.
     * @return A suitable label.
     */
    public StringTemplate getCombatLabel(Tile tile) {
<span class="nc" id="L399">        final CombatModel.CombatOdds combatOdds = getGame().getCombatModel()</span>
<span class="nc" id="L400">            .calculateCombatOdds(this, tile.getDefendingUnit(this));</span>
        // If attacking a settlement, the true odds are never
        // known because units may be hidden within
<span class="nc bnc" id="L403" title="All 2 branches missed.">        boolean unknown = combatOdds.win == CombatModel.CombatOdds.UNKNOWN_ODDS</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            || tile.hasSettlement();</span>
<span class="nc" id="L405">        return StringTemplate.template(&quot;model.unit.attackTileOdds&quot;)</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            .addName(&quot;%chance%&quot;, (unknown) ? &quot;??&quot;</span>
<span class="nc" id="L407">                : String.valueOf((int)(combatOdds.win * 100)));</span>
    }
    
    /**
     * Get a destination label for this unit.
     *
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing where this unit
     *     is going.
     */
    public StringTemplate getDestinationLabel() {
        // Create the right tag for the tagged &quot;goingTo&quot; message.
<span class="nc bnc" id="L418" title="All 2 branches missed.">        String type = (isPerson()) ? &quot;person&quot;</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            : (isNaval()) ? &quot;ship&quot;</span>
<span class="nc" id="L420">            : &quot;other&quot;;</span>
<span class="nc" id="L421">        return getDestinationLabel(type, getDestination(), getOwner());</span>
    }

    /**
     * Get a destination label for a given unit tag, destination and player.
     *
     * @param tag The unit tag for the &quot;goingTo&quot; message.
     * @param destination The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewpoint.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing the unit movement.
     */
    public static StringTemplate getDestinationLabel(String tag,
        Location destination, Player player) {
<span class="nc" id="L434">        return StringTemplate.template(&quot;model.unit.goingTo&quot;)</span>
<span class="nc" id="L435">            .addTagged(&quot;%type%&quot;, tag)</span>
<span class="nc" id="L436">            .addStringTemplate(&quot;%location%&quot;,</span>
<span class="nc" id="L437">                destination.getLocationLabelFor(player));</span>
    }

    /**
     * Get a string template describing the repair state of this unit.
     *
     * @return A repair label.
     */
    public StringTemplate getRepairLabel() {
<span class="nc" id="L446">        return StringTemplate.template(&quot;model.unit.underRepair&quot;)</span>
<span class="nc" id="L447">            .addAmount(&quot;%turns%&quot;, getTurnsForRepair());</span>
    }

    /**
     * Get the &lt;code&gt;UnitType&lt;/code&gt; value.
     *
     * @return The current &lt;code&gt;UnitType&lt;/code&gt;.
     */
    public final UnitType getType() {
<span class="fc" id="L456">        return unitType;</span>
    }

    /**
     * Sets the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     */
    public void setType(UnitType unitType) {
<span class="fc" id="L467">        this.unitType = unitType;</span>
<span class="fc" id="L468">    }</span>

    /**
     * Changes the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     * @return True if the type change succeeds.
     */
    public boolean changeType(UnitType unitType) {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        if (!unitType.isAvailableTo(owner)) return false;</span>

<span class="fc" id="L481">        setType(unitType);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        if (getMovesLeft() &gt; getInitialMovesLeft()) {</span>
<span class="nc" id="L483">            setMovesLeft(getInitialMovesLeft());</span>
        }
<span class="fc" id="L485">        hitPoints = unitType.getHitPoints();</span>
<span class="fc bfc" id="L486" title="All 4 branches covered.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="fc" id="L487">            getTeacher().setStudent(null);</span>
<span class="fc" id="L488">            setTeacher(null);</span>
        }
<span class="fc" id="L490">        return true;</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is naval.
     *
     * @return True if this is a naval &lt;code&gt;Unit&lt;/code&gt;.
     */
    public boolean isNaval() {
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        return (unitType == null) ? false : unitType.isNaval();</span>
    }

    /**
     * Checks if this unit is an undead.
     *
     * @return True if the unit is undead.
     */
    public boolean isUndead() {
<span class="nc" id="L508">        return hasAbility(Ability.UNDEAD);</span>
    }

    /**
     * Can this unit carry treasure (like a treasure train)?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; can carry treasure.
     */
    public boolean canCarryTreasure() {
<span class="fc" id="L517">        return hasAbility(Ability.CARRY_TREASURE);</span>
    }

    /**
     * Can this unit capture enemy goods?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; is capable of capturing goods.
     */
    public boolean canCaptureGoods() {
<span class="fc" id="L526">        return hasAbility(Ability.CAPTURE_GOODS);</span>
    }

    /**
     * Checks if this is a trading &lt;code&gt;Unit&lt;/code&gt;, meaning that it
     * can trade with settlements.
     *
     * @return True if this is a trading unit.
     */
    public boolean isTradingUnit() {
<span class="fc bfc" id="L536" title="All 4 branches covered.">        return canCarryGoods() &amp;&amp; owner.isEuropean();</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is a `colonist'.  A unit is a
     * colonist if it is European and can build a new &lt;code&gt;Colony&lt;/code&gt;.
     *
     * @return True if this unit is a colonist.
     */
    public boolean isColonist() {
<span class="fc bfc" id="L546" title="All 2 branches covered.">        return unitType.hasAbility(Ability.FOUND_COLONY)</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">            &amp;&amp; owner.hasAbility(Ability.FOUNDS_COLONIES);</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is able to carry {@link Locatable}s.
     *
     * @return True if this unit can carry goods or other units.
     */
    public boolean isCarrier() {
<span class="pc bpc" id="L556" title="1 of 4 branches missed.">        return unitType.canCarryGoods() || unitType.canCarryUnits();</span>
    }

    /**
     * Checks if this unit is a person, that is not a ship or wagon.
     * Surprisingly difficult without explicit enumeration because
     * model.ability.person only arrived in 0.10.1.
     *
     * @return True if this unit is a person.
     */
    public boolean isPerson() {
<span class="fc bfc" id="L567" title="All 2 branches covered.">        return hasAbility(Ability.PERSON)</span>
            // @compat 0.10.0
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_COLONY)</span>
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_INDIAN_SETTLEMENT)</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.FOUND_COLONY)</span>
            // Nick also had:
            //     &amp;&amp; (!hasAbility(&quot;model.ability.carryGoods&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryUnits&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryTreasure&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.bombard&quot;))
            // ...but that should be unnecessary.
            // end @compat
            ;
    }

    /**
     * Gets the state of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @return The state of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public UnitState getState() {
<span class="fc" id="L588">        return state;</span>
    }

    /**
     * Checks if a &lt;code&gt;Unit&lt;/code&gt; can get the given state set.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, FORTIFIED, ...}.
     * @return True if the &lt;code&gt;Unit&lt;/code&gt; state can be changed to
     *     the new value.
     */
    public boolean checkSetState(UnitState s) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (getState() == s) return false;</span>
<span class="pc bpc" id="L601" title="2 of 8 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L603">            return true;</span>
        case FORTIFIED:
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">            return getState() == UnitState.FORTIFYING;</span>
        case FORTIFYING:
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            return getMovesLeft() &gt; 0;</span>
        case IMPROVING:
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            return getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                &amp;&amp; getLocation() instanceof Tile</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                &amp;&amp; getOwner().canAcquireForImprovement(getLocation().getTile());</span>
        case IN_COLONY:
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            return !isNaval();</span>
        case SENTRY:
<span class="fc" id="L615">            return true;</span>
        case SKIPPED:
<span class="nc bnc" id="L617" title="All 2 branches missed.">            return getState() == UnitState.ACTIVE;</span>
        default:
<span class="nc" id="L619">            logger.warning(&quot;Invalid unit state: &quot; + s);</span>
<span class="nc" id="L620">            return false;</span>
        }
    }

    /**
     * Sets a new state for this unit and initializes the amount of
     * work the unit has left.
     *
     * If the work needs turns to be completed (for instance when
     * plowing), then the moves the unit has still left will be used
     * up. Some work (basically building a road with a hardy pioneer)
     * might actually be finished already in this method-call, in
     * which case the state is set back to UnitState.ACTIVE.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, UnitState.FORTIFIED, ...}.
     */
    public void setState(UnitState s) {
<span class="fc bfc" id="L638" title="All 2 branches covered.">        if (state == s) {</span>
            // No need to do anything when the state is unchanged
<span class="fc" id="L640">            return;</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        } else if (!checkSetState(s)) {</span>
<span class="nc" id="L642">            throw new IllegalStateException(&quot;Illegal UnitState transition: &quot;</span>
<span class="nc" id="L643">                + state + &quot; -&gt; &quot; + s);</span>
        } else {
<span class="fc" id="L645">            setStateUnchecked(s);</span>
        }
<span class="fc" id="L647">    }</span>

    /**
     * Actually set the unit state.
     *
     * @param s The new &lt;code&gt;UnitState&lt;/code&gt;.
     */
    protected void setStateUnchecked(UnitState s) {
        // FIXME: move to the server.
        // Cleanup the old UnitState, for example destroy the
        // TileImprovment being built by a pioneer.
<span class="fc bfc" id="L658" title="All 2 branches covered.">        switch (state) {</span>
        case IMPROVING:
<span class="pc bpc" id="L660" title="3 of 4 branches missed.">            if (workImprovement != null &amp;&amp; getWorkLeft() &gt; 0) {</span>
                // Remove the tile improvement if it is incomplete
                // and no one else is working on it
                Tile tile;
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (!workImprovement.isComplete()</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                    &amp;&amp; (tile = workImprovement.getTile()) != null</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                    &amp;&amp; tile.getTileItemContainer() != null</span>
<span class="nc" id="L667">                    &amp;&amp; none(tile.getUnitList(), u -&gt;</span>
<span class="nc bnc" id="L668" title="All 4 branches missed.">                        u != this &amp;&amp; u.getState() == UnitState.IMPROVING</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">                             &amp;&amp; u.getWorkImprovement() == workImprovement)) {</span>
<span class="nc" id="L670">                    workImprovement.getTile().getTileItemContainer()</span>
<span class="nc" id="L671">                        .removeTileItem(workImprovement);</span>
                }
<span class="nc" id="L673">                setWorkImprovement(null);</span>
            }
<span class="nc" id="L675">            break;</span>
        default:
            // do nothing
<span class="fc" id="L678">            break;</span>
        }

        // Now initiate the new UnitState
<span class="pc bpc" id="L682" title="1 of 7 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L684">            setWorkLeft(-1);</span>
<span class="fc" id="L685">            break;</span>
        case SENTRY:
<span class="fc" id="L687">            setWorkLeft(-1);</span>
<span class="fc" id="L688">            break;</span>
        case FORTIFIED:
<span class="fc" id="L690">            setWorkLeft(-1);</span>
<span class="fc" id="L691">            movesLeft = 0;</span>
<span class="fc" id="L692">            break;</span>
        case FORTIFYING:
<span class="fc" id="L694">            setWorkLeft(1);</span>
<span class="fc" id="L695">            break;</span>
        case IMPROVING:
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">            if (workImprovement == null) {</span>
<span class="nc" id="L698">                setWorkLeft(-1);</span>
<span class="nc" id="L699">            } else {</span>
<span class="fc" id="L700">                setWorkLeft(workImprovement.getTurnsToComplete()</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">                    + ((getMovesLeft() &gt; 0) ? 0 : 1));</span>
            }
<span class="fc" id="L703">            movesLeft = 0;</span>
<span class="fc" id="L704">            break;</span>
        case SKIPPED: // do nothing
<span class="nc" id="L706">            break;</span>
        default:
<span class="fc" id="L708">            setWorkLeft(-1);</span>
        }
<span class="fc" id="L710">        state = s;</span>
<span class="fc" id="L711">    }</span>

    /**
     * Sets the given state to all the units that are carried.
     *
     * @param state The &lt;code&gt;UnitState&lt;/code&gt; to set..
     */
    public void setStateToAllChildren(UnitState state) {
<span class="fc bfc" id="L719" title="All 2 branches covered.">        if (canCarryUnits()) {</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">            for (Unit u : getUnitList()) u.setState(state);</span>
        }
<span class="fc" id="L722">    }</span>

    /**
     * Change the owner of this unit.
     *
     * -vis: This routine calls setOwner() and thus has visibility
     * implications.  Ideally it should be in ServerUnit but we keep
     * it here for the benefit of the test suite.
     *
     * @param owner The new owner &lt;code&gt;Player&lt;/code&gt;.
     */
    public void changeOwner(Player owner) {
<span class="fc" id="L734">        final Player oldOwner = this.owner;</span>
<span class="pc bpc" id="L735" title="1 of 2 branches missed.">        if (oldOwner == owner) return;</span>

<span class="pc bpc" id="L737" title="1 of 2 branches missed.">        if (oldOwner == null) {</span>
<span class="nc" id="L738">            logger.warning(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L739">                + &quot; had no owner, when changing owner to &quot; + owner.getId());</span>
        }

        // This need to be set right away.
<span class="fc" id="L743">        setOwner(owner);</span>

        // Clear trade route and goto orders if changing owner.
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (getTradeRoute() != null) setTradeRoute(null);</span>
<span class="pc bpc" id="L747" title="1 of 2 branches missed.">        if (getDestination() != null) setDestination(null);</span>

        // If its a carrier, we need to update the units it has loaded
        // before finishing with it
<span class="fc bfc" id="L751" title="All 2 branches covered.">        for (Unit u : getUnitList()) u.changeOwner(owner);</span>

<span class="pc bpc" id="L753" title="3 of 4 branches missed.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L754">            getTeacher().setStudent(null);</span>
<span class="nc" id="L755">            setTeacher(null);</span>
        }

<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (oldOwner != null) oldOwner.removeUnit(this);</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">        if (owner != null) owner.addUnit(this);</span>

<span class="fc" id="L761">        getGame().notifyOwnerChanged(this, oldOwner, owner);</span>
<span class="fc" id="L762">    }</span>

    /**
     * Gets the unit role.
     *
     * @return The &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Role getRole() {
<span class="fc" id="L770">        return role;</span>
    }

    /**
     * Sets the &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     */
    public void setRole(Role role) {
<span class="fc" id="L779">        this.role = role;</span>
<span class="fc" id="L780">    }</span>

    /**
     * Get the role count.
     *
     * @return The current role count.
     */    
    public int getRoleCount() {
<span class="fc" id="L788">        return roleCount;</span>
    }

    /**
     * Set the role count.
     *
     * @param roleCount The new role count.
     */    
    public void setRoleCount(int roleCount) {
<span class="fc" id="L797">        this.roleCount = roleCount;</span>
<span class="fc" id="L798">    }</span>

    /**
     * Does this unit have the default role?
     *
     * @return True if the unit has the default &lt;code&gt;Role&lt;/code&gt;.
     */
    public boolean hasDefaultRole() {
<span class="fc" id="L806">        return role.isDefaultRole();</span>
    }

    /**
     * Get the last part of the role identifier, which is often used as
     * part of a message key.
     *
     * @return The role suffix.
     */
    public String getRoleSuffix() {
<span class="fc" id="L816">        return Role.getRoleSuffix(role.getId());</span>
    }

    /**
     * Change the current role of this unit.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     * @param roleCount The new role count.
     */
    public void changeRole(Role role, int roleCount) {
<span class="fc bfc" id="L826" title="All 2 branches covered.">        if (!role.isCompatibleWith(getRole())) {</span>
            // Clear experience if changing to an incompatible role.
<span class="fc" id="L828">            setExperience(0);</span>
        }
<span class="fc" id="L830">        setRole(role);</span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">        setRoleCount((role.isDefaultRole()) ? 0 : roleCount);</span>
<span class="fc" id="L832">    }</span>

    /**
     * Change the current role count.  On zero, revert to default role.
     *
     * @param delta The change to apply to the role count.
     * @return True if the role count reached zero.
     */
    public boolean changeRoleCount(int delta) {
<span class="fc" id="L841">        this.roleCount = Math.max(0, this.roleCount + delta);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">        if (this.roleCount != 0) return false;</span>
<span class="fc" id="L843">        this.role = getSpecification().getDefaultRole();</span>
<span class="fc" id="L844">        return true;</span>
    }

    /**
     * Is a role available to this unit?
     *
     * @param role The &lt;code&gt;Role&lt;/code&gt; to test.
     * @return True if the role is available to this unit.
     */
    public boolean roleIsAvailable(Role role) {
<span class="fc" id="L854">        return role.isAvailableTo(this);</span>
    }

    /**
     * Filter a list of roles to return only those available to this unit.
     *
     * @param roles The list of &lt;code&gt;Role&lt;/code&gt;s to filter, if null all
     *     available roles are used.
     * @return A list of available &lt;code&gt;Role&lt;/code&gt;s.
     */
    public List&lt;Role&gt; getAvailableRoles(List&lt;Role&gt; roles) {
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">        if (roles == null) roles = getSpecification().getRoles();</span>
<span class="fc" id="L866">        return transform(roles, r -&gt; roleIsAvailable(r), Collectors.toList());</span>
    }

    /**
     * Get a military role for this unit.
     *
     * @return A military &lt;code&gt;Role&lt;/code&gt;, or null if none found.
     */
    public Role getMilitaryRole() {
<span class="fc" id="L875">        List&lt;Role&gt; roles</span>
<span class="fc" id="L876">            = getAvailableRoles(getSpecification().getMilitaryRoles());</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">        return (roles.isEmpty()) ? null : roles.get(0);</span>
    }

    /**
     * Get the change in goods required to change to a new role/count.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt; to change to.
     * @param roleCount The new role count.
     * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; defining the change
     *     in goods required.
     */
    public List&lt;AbstractGoods&gt; getGoodsDifference(Role role, int roleCount) {
<span class="fc" id="L889">        return Role.getGoodsDifference(getRole(), getRoleCount(),</span>
<span class="fc" id="L890">                                       role, roleCount);</span>
    }

    /**
     * Sets the units location without updating any other variables
     *
     * get/setLocation are in Locatable interface.
     *
     * -vis: This routine changes player visibility.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setLocationNoUpdate(Location newLocation) {
<span class="fc" id="L903">        this.location = newLocation;</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">        if (newLocation instanceof Colony) {</span>
<span class="nc" id="L905">            logger.warning(&quot;Unit-&gt;Colony &quot; + this.getId()</span>
<span class="nc" id="L906">                + &quot; &quot; + ((Colony)newLocation).getId() + &quot;\n&quot;</span>
<span class="nc" id="L907">                + net.sf.freecol.common.debug.FreeColDebugger.stackTraceToString());</span>
        }                
<span class="fc" id="L909">    }</span>

    /**
     * Verifies if the unit is aboard a carrier
     *
     * @return True if the unit is aboard a carrier.
     */
    public boolean isOnCarrier() {
<span class="fc" id="L917">        return getLocation() instanceof Unit;</span>
    }

    /**
     * Gets the carrier this unit is aboard if any.
     *
     * @return The carrier this unit is aboard, or null if none.
     */
    public Unit getCarrier() {
<span class="fc bfc" id="L926" title="All 2 branches covered.">        return (isOnCarrier()) ? ((Unit)getLocation()) : null;</span>
    }

    /**
     * Checks whether this &lt;code&gt;Unit&lt;/code&gt; is at sea off the map, or
     * on board of a carrier that is.
     *
     * @return True if at sea.
     */
    public boolean isAtSea() {
<span class="fc bfc" id="L936" title="All 2 branches covered.">        return (isOnCarrier()) ? getCarrier().isAtSea()</span>
<span class="fc" id="L937">            : getLocation() instanceof HighSeas;</span>
    }

    /**
     * Checks if this unit is running a mission.
     *
     * @return True if this unit is running a mission.
     */
    public boolean isInMission() {
<span class="pc bfc" id="L946" title="All 2 branches covered.">        return hasAbility(Ability.ESTABLISH_MISSION)</span>
<span class="pc bpc" id="L947" title="1 of 2 branches missed.">            &amp;&amp; (getLocation() instanceof IndianSettlement</span>
                // @compat 0.10.x
                // Remove this when PET missionary serialization is retired
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">                || getLocation() == null</span>
                // end @compat 0.10.x
                );
    }

    /**
     * Checks whether this unit is working inside a colony.
     *
     * @return True if in colony.
     */
    public boolean isInColony() {
<span class="fc" id="L961">        return getLocation() instanceof WorkLocation;</span>
    }

    /**
     * Is this unit on a tile?
     *
     * @return True if this unit is on a tile.
     */
    public boolean hasTile() {
<span class="fc bfc" id="L970" title="All 2 branches covered.">        return getTile() != null;</span>
    }


    /**
     * Gets the work location this unit is working in.
     *
     * @return The current &lt;code&gt;WorkLocation&lt;/code&gt;, or null if none.
     */
    public WorkLocation getWorkLocation() {
<span class="fc bfc" id="L980" title="All 2 branches covered.">        return (isInColony()) ? (WorkLocation)getLocation() : null;</span>
    }

    /**
     * Gets the &lt;code&gt;Building&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;Building&lt;/code&gt;, or null if none.
     */
    public Building getWorkBuilding() {
<span class="nc bnc" id="L989" title="All 2 branches missed.">        return (getLocation() instanceof Building) ? (Building)getLocation()</span>
<span class="nc" id="L990">            : null;</span>
    }

    /**
     * Gets the &lt;code&gt;ColonyTile&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;ColonyTile&lt;/code&gt;, or null if none.
     */
    public ColonyTile getWorkTile() {
<span class="nc bnc" id="L999" title="All 2 branches missed.">        return (getLocation() instanceof ColonyTile) ? (ColonyTile)getLocation()</span>
<span class="nc" id="L1000">            : null;</span>
    }

    /**
     * Gets the entry location for this unit to use when returning from
     * {@link Europe}.
     *
     * @return The entry &lt;code&gt;Location&lt;/code&gt;.
     */
    public Location getEntryLocation() {
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (entryLocation == null) {</span>
<span class="nc" id="L1011">            entryLocation = owner.getEntryLocation();</span>
        }
<span class="nc" id="L1013">        return entryLocation;</span>
    }

    /**
     * Sets the entry location in which this unit will be put when
     * returning from {@link Europe}.
     *
     * @param entryLocation The new entry &lt;code&gt;Location&lt;/code&gt;.
     * @see #getEntryLocation
     */
    public void setEntryLocation(Location entryLocation) {
<span class="fc" id="L1024">        this.entryLocation = entryLocation;</span>
<span class="pc bpc" id="L1025" title="1 of 2 branches missed.">        if (entryLocation != null) {</span>
<span class="fc" id="L1026">            owner.setEntryLocation(entryLocation);</span>
        }
<span class="fc" id="L1028">    }</span>

    /**
     * Gets the entry tile for this unit, or if null the default
     * entry location for the owning player.
     *
     * @return The entry &lt;code&gt;Tile&lt;/code&gt;.
     */
    public Tile getFullEntryLocation() {
<span class="nc bnc" id="L1037" title="All 2 branches missed.">        return (entryLocation != null) ? (Tile) entryLocation</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">            : (owner.getEntryLocation() == null) ? null</span>
<span class="nc" id="L1039">            : owner.getEntryLocation().getTile();</span>
    }

    /**
     * Get the moves left this turn.
     *
     * @return The number of moves this &lt;code&gt;Unit&lt;/code&gt; has left.
     */
    @Override
    public int getMovesLeft() {
<span class="fc" id="L1049">        return movesLeft;</span>
    }

    /**
     * Sets the moves left this turn.
     *
     * @param moves The new amount of moves left this &lt;code&gt;Unit&lt;/code&gt;
     *     should have.
     */
    public void setMovesLeft(int moves) {
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        this.movesLeft = (moves &lt; 0) ? 0 : moves;</span>
<span class="fc" id="L1060">    }</span>

    /**
     * Gets the type of goods this unit is producing in its current occupation.
     *
     * @return The type of goods this unit is producing.
     */
    public GoodsType getWorkType() {
<span class="fc" id="L1068">        return workType;</span>
    }

    /**
     * Set the type of goods this unit is producing in its current
     * occupation.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void setWorkType(GoodsType type) {
<span class="fc" id="L1078">        this.workType = type;</span>
<span class="fc" id="L1079">    }</span>

    /**
     * Change the type of goods this unit is producing in its current
     * occupation.  Updates the work location production and the unit
     * experience type if necessary.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void changeWorkType(GoodsType type) {
<span class="fc" id="L1089">        setWorkType(type);</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">        if (type != null) experienceType = type;</span>
<span class="fc" id="L1091">        WorkLocation wl = getWorkLocation();</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">        if (wl != null) wl.updateProductionType();</span>
<span class="fc" id="L1093">    }</span>

    /**
     * Gets the type of goods this unit has accrued experience producing.
     *
     * @return The type of goods this unit would produce.
     */
    public GoodsType getExperienceType() {
<span class="fc" id="L1101">        return experienceType;</span>
    }

    /**
     * Gets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @return The experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     *     experienceType.
     * @see #modifyExperience
     */
    public int getExperience() {
<span class="fc" id="L1113">        return experience;</span>
    }

    /**
     * Sets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param experience The new experience of this &lt;code&gt;Unit&lt;/code&gt;
     *     at its current experienceType.
     * @see #modifyExperience
     */
    public void setExperience(int experience) {
<span class="fc" id="L1125">        this.experience = Math.min(experience,</span>
<span class="fc" id="L1126">                                   getType().getMaximumExperience());</span>
<span class="fc" id="L1127">    }</span>

    /**
     * Modifies the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param value The value by which to modify the experience of this
     *     &lt;code&gt;Unit&lt;/code&gt;.
     * @see #getExperience
     */
    public void modifyExperience(int value) {
<span class="fc" id="L1138">        experience += value;</span>
<span class="fc" id="L1139">    }</span>

    /**
     * Gets the amount of work left.
     *
     * @return The amount of work left.
     */
    public int getWorkLeft() {
<span class="fc" id="L1147">        return workLeft;</span>
    }

    /**
     * Sets the amount of work left.
     *
     * @param workLeft The new amount of work left.
     */
    public void setWorkLeft(int workLeft) {
<span class="fc" id="L1156">        this.workLeft = workLeft;</span>
<span class="fc" id="L1157">    }</span>

    /**
     * Get the number of turns of work left.
     *
     * @return The number of turns of work left.
     */
    public int getWorkTurnsLeft() {
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">        return (state == UnitState.IMPROVING</span>
<span class="fc bfc" id="L1166" title="All 2 branches covered.">                &amp;&amp; unitType.hasAbility(Ability.EXPERT_PIONEER))</span>
<span class="fc" id="L1167">            ? (getWorkLeft() + 1) / 2</span>
<span class="fc" id="L1168">            : getWorkLeft();</span>
    }

    /**
     * Gets the TileImprovement that this pioneer is contributing to.
     *
     * @return The &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is working on.
     */
    public TileImprovement getWorkImprovement() {
<span class="fc" id="L1177">        return workImprovement;</span>
    }

    /**
     * Sets the TileImprovement that this pioneer is contributing to.
     *
     * @param imp The new &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is to
     *     work on.
     */
    public void setWorkImprovement(TileImprovement imp) {
<span class="fc" id="L1187">        workImprovement = imp;</span>
<span class="fc" id="L1188">    }</span>

    /**
     * Get the unit being taught.
     *
     * @return A student &lt;code&gt;Unit&lt;/code&gt; if any.
     */
    public final Unit getStudent() {
<span class="fc" id="L1196">        return student;</span>
    }

    /**
     * Set the student unit.
     *
     * @param newStudent The new student &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setStudent(final Unit newStudent) {
<span class="fc" id="L1205">        Unit oldStudent = this.student;</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">        if (oldStudent == newStudent) return;</span>

<span class="fc bfc" id="L1208" title="All 2 branches covered.">        if (newStudent == null) {</span>
<span class="fc" id="L1209">            this.student = null;</span>
<span class="pc bpc" id="L1210" title="1 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="fc" id="L1211">                oldStudent.setTeacher(null);</span>
            }
<span class="pc bpc" id="L1213" title="1 of 2 branches missed.">        } else if (newStudent.getColony() != null</span>
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">            &amp;&amp; newStudent.getColony() == getColony()</span>
<span class="pc bpc" id="L1215" title="1 of 2 branches missed.">            &amp;&amp; newStudent.canBeStudent(this)) {</span>
<span class="pc bpc" id="L1216" title="3 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1217">                oldStudent.setTeacher(null);</span>
            }
<span class="fc" id="L1219">            this.student = newStudent;</span>
<span class="fc" id="L1220">            newStudent.setTeacher(this);</span>
<span class="fc" id="L1221">        } else {</span>
<span class="nc" id="L1222">            throw new IllegalStateException(&quot;Unit can not be student: &quot;</span>
<span class="nc" id="L1223">                + newStudent);</span>
        }
<span class="fc" id="L1225">    }</span>

    /**
     * Get the unit teaching this one.
     *
     * @return A teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final Unit getTeacher() {
<span class="fc" id="L1233">        return teacher;</span>
    }

    /**
     * Set the teacher for this unit.
     *
     * @param newTeacher The new teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setTeacher(final Unit newTeacher) {
<span class="fc" id="L1242">        Unit oldTeacher = this.teacher;</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">        if (newTeacher == oldTeacher) return;</span>

<span class="fc bfc" id="L1245" title="All 2 branches covered.">        if (newTeacher == null) {</span>
<span class="fc" id="L1246">            this.teacher = null;</span>
<span class="pc bpc" id="L1247" title="1 of 4 branches missed.">            if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1248">                oldTeacher.setStudent(null);</span>
            }
<span class="fc" id="L1250">        } else {</span>
<span class="fc" id="L1251">            UnitType skillTaught = newTeacher.getType().getSkillTaught();</span>
<span class="pc bpc" id="L1252" title="1 of 2 branches missed.">            if (newTeacher.getColony() != null</span>
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">                &amp;&amp; newTeacher.getColony() == getColony()</span>
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">                &amp;&amp; getColony().canTrain(skillTaught)) {</span>
<span class="pc bpc" id="L1255" title="1 of 4 branches missed.">                if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1256">                    oldTeacher.setStudent(null);</span>
                }
<span class="fc" id="L1258">                this.teacher = newTeacher;</span>
<span class="fc" id="L1259">                this.teacher.setStudent(this);</span>
<span class="fc" id="L1260">            } else {</span>
<span class="nc" id="L1261">                throw new IllegalStateException(&quot;Unit can not be teacher: &quot;</span>
<span class="nc" id="L1262">                    + newTeacher);</span>
            }
        }
<span class="fc" id="L1265">    }</span>

    /**
     * Gets the number of turns this unit has been training.
     *
     * @return The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has
     *     given.
     * @see #setTurnsOfTraining
     * @see #getNeededTurnsOfTraining
     */
    public int getTurnsOfTraining() {
<span class="fc" id="L1276">        return turnsOfTraining;</span>
    }

    /**
     * Sets the number of turns this unit has been training.
     *
     * @param turnsOfTraining The number of turns of training this
     *     &lt;code&gt;Unit&lt;/code&gt; has given.
     * @see #getNeededTurnsOfTraining
     */
    public void setTurnsOfTraining(int turnsOfTraining) {
<span class="fc" id="L1287">        this.turnsOfTraining = turnsOfTraining;</span>
<span class="fc" id="L1288">    }</span>

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining() {
        // number of turns is 4/6/8 for skill 1/2/3
<span class="fc" id="L1301">        int result = 0;</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="fc" id="L1303">            result = getNeededTurnsOfTraining(unitType, student.unitType);</span>
<span class="pc bpc" id="L1304" title="1 of 2 branches missed.">            if (getColony() != null) {</span>
<span class="fc" id="L1305">                result -= getColony().getProductionBonus();</span>
            }
        }
<span class="fc" id="L1308">        return result;</span>
    }

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent the student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining(UnitType typeTeacher,
                                        UnitType typeStudent) {
<span class="fc" id="L1324">        UnitType teaching = getUnitTypeTeaching(typeTeacher, typeStudent);</span>
<span class="pc bpc" id="L1325" title="1 of 2 branches missed.">        if (teaching != null) {</span>
<span class="fc" id="L1326">            return typeStudent.getEducationTurns(teaching);</span>
        } else {
<span class="nc" id="L1328">            throw new IllegalStateException(&quot;typeTeacher=&quot; + typeTeacher</span>
<span class="nc" id="L1329">                + &quot; typeStudent=&quot; + typeStudent);</span>
        }
    }

    /**
     * Gets the UnitType which a teacher is teaching to a student.
     * This value is only meaningful for teachers that can be put in a
     * school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The &lt;code&gt;UnitType&lt;/code&gt; taught.
     * @see #getTurnsOfTraining
     *
     */
    public static UnitType getUnitTypeTeaching(UnitType typeTeacher,
                                               UnitType typeStudent) {
<span class="fc" id="L1346">        UnitType skillTaught = typeTeacher.getSkillTaught();</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        if (typeStudent.canBeUpgraded(skillTaught, ChangeType.EDUCATION)) {</span>
<span class="fc" id="L1348">            return skillTaught;</span>
        } else {
<span class="fc" id="L1350">            return typeStudent.getEducationUnit(0);</span>
        }
    }

    /**
     * Can this unit be a student?
     *
     * @param teacher The teacher &lt;code&gt;Unit&lt;/code&gt; which is trying to
     *     teach it.
     * @return True if the unit can be taught by the teacher.
     */
    public boolean canBeStudent(Unit teacher) {
<span class="fc bfc" id="L1362" title="All 4 branches covered.">        return teacher != this &amp;&amp; canBeStudent(unitType, teacher.unitType);</span>
    }

    /**
     * Can a unit be a student?
     *
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @return True if the student can be taught by the teacher.
     */
    public boolean canBeStudent(UnitType typeStudent, UnitType typeTeacher) {
<span class="fc bfc" id="L1373" title="All 2 branches covered.">        return getUnitTypeTeaching(typeTeacher, typeStudent) != null;</span>
    }

    /**
     * Gets the nationality of this Unit.
     *
     * Nationality represents a Unit's personal allegiance to a
     * nation.  This may conflict with who currently issues orders to
     * the Unit (the owner).
     *
     * @return The nationality of this Unit.
     */
    public String getNationality() {
<span class="nc" id="L1386">        return nationality;</span>
    }

    /**
     * Sets the nationality of this Unit.  A unit will change
     * nationality when it switches owners willingly.  Currently only
     * Converts do this, but it opens the possibility of
     * naturalisation.
     *
     * @param newNationality The new nationality of this Unit.
     */
    public void setNationality(String newNationality) {
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (isPerson()) {</span>
<span class="nc" id="L1399">            nationality = newNationality;</span>
<span class="nc" id="L1400">        } else {</span>
<span class="nc" id="L1401">            throw new UnsupportedOperationException(&quot;Can not set the nationality of a Unit which is not a person!&quot;);</span>
        }
<span class="nc" id="L1403">    }</span>

    /**
     * Gets the ethnicity of this Unit.
     *
     * Ethnicity is inherited from the inhabitants of the place where
     * the Unit was born.  Allows former converts to become
     * native-looking colonists.
     *
     * @return The ethnicity of this Unit.
     */
    public String getEthnicity() {
<span class="nc" id="L1415">        return ethnicity;</span>
    }

    /**
     * Sets the ethnicity of this Unit.
     *
     * @param newEthnicity The new ethnicity of this Unit.
     */
    public void setEthnicity(String newEthnicity) {
<span class="nc" id="L1424">        this.ethnicity = newEthnicity;</span>
<span class="nc" id="L1425">    }</span>

    /**
     * Identifies whether this unit came from a native tribe.
     *
     * @return Whether this unit looks native or not.
     */
    public boolean hasNativeEthnicity() {
        try {
            // FIXME: getNation() could fail, but getNationType()
            // doesn't work as expected
<span class="nc" id="L1436">            return getGame().getSpecification().getNation(ethnicity)</span>
<span class="nc" id="L1437">                .getType().isIndian();</span>
<span class="nc" id="L1438">        } catch (Exception e) {</span>
<span class="nc" id="L1439">            return false;</span>
        }
    }

    /**
     * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; home for this unit.
     *
     * @return The home &lt;code&gt;IndianSettlement&lt;/code&gt; of this unit.
     */
    public IndianSettlement getHomeIndianSettlement() {
<span class="fc" id="L1449">        return indianSettlement;</span>
    }

    /**
     * Sets the home &lt;code&gt;IndianSettlement&lt;/code&gt; for this unit.
     *
     * @param indianSettlement The &lt;code&gt;IndianSettlement&lt;/code&gt; that should
     *     now own this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public void setHomeIndianSettlement(IndianSettlement indianSettlement) {
<span class="fc bfc" id="L1459" title="All 2 branches covered.">        if (this.indianSettlement != null) {</span>
<span class="fc" id="L1460">            this.indianSettlement.removeOwnedUnit(this);</span>
        }

<span class="fc" id="L1463">        this.indianSettlement = indianSettlement;</span>

<span class="fc bfc" id="L1465" title="All 2 branches covered.">        if (indianSettlement != null) {</span>
<span class="fc" id="L1466">            indianSettlement.addOwnedUnit(this);</span>
        }
<span class="fc" id="L1468">    }</span>

    /**
     * Gets the unit hit points.
     *
     * This is currently only used for damaged ships, but might get an
     * extended use later.
     *
     * @return The hit points this &lt;code&gt;Unit&lt;/code&gt; has.
     * @see UnitType#getHitPoints
     */
    public int getHitPoints() {
<span class="nc" id="L1480">        return hitPoints;</span>
    }

    /**
     * Sets the hit points for this unit.
     *
     * @param hitPoints The new hit points for this unit.
     */
    public void setHitPoints(int hitPoints) {
<span class="fc" id="L1489">        this.hitPoints = hitPoints;</span>
<span class="fc" id="L1490">    }</span>

    /**
     * Checks if this unit is under repair.
     *
     * @return True if under repair.
     */
    public boolean isDamaged() {
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        return hitPoints &lt; unitType.getHitPoints();</span>
    }

    /**
     * Get how many turns left to be repaired
     *
     * @return The number of turns left to be repaired.
     */
    public int getTurnsForRepair() {
<span class="nc" id="L1507">        return unitType.getHitPoints() - getHitPoints();</span>
    }

    /**
     * Get the destination of this unit.
     *
     * @return The destination &lt;code&gt;Location&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Location getDestination() {
<span class="fc" id="L1516">        return destination;</span>
    }

    /**
     * Sets the destination of this unit.
     *
     * @param newDestination The new destination &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setDestination(Location newDestination) {
<span class="fc" id="L1525">        this.destination = newDestination;</span>
<span class="fc" id="L1526">    }</span>

    /**
     * Get the unit trade route, if any.
     *
     * @return The &lt;code&gt;TradeRoute&lt;/code&gt;, or null if none.
     */
    public final TradeRoute getTradeRoute() {
<span class="fc" id="L1534">        return tradeRoute;</span>
    }

    /**
     * Set the unit trade route.
     *
     * @param newTradeRoute The new &lt;code&gt;TradeRoute&lt;/code&gt; value.
     */
    public final void setTradeRoute(final TradeRoute newTradeRoute) {
<span class="fc" id="L1543">        this.tradeRoute = newTradeRoute;</span>
<span class="fc" id="L1544">    }</span>

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public TradeRouteStop getStop() {
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        return (validateCurrentStop() &lt; 0) ? null</span>
<span class="nc" id="L1553">            : getTradeRoute().getStops().get(currentStop);</span>
    }

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public List&lt;TradeRouteStop&gt; getCurrentStops() {
<span class="nc bnc" id="L1562" title="All 2 branches missed.">        if (validateCurrentStop() &lt; 0) return null;</span>
<span class="nc" id="L1563">        List&lt;TradeRouteStop&gt; stops</span>
<span class="nc" id="L1564">            = new ArrayList&lt;TradeRouteStop&gt;(getTradeRoute().getStops());</span>
<span class="nc" id="L1565">        rotate(stops, currentStop);</span>
<span class="nc" id="L1566">        return stops;</span>
    }

    /**
     * Get the current trade route stop.
     *
     * @return The current stop index.
     */
    public int getCurrentStop() {
<span class="nc" id="L1575">        return currentStop;</span>
    }

    /**
     * Set the current stop.
     *
     * @param currentStop A new value for the currentStop.
     */
    public void setCurrentStop(int currentStop) {
<span class="nc" id="L1584">        this.currentStop = currentStop;</span>
<span class="nc" id="L1585">    }</span>

    /**
     * Validate and return the current stop.
     *
     * @return The current stop index, or negative on failure.
     */
    public int validateCurrentStop() {
<span class="nc bnc" id="L1593" title="All 2 branches missed.">        if (tradeRoute == null) {</span>
<span class="nc" id="L1594">            currentStop = -1;</span>
<span class="nc" id="L1595">        } else {</span>
<span class="nc" id="L1596">            List&lt;TradeRouteStop&gt; stops = tradeRoute.getStops();</span>
<span class="nc bnc" id="L1597" title="All 4 branches missed.">            if (stops == null || stops.isEmpty()) {</span>
<span class="nc" id="L1598">                currentStop = -1;</span>
<span class="nc" id="L1599">            } else {</span>
<span class="nc bnc" id="L1600" title="All 4 branches missed.">                if (currentStop &lt; 0 || currentStop &gt;= stops.size()) {</span>
                    // The current stop can become out of range if the trade
                    // route is modified.
<span class="nc" id="L1603">                    currentStop = 0;</span>
                }
            }
        }
<span class="nc" id="L1607">        return currentStop;</span>
    }

    /**
     * Convenience function to check if a unit is at a stop.
     *
     * @param stop The &lt;code&gt;TradeRouteStop&lt;/code&gt; to check.
     * @return True if the unit is at the given stop.
     */
    public boolean atStop(TradeRouteStop stop) {
<span class="nc" id="L1617">        return Map.isSameLocation(getLocation(), stop.getLocation());</span>
    }

    /**
     * Get the current trade location.
     *
     * @return The &lt;code&gt;TradeLocation&lt;/code&gt; for this unit.
     */
    public TradeLocation getTradeLocation() {
        Colony colony;
        IndianSettlement is;
<span class="nc bnc" id="L1628" title="All 2 branches missed.">        return ((colony = getColony()) != null) ? colony</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            : ((is = getIndianSettlement()) != null) ? is</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">            : (isInEurope()) ? (TradeLocation)getOwner().getEurope()</span>
<span class="nc" id="L1631">            : null;</span>
    }

    /**
     * Get the current amount of treasure in this unit.
     *
     * @return The amount of treasure.
     * @exception IllegalStateException if this is not a treasure
     *     carrying unit.
     */
    public int getTreasureAmount() {
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1643">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1645">        return treasureAmount;</span>
    }

    /**
     * Set the amount of treasure in this unit.
     *
     * @param amount The new amount of treasure.
     */
    public void setTreasureAmount(int amount) {
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1655">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1657">        this.treasureAmount = amount;</span>
<span class="fc" id="L1658">    }</span>

    /**
     * Gets the attrition of this unit.
     *
     * @return The attrition of this unit.
     */
    public int getAttrition() {
<span class="fc" id="L1666">        return attrition;</span>
    }

    /**
     * Sets the attrition of this unit.
     *
     * @param attrition The new attrition of this unit.
     */
    public void setAttrition(int attrition) {
<span class="fc" id="L1675">        this.attrition = attrition;</span>
<span class="fc" id="L1676">    }</span>

    /**
     * Get the visible amount of goods that is carried by this unit.
     *
     * @return The visible amount of goods carried by this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getVisibleGoodsCount() {
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">        return (visibleGoodsCount &gt;= 0) ? visibleGoodsCount</span>
<span class="fc" id="L1685">            : getGoodsSpaceTaken();</span>
    }


    // Combat routines

    /**
     * Gets a role that can be equipped automatically assumed
     * in case of an attack.
     *
     * Paul Revere makes an unarmed colonist in a settlement pick up a
     * stock-piled musket if attacked, so the bonus should be applied
     * for unarmed colonists inside colonies where there are muskets
     * available.  Natives can also auto-arm.
     *
     * @return A &lt;code&gt;Role&lt;/code&gt; that can be automatically assumed
     *     by this unit, or null if none.
     */
    public Role getAutomaticRole() {
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        if (!hasDefaultRole()) return null;</span>
<span class="fc" id="L1705">        Set&lt;Ability&gt; autoDefence = getAbilities(Ability.AUTOMATIC_EQUIPMENT);</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">        if (autoDefence.isEmpty()) return null;</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">        Settlement settlement = (isInColony()) ? getColony()</span>
<span class="fc bfc" id="L1708" title="All 2 branches covered.">            : (getLocation() instanceof IndianSettlement)</span>
<span class="fc" id="L1709">            ? (Settlement)getLocation()</span>
<span class="fc" id="L1710">            : null;</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">        if (settlement == null) return null;</span>

<span class="fc" id="L1713">        final Specification spec = getSpecification();</span>
<span class="fc bfc" id="L1714" title="All 2 branches covered.">        for (Ability ability : autoDefence) {</span>
<span class="fc bfc" id="L1715" title="All 2 branches covered.">            for (Scope scope : ability.getScopes()) {</span>
<span class="fc" id="L1716">                Role role = spec.getRole(scope.getType());</span>
<span class="pc bpc" id="L1717" title="1 of 2 branches missed.">                if (role != null</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">                    &amp;&amp; settlement.containsGoods(getGoodsDifference(role, 1))) {</span>
<span class="fc" id="L1719">                    return role;</span>
                }
            }
        }
<span class="fc" id="L1723">        return null;</span>
    }

    /**
     * After winning a battle, can this unit capture the loser's role
     * equipment?
     *
     * @param role The loser unit &lt;code&gt;Role&lt;/code&gt;.
     * @return The &lt;code&gt;Role&lt;/code&gt; available to this unit as a result
     *     of capturing the loser equipment.
     */
    public Role canCaptureEquipment(Role role) {
<span class="fc bfc" id="L1735" title="All 2 branches covered.">        if (!hasAbility(Ability.CAPTURE_EQUIPMENT)) return null;</span>
<span class="fc" id="L1736">        final Specification spec = getSpecification();</span>
<span class="fc" id="L1737">        final Role oldRole = getRole();</span>
<span class="fc bfc" id="L1738" title="All 2 branches covered.">        for (Role r : getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="fc bfc" id="L1739" title="All 2 branches covered.">            for (Role.RoleChange rc : r.getRoleChanges()) {</span>
<span class="fc bfc" id="L1740" title="All 2 branches covered.">                if (rc.getFrom(spec) == oldRole</span>
<span class="fc bfc" id="L1741" title="All 2 branches covered.">                    &amp;&amp; rc.getCapture(spec) == role) return r;</span>
            }
        }
<span class="fc" id="L1744">        return null;</span>
    }

    /**
     * Does losing a piece of equipment mean the death of this unit?
     *
     * @return True if the unit is doomed.
     */
    public boolean losingEquipmentKillsUnit() {
<span class="pc bfc" id="L1753" title="All 2 branches covered.">        return hasAbility(Ability.DISPOSE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does losing equipment mean the demotion of this unit?
     *
     * @return True if the unit is to be demoted.
     */
    public boolean losingEquipmentDemotesUnit() {
<span class="fc bfc" id="L1763" title="All 2 branches covered.">        return hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="fc bfc" id="L1764" title="All 2 branches covered.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does the unit have arms?
     *
     * @return True if the unit has arms.
     */
    public boolean isArmed() {
<span class="fc" id="L1773">        return hasAbility(Ability.ARMED);</span>
    }

    /**
     * Does the unit have a mount?
     *
     * @return True if the unit have a mount.
     */
    public boolean isMounted() {
<span class="fc" id="L1782">        return hasAbility(Ability.MOUNTED);</span>
    }

    /**
     * Is the unit a beached ship?
     *
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached() {
<span class="fc" id="L1791">        return isBeached(getTile());</span>
    }

    /**
     * Would this unit be beached if it was on a particular tile?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached(Tile tile) {
<span class="pc bpc" id="L1801" title="1 of 6 branches missed.">        return isNaval() &amp;&amp; tile != null &amp;&amp; tile.isLand()</span>
<span class="pc bpc" id="L1802" title="1 of 2 branches missed.">            &amp;&amp; !tile.hasSettlement();</span>
    }

    /**
     * Checks if this is an defensive unit. That is: a unit which can
     * be used to defend a &lt;code&gt;Settlement&lt;/code&gt;.
     *
     * Note! As this method is used by the AI it really means that the
     * unit can defend as is. To be specific an unarmed colonist is
     * not defensive yet, even if Paul Revere and stockpiled muskets
     * are available. That check is only performed on an actual
     * attack.
     *
     * A settlement is lost when there are no more defensive units.
     *
     * @return True if this is a defensive unit meaning it can be used
     *     to defend a &lt;code&gt;Colony&lt;/code&gt;.  This would normally mean
     *     that a defensive unit also will be offensive.
     */
    public boolean isDefensiveUnit() {
<span class="pc bpc" id="L1822" title="1 of 4 branches missed.">        return (unitType.isDefensive() || getRole().isDefensive())</span>
<span class="pc bpc" id="L1823" title="1 of 2 branches missed.">            &amp;&amp; !isCarrier(); // Not wagons or ships</span>
    }

    /**
     * Checks if this is an offensive unit.  That is, one that can
     * attack other units.
     *
     * @return True if this is an offensive unit.
     */
    public boolean isOffensiveUnit() {
<span class="fc bfc" id="L1833" title="All 4 branches covered.">        return unitType.isOffensive() || getRole().isOffensive();</span>
    }

    /**
     * Is an alternate unit a better defender than the current choice.
     * Prefer if there is no current defender, or if the alternate
     * unit is better armed, or provides greater defensive power and
     * does not replace a defensive unit defender with a non-defensive
     * unit.
     *
     * @param defender The current defender &lt;code&gt;Unit&lt;/code&gt;.
     * @param defenderPower Its defence power.
     * @param other An alternate &lt;code&gt;Unit&lt;/code&gt;.
     * @param otherPower Its defence power.
     * @return True if the other unit should be preferred.
     */
    public static boolean betterDefender(Unit defender, double defenderPower,
                                         Unit other, double otherPower) {
<span class="fc bfc" id="L1851" title="All 2 branches covered.">        if (defender == null) {</span>
<span class="fc" id="L1852">            return true;</span>
<span class="pc bpc" id="L1853" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1854" title="1 of 4 branches missed.">            &amp;&amp; !defender.isArmed() &amp;&amp; other.isArmed()) {</span>
<span class="nc" id="L1855">            return true;</span>
<span class="pc bpc" id="L1856" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1857" title="1 of 4 branches missed.">            &amp;&amp; defender.isArmed() &amp;&amp; !other.isArmed()) {</span>
<span class="nc" id="L1858">            return false;</span>
<span class="pc bpc" id="L1859" title="1 of 4 branches missed.">        } else if (!defender.isDefensiveUnit() &amp;&amp; other.isDefensiveUnit()) {</span>
<span class="nc" id="L1860">            return true;</span>
<span class="pc bpc" id="L1861" title="1 of 4 branches missed.">        } else if (defender.isDefensiveUnit() &amp;&amp; !other.isDefensiveUnit()) {</span>
<span class="nc" id="L1862">            return false;</span>
        } else {
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">            return defenderPower &lt; otherPower;</span>
        }
    }

    /**
     * Finds the closest &lt;code&gt;Location&lt;/code&gt; to this tile where
     * this ship can be repaired, excluding the current colony.
     *
     * @return The closest &lt;code&gt;Location&lt;/code&gt; where a ship can be
     *     repaired.
     */
    public Location getRepairLocation() {
<span class="fc" id="L1876">        final Player player = getOwner();</span>
<span class="fc" id="L1877">        final Colony notHere = getTile().getColony();</span>
<span class="fc" id="L1878">        Location best = getClosestColony(player.getColonies().stream()</span>
<span class="pc bpc" id="L1879" title="3 of 4 branches missed.">            .filter(c -&gt; c != notHere &amp;&amp; c.hasAbility(Ability.REPAIR_UNITS)));</span>
<span class="pc bpc" id="L1880" title="1 of 2 branches missed.">        return (best != null) ? best : player.getEurope();</span>
    }


    // Movement handling

    /**
     * A move type.
     *
     * @see Unit#getMoveType(Direction)
     */
<span class="fc" id="L1891">    public static enum MoveType {</span>
<span class="fc" id="L1892">        MOVE(null, true),</span>
<span class="fc" id="L1893">        MOVE_HIGH_SEAS(null, true),</span>
<span class="fc" id="L1894">        EXPLORE_LOST_CITY_RUMOUR(null, true),</span>
<span class="fc" id="L1895">        ATTACK_UNIT(null, false),</span>
<span class="fc" id="L1896">        ATTACK_SETTLEMENT(null, false),</span>
<span class="fc" id="L1897">        EMBARK(null, false),</span>
<span class="fc" id="L1898">        ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST(null, false),</span>
<span class="fc" id="L1899">        ENTER_INDIAN_SETTLEMENT_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1900">        ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY(null, false),</span>
<span class="fc" id="L1901">        ENTER_FOREIGN_COLONY_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1902">        ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS(null, false),</span>
<span class="fc" id="L1903">        MOVE_NO_MOVES(&quot;Attempt to move without moves left&quot;),</span>
<span class="fc" id="L1904">        MOVE_NO_ACCESS_LAND(&quot;Attempt to move a naval unit onto land&quot;),</span>
<span class="fc" id="L1905">        MOVE_NO_ACCESS_BEACHED(&quot;Attempt to move onto foreign beached ship&quot;),</span>
<span class="fc" id="L1906">        MOVE_NO_ACCESS_EMBARK(&quot;Attempt to embark onto absent or foreign carrier&quot;),</span>
<span class="fc" id="L1907">        MOVE_NO_ACCESS_FULL(&quot;Attempt to embark onto full carrier&quot;),</span>
<span class="fc" id="L1908">        MOVE_NO_ACCESS_GOODS(&quot;Attempt to trade without goods&quot;),</span>
<span class="fc" id="L1909">        MOVE_NO_ACCESS_CONTACT(&quot;Attempt to interact with natives before contact&quot;),</span>
<span class="fc" id="L1910">        MOVE_NO_ACCESS_MISSION_BAN(&quot;Attempt to use missionary at banned settlement&quot;),</span>
<span class="fc" id="L1911">        MOVE_NO_ACCESS_SETTLEMENT(&quot;Attempt to move into foreign settlement&quot;),</span>
<span class="fc" id="L1912">        MOVE_NO_ACCESS_SKILL(&quot;Attempt to learn skill with incapable unit&quot;),</span>
<span class="fc" id="L1913">        MOVE_NO_ACCESS_TRADE(&quot;Attempt to trade without authority&quot;),</span>
<span class="fc" id="L1914">        MOVE_NO_ACCESS_WAR(&quot;Attempt to trade while at war&quot;),</span>
<span class="fc" id="L1915">        MOVE_NO_ACCESS_WATER(&quot;Attempt to move into a settlement by water&quot;),</span>
<span class="fc" id="L1916">        MOVE_NO_ATTACK_CIVILIAN(&quot;Attempt to attack with civilian unit&quot;),</span>
<span class="fc" id="L1917">        MOVE_NO_ATTACK_MARINE(&quot;Attempt to attack from on board ship&quot;),</span>
<span class="fc" id="L1918">        MOVE_NO_EUROPE(&quot;Attempt to move to Europe by incapable unit&quot;),</span>
<span class="fc" id="L1919">        MOVE_NO_REPAIR(&quot;Attempt to move a unit that is under repair&quot;),</span>
<span class="fc" id="L1920">        MOVE_NO_TILE(&quot;Attempt to move when not on a tile&quot;),</span>
<span class="fc" id="L1921">        MOVE_ILLEGAL(&quot;Unspecified illegal move&quot;);</span>

        /**
         * The reason why this move type is illegal.
         */
        private final String reason;

        /**
         * Does this move type imply progress towards a destination.
         */
        private final boolean progress;

<span class="fc" id="L1933">        MoveType(String reason) {</span>
<span class="fc" id="L1934">            this.reason = reason;</span>
<span class="fc" id="L1935">            this.progress = false;</span>
<span class="fc" id="L1936">        }</span>

<span class="fc" id="L1938">        MoveType(String reason, boolean progress) {</span>
<span class="fc" id="L1939">            this.reason = reason;</span>
<span class="fc" id="L1940">            this.progress = progress;</span>
<span class="fc" id="L1941">        }</span>

        public boolean isLegal() {
<span class="fc bfc" id="L1944" title="All 2 branches covered.">            return this.reason == null;</span>
        }

        public String whyIllegal() {
<span class="nc bnc" id="L1948" title="All 2 branches missed.">            return (reason == null) ? &quot;(none)&quot; : reason;</span>
        }

        public boolean isProgress() {
<span class="fc" id="L1952">            return progress;</span>
        }

        public boolean isAttack() {
<span class="nc bnc" id="L1956" title="All 4 branches missed.">            return this == ATTACK_UNIT || this == ATTACK_SETTLEMENT;</span>
        }
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; onto the given
     * &lt;code&gt;Tile&lt;/code&gt;. A call to {@link #getMoveType(Tile)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            onto.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile target) {
<span class="fc" id="L1971">        return getMoveCost(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; from the given
     * &lt;code&gt;Tile&lt;/code&gt; onto the given &lt;code&gt;Tile&lt;/code&gt;. A call to
     * {@link #getMoveType(Tile, Tile, int)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will
     *     move from.
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will
     *     move onto.
     * @param ml The amount of moves this Unit has left.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile from, Tile target, int ml) {
        // Remember to also change map.findPath(...) if you change anything
        // here.

<span class="fc" id="L1992">        int cost = target.getType().getBasicMoveCost();</span>
<span class="fc bfc" id="L1993" title="All 4 branches covered.">        if (target.isLand() &amp;&amp; !isNaval()) {</span>
<span class="fc" id="L1994">            TileItemContainer container = target.getTileItemContainer();</span>
<span class="fc bfc" id="L1995" title="All 2 branches covered.">            if (container != null) {</span>
<span class="fc" id="L1996">                cost = container.getMoveCost(from, target, cost);</span>
            }
        }

<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">        if (isBeached(from)) {</span>
            // Ship on land due to it was in a colony which was abandoned
<span class="nc" id="L2002">            cost = ml;</span>
<span class="pc bfc" id="L2003" title="All 2 branches covered.">        } else if (cost &gt; ml) {</span>
            // Using +2 in order to make 1/3 and 2/3 move count as
            // 3/3, only when getMovesLeft &gt; 0
<span class="pc bpc" id="L2006" title="1 of 4 branches missed.">            if ((ml + 2 &gt;= getInitialMovesLeft() || cost &lt;= ml + 2</span>
<span class="fc bfc" id="L2007" title="All 4 branches covered.">                 || target.hasSettlement()) &amp;&amp; ml != 0) {</span>
<span class="fc" id="L2008">                cost = ml;</span>
            }
        }
<span class="fc" id="L2011">        return cost;</span>
    }

    /**
     * Gets the type of a move made in a specified direction.
     *
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Direction direction) {
        Tile target;
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2023">            ? MoveType.MOVE_NO_TILE</span>
<span class="pc bpc" id="L2024" title="1 of 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
<span class="nc" id="L2025">            ? MoveType.MOVE_ILLEGAL</span>
<span class="fc" id="L2026">            : getMoveType(target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Tile target) {
<span class="pc bpc" id="L2037" title="1 of 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2038">            ? MoveType.MOVE_NO_TILE</span>
<span class="fc" id="L2039">            : getMoveType(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param ml The amount of moves this unit has left.
     * @return The move type.
     */
    public MoveType getMoveType(Tile from, Tile target, int ml) {
<span class="fc" id="L2052">        MoveType move = getSimpleMoveType(from, target);</span>
<span class="fc bfc" id="L2053" title="All 2 branches covered.">        if (move.isLegal()) {</span>
<span class="fc bfc" id="L2054" title="All 2 branches covered.">            switch (move) {</span>
            case ATTACK_UNIT: case ATTACK_SETTLEMENT:
                // Needs only a single movement point, regardless of
                // terrain, but suffers penalty.
<span class="fc bfc" id="L2058" title="All 2 branches covered.">                if (ml &lt;= 0) {</span>
<span class="fc" id="L2059">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
<span class="fc" id="L2061">                break;</span>
            default:
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">                if (ml &lt;= 0</span>
<span class="pc bpc" id="L2064" title="2 of 4 branches missed.">                    || (from != null &amp;&amp; getMoveCost(from, target, ml) &gt; ml)) {</span>
<span class="nc" id="L2065">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
                break;
            }
        }
<span class="fc" id="L2070">        return move;</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile from, Tile target) {
<span class="fc bfc" id="L2084" title="All 2 branches covered.">        return (isNaval()) ? getNavalMoveType(from, target)</span>
<span class="fc" id="L2085">            : getLandMoveType(from, target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile target) {
<span class="nc bnc" id="L2098" title="All 2 branches missed.">        return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc" id="L2099">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move made in a specified direction,
     * without checking if the unit has moves left or logging errors.
     *
     * @param direction The direction of the move.
     * @return The move type.
     */
    public MoveType getSimpleMoveType(Direction direction) {
        Tile target;
<span class="nc bnc" id="L2111" title="All 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2112">            ? MoveType.MOVE_NO_TILE</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
<span class="nc" id="L2114">            ? MoveType.MOVE_ILLEGAL</span>
<span class="nc" id="L2115">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move that is made when moving a naval unit
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getNavalMoveType(@SuppressWarnings(&quot;unused&quot;) Tile from,
                                      Tile target) {
<span class="pc bpc" id="L2128" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">            return (getOwner().canMoveToEurope()) ? MoveType.MOVE_HIGH_SEAS</span>
<span class="nc" id="L2130">                : MoveType.MOVE_NO_EUROPE;</span>
<span class="pc bpc" id="L2131" title="1 of 2 branches missed.">        } else if (isDamaged()) {</span>
<span class="nc" id="L2132">            return MoveType.MOVE_NO_REPAIR;</span>
        }

<span class="fc bfc" id="L2135" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2136">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2137" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc" id="L2138">                return MoveType.MOVE_NO_ACCESS_LAND;</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">            } else if (settlement.getOwner() == getOwner()) {</span>
<span class="fc" id="L2140">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2141" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="fc" id="L2142">                return getTradeMoveType(settlement);</span>
            } else {
<span class="nc" id="L2144">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // target at sea
<span class="fc" id="L2147">            Unit defender = target.getFirstUnit();</span>
<span class="fc bfc" id="L2148" title="All 4 branches covered.">            if (defender != null &amp;&amp; !getOwner().owns(defender)) {</span>
<span class="fc bfc" id="L2149" title="All 2 branches covered.">                return (isOffensiveUnit())</span>
<span class="fc" id="L2150">                    ? MoveType.ATTACK_UNIT</span>
<span class="fc" id="L2151">                    : MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
            } else {
<span class="fc bfc" id="L2153" title="All 2 branches covered.">                return (target.isDirectlyHighSeasConnected())</span>
<span class="fc" id="L2154">                    ? MoveType.MOVE_HIGH_SEAS</span>
<span class="fc" id="L2155">                    : MoveType.MOVE;</span>
            }
        }
    }

    /**
     * Gets the type of a move that is made when moving a land unit to
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getLandMoveType(Tile from, Tile target) {
<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">        if (target == null) return MoveType.MOVE_ILLEGAL;</span>

<span class="fc" id="L2171">        Player owner = getOwner();</span>
<span class="fc" id="L2172">        Unit defender = target.getFirstUnit();</span>

<span class="fc bfc" id="L2174" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2175">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2176" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc bfc" id="L2177" title="All 4 branches covered.">                if (defender != null &amp;&amp; owner != defender.getOwner()) {</span>
<span class="pc bpc" id="L2178" title="1 of 2 branches missed.">                    if (defender.isNaval()) {</span>
<span class="nc" id="L2179">                        return MoveType.ATTACK_UNIT;</span>
<span class="fc bfc" id="L2180" title="All 2 branches covered.">                    } else if (!isOffensiveUnit()) {</span>
<span class="fc" id="L2181">                        return MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
                    } else {
<span class="pc bpc" id="L2183" title="1 of 2 branches missed.">                        return (allowMoveFrom(from))</span>
<span class="fc" id="L2184">                            ? MoveType.ATTACK_UNIT</span>
<span class="nc" id="L2185">                            : MoveType.MOVE_NO_ATTACK_MARINE;</span>
                    }
<span class="pc bpc" id="L2187" title="1 of 4 branches missed.">                } else if (target.hasLostCityRumour() &amp;&amp; owner.isEuropean()) {</span>
                    // Natives do not explore rumours, see:
                    // server/control/InGameInputHandler.java:move()
<span class="fc" id="L2190">                    return MoveType.EXPLORE_LOST_CITY_RUMOUR;</span>
                } else {
<span class="fc" id="L2192">                    return MoveType.MOVE;</span>
                }
<span class="fc bfc" id="L2194" title="All 2 branches covered.">            } else if (owner == settlement.getOwner()) {</span>
<span class="fc" id="L2195">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="nc" id="L2197">                return getTradeMoveType(settlement);</span>
<span class="fc bfc" id="L2198" title="All 2 branches covered.">            } else if (isColonist()) {</span>
<span class="fc bfc" id="L2199" title="All 2 branches covered.">                if (settlement instanceof Colony</span>
<span class="fc bfc" id="L2200" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.NEGOTIATE)) {</span>
<span class="pc bpc" id="L2201" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2202">                        ? MoveType.ENTER_FOREIGN_COLONY_WITH_SCOUT</span>
<span class="nc" id="L2203">                        : MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="fc bfc" id="L2204" title="All 2 branches covered.">                } else if (settlement instanceof IndianSettlement</span>
<span class="fc bfc" id="L2205" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.SPEAK_WITH_CHIEF)) {</span>
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2207">                        ? MoveType.ENTER_INDIAN_SETTLEMENT_WITH_SCOUT</span>
<span class="nc" id="L2208">                        : MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">                } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2210" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2211">                        ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2212">                        : MoveType.MOVE_NO_ATTACK_MARINE;</span>
<span class="fc bfc" id="L2213" title="All 2 branches covered.">                } else if (hasAbility(Ability.ESTABLISH_MISSION)) {</span>
<span class="fc" id="L2214">                    return getMissionaryMoveType(from, settlement);</span>
                } else {
<span class="fc" id="L2216">                    return getLearnMoveType(from, settlement);</span>
                }
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">            } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2219" title="1 of 2 branches missed.">                return (allowMoveFrom(from))</span>
<span class="fc" id="L2220">                    ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2221">                    : MoveType.MOVE_NO_ATTACK_MARINE;</span>
            } else {
<span class="nc" id="L2223">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // moving to sea, check for embarkation
<span class="fc bfc" id="L2226" title="All 4 branches covered.">            return (defender == null || !getOwner().owns(defender))</span>
<span class="fc" id="L2227">                ? MoveType.MOVE_NO_ACCESS_EMBARK</span>
<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">                : (any(target.getUnitList(), u -&gt; u.canAdd(this)))</span>
<span class="fc" id="L2229">                ? MoveType.EMBARK</span>
<span class="nc" id="L2230">                : MoveType.MOVE_NO_ACCESS_FULL;</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a trading unit to a
     * settlement.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getTradeMoveType(Settlement settlement) {
<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">        if (settlement instanceof Colony) {</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">            return (getOwner().atWarWith(settlement.getOwner()))</span>
<span class="nc" id="L2244">                ? MoveType.MOVE_NO_ACCESS_WAR</span>
<span class="nc bnc" id="L2245" title="All 2 branches missed.">                : (!hasAbility(Ability.TRADE_WITH_FOREIGN_COLONIES))</span>
<span class="nc" id="L2246">                ? MoveType.MOVE_NO_ACCESS_TRADE</span>
<span class="nc" id="L2247">                : MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS;</span>
<span class="pc bpc" id="L2248" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
            // Do not block for war, bringing gifts is allowed
<span class="fc bfc" id="L2250" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
<span class="fc" id="L2251">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="fc bfc" id="L2252" title="All 2 branches covered.">                : (hasGoodsCargo() || getSpecification()</span>
<span class="fc bfc" id="L2253" title="All 2 branches covered.">                    .getBoolean(GameOptions.EMPTY_TRADERS))</span>
<span class="fc" id="L2254">                ? MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS</span>
<span class="fc" id="L2255">                : MoveType.MOVE_NO_ACCESS_GOODS;</span>
        } else {
<span class="nc" id="L2257">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a colonist to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getLearnMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2269" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2270">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2271" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
<span class="fc" id="L2273">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2274" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
<span class="nc" id="L2275">                ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">                : (!getType().canBeUpgraded(null, ChangeType.NATIVES))</span>
<span class="nc" id="L2277">                ? MoveType.MOVE_NO_ACCESS_SKILL</span>
<span class="fc" id="L2278">                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST;</span>
        } else {
<span class="nc" id="L2280">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a missionary to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getMissionaryMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2292" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2293">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2294" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="pc bpc" id="L2295" title="1 of 2 branches missed.">            return (!allowContact(settlement))</span>
<span class="nc" id="L2296">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2297" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
<span class="nc" id="L2298">                ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2299" title="1 of 2 branches missed.">                : (settlement.getOwner().missionsBanned(getOwner()))</span>
<span class="nc" id="L2300">                ? MoveType.MOVE_NO_ACCESS_MISSION_BAN</span>
<span class="fc" id="L2301">                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY;</span>
        } else {
<span class="nc" id="L2303">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Is this unit allowed to move from a source tile?
     * Implements the restrictions on moving from water.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return True if the move is allowed.
     */
    private boolean allowMoveFrom(Tile from) {
<span class="pc bfc" id="L2315" title="All 2 branches covered.">        return from.isLand()</span>
<span class="pc bpc" id="L2316" title="1 of 2 branches missed.">            || (!getOwner().isREF()</span>
<span class="pc bpc" id="L2317" title="1 of 2 branches missed.">                &amp;&amp; getSpecification().getBoolean(GameOptions.AMPHIBIOUS_MOVES));</span>
    }

    /**
     * Is this unit allowed to contact a settlement?
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to consider.
     * @return True if the contact is allowed.
     */
    private boolean allowContact(Settlement settlement) {
<span class="fc" id="L2327">        return getOwner().hasContacted(settlement.getOwner());</span>
    }

    /**
     * Does a basic check whether a unit can ever expect to move to a tile.
     *
     * @param tile The code &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if some sort of legal move to the tile exists, including
     *     special cases where there is an interaction but the unit does not
     *     actually move, such as trade.
     */
    public boolean isTileAccessible(Tile tile) {
<span class="fc bfc" id="L2339" title="All 2 branches covered.">        return (isNaval())</span>
<span class="fc bfc" id="L2340" title="All 2 branches covered.">            ? (!tile.isLand()</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">                || (tile.hasSettlement()</span>
<span class="fc bfc" id="L2342" title="All 2 branches covered.">                    &amp;&amp; getOwner().owns(tile.getSettlement())))</span>
<span class="fc" id="L2343">            : tile.isLand();</span>
    }

    /**
     * Gets the amount of moves this unit has at the beginning of each turn.
     *
     * @return The amount of moves this unit has at the beginning of
     *     each turn.
     */
    @Override
    public int getInitialMovesLeft() {
<span class="fc" id="L2354">        Turn turn = getGame().getTurn();</span>
<span class="fc" id="L2355">        return (int)applyModifiers(unitType.getMovement(), turn,</span>
<span class="fc" id="L2356">                                   Modifier.MOVEMENT_BONUS, unitType);</span>
    }

    /**
     * Make a label showing the unit moves left.
     *
     * @return A movement label.
     */
    public String getMovesAsString() {
<span class="fc" id="L2365">        StringBuilder sb = new StringBuilder(16);</span>
<span class="fc" id="L2366">        int quotient = getMovesLeft() / 3;</span>
<span class="fc" id="L2367">        int remainder = getMovesLeft() % 3;</span>
<span class="fc bfc" id="L2368" title="All 4 branches covered.">        if (quotient &gt; 0 || remainder == 0) sb.append(quotient);</span>
<span class="fc bfc" id="L2369" title="All 2 branches covered.">        if (remainder &gt; 0) {</span>
<span class="fc" id="L2370">            sb.append(&quot;(&quot;).append(remainder).append(&quot;/3) &quot;);</span>
        }
<span class="fc" id="L2372">        sb.append(&quot;/&quot;).append(getInitialMovesLeft() / 3);</span>
<span class="fc" id="L2373">        return sb.toString();</span>
    }

    /**
     * Gets the number of turns this unit will need to sail to/from Europe.
     *
     * @return The number of turns to sail to/from Europe.
     */
    public int getSailTurns() {
<span class="fc" id="L2382">        float base = getSpecification().getInteger(GameOptions.TURNS_TO_SAIL);</span>
<span class="fc" id="L2383">        return (int)getOwner().applyModifiers(base, getGame().getTurn(),</span>
<span class="fc" id="L2384">                                              Modifier.SAIL_HIGH_SEAS,</span>
<span class="fc" id="L2385">                                              unitType);</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; can be moved to the high seas
     * from its current location.
     *
     * @return True if this unit can move immediately to the high seas.
     */
    public boolean canMoveToHighSeas() {
<span class="nc bnc" id="L2395" title="All 4 branches missed.">        if (isInEurope() || isAtSea()) return true;</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">        if (!getOwner().canMoveToEurope()</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">            || !getType().canMoveToHighSeas()) return false;</span>
<span class="nc" id="L2398">        return getTile().isDirectlyHighSeasConnected();</span>
    }

    /**
     * Does this unit have a valid move to the high seas this turn.
     *
     * @return True if the unit can either move immediately to the high
     *      seas or can make a move to a neighbouring high seas tile.
     */
    public boolean hasHighSeasMove() {
<span class="nc bnc" id="L2408" title="All 2 branches missed.">        return (canMoveToHighSeas())</span>
<span class="nc" id="L2409">            ? true</span>
<span class="nc bnc" id="L2410" title="All 4 branches missed.">            : (hasTile() &amp;&amp; getMovesLeft() &gt; 0)</span>
<span class="nc" id="L2411">            ? any(getTile().getSurroundingTiles(1, 1),</span>
<span class="nc" id="L2412">                Tile::isDirectlyHighSeasConnected)</span>
<span class="nc" id="L2413">            : false;</span>
    }

    /**
     * Check if this unit can build a colony.  Does not consider whether
     * the tile where the unit is located is suitable,
     * @see Player#canClaimToFoundSettlement(Tile)
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this unit can build a colony.
     */
    public boolean canBuildColony() {
<span class="fc" id="L2424">        final Specification spec = getSpecification();</span>
<span class="pc bpc" id="L2425" title="1 of 6 branches missed.">        return hasTile() &amp;&amp; unitType.canBuildColony() &amp;&amp; getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L2426" title="1 of 2 branches missed.">            &amp;&amp; (!getOwner().isRebel()</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">                || spec.getBoolean(GameOptions.FOUND_COLONY_DURING_REBELLION));</span>
    }

    /**
     * Is this unit at a specified location?
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to test.
     * @return True if the locations are the same, or on the same tile.
     */
    public boolean isAtLocation(Location loc) {
<span class="fc" id="L2437">        Location ourLoc = getLocation(),</span>
<span class="fc bfc" id="L2438" title="All 2 branches covered.">            otherLoc = (loc instanceof Unit) ? ((Unit)loc).getLocation() : loc;</span>
<span class="pc bpc" id="L2439" title="1 of 2 branches missed.">        if (ourLoc instanceof Unit) ourLoc = ((Unit)ourLoc).getLocation();</span>
<span class="fc" id="L2440">        return Map.isSameLocation(ourLoc, otherLoc);</span>
    }

    /**
     * Gets the best (closest) entry location for this unit to reach a
     * given tile.
     *
     * @param tile The target &lt;code&gt;Tile&lt;/code&gt;.
     * @return The best entry location tile to arrive on the map at, or null
     *     if none found.
     */
    public Tile getBestEntryTile(Tile tile) {
<span class="nc" id="L2452">        return getGame().getMap().getBestEntryTile(this, tile, null, null);</span>
    }

    /**
     * Resolves a destination for a unit on the high seas.
     * That is, the location where the unit will appear when it leaves
     * the high seas, which will either be Europe or a tile.
     *
     * @return The location the unit should appear next after leaving
     *      the high seas.
     */
    public Location resolveDestination() {
<span class="nc bnc" id="L2464" title="All 2 branches missed.">        if (!isAtSea()) throw new IllegalArgumentException(&quot;Not at sea.&quot;);</span>
<span class="nc" id="L2465">        TradeRouteStop stop = getStop();</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">        Location dst = (TradeRoute.isStopValid(this, stop))</span>
<span class="nc" id="L2467">            ? stop.getLocation()</span>
<span class="nc" id="L2468">            : getDestination();</span>
        Tile best;
<span class="nc bnc" id="L2470" title="All 2 branches missed.">        return (dst == null) ? getFullEntryLocation()</span>
<span class="nc bnc" id="L2471" title="All 2 branches missed.">            : (dst instanceof Europe) ? dst</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">            : (dst.getTile() != null</span>
<span class="nc bnc" id="L2473" title="All 2 branches missed.">                &amp;&amp; (best = getBestEntryTile(dst.getTile())) != null) ? best</span>
<span class="nc" id="L2474">            : getFullEntryLocation();</span>
    }

    /**
     * Set movesLeft to 0 if has some spent moves and it's in a colony
     *
     * @see #add(Locatable)
     * @see #remove(Locatable)
     */
    private void spendAllMoves() {
<span class="pc bpc" id="L2484" title="3 of 4 branches missed.">        if (getColony() != null &amp;&amp; getMovesLeft() &lt; getInitialMovesLeft()) {</span>
<span class="nc" id="L2485">            setMovesLeft(0);</span>
        }
<span class="fc" id="L2487">    }</span>

    /**
     * Is this unit ready to operate a trade route?
     *
     * @return True if the unit is ready to trade.
     */
    public boolean isReadyToTrade() {
<span class="nc bnc" id="L2495" title="All 4 branches missed.">        return !isDisposed()</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">            &amp;&amp; !isDamaged()</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">            &amp;&amp; !isAtSea()</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            &amp;&amp; !isOnCarrier()</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">            &amp;&amp; !isInColony()</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">            &amp;&amp; getTradeRoute() != null</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">            &amp;&amp; getState() != Unit.UnitState.FORTIFYING</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            &amp;&amp; getState() != Unit.UnitState.SKIPPED</span>
<span class="nc" id="L2503">            &amp;&amp; getMovesLeft() &gt; 0;</span>
    }

    /**
     * Basic checks for whether a unit is usable ATM.
     *
     * @return True if the unit might be useful at present.
     */
    private boolean readyAndAble() {
<span class="nc bnc" id="L2512" title="All 4 branches missed.">        return !isDisposed()</span>
<span class="nc bnc" id="L2513" title="All 2 branches missed.">            &amp;&amp; !isDamaged()</span>
<span class="nc bnc" id="L2514" title="All 2 branches missed.">            &amp;&amp; !isAtSea()</span>
<span class="nc bnc" id="L2515" title="All 2 branches missed.">            &amp;&amp; !isOnCarrier()</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">            &amp;&amp; !isInColony()</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">            &amp;&amp; getState() == UnitState.ACTIVE</span>
<span class="nc" id="L2518">            &amp;&amp; getMovesLeft() &gt; 0;</span>
    }
    
    /**
     * Is this unit a suitable `next active unit', that is, the unit
     * needs to be currently movable by the player.
     *
     * Used as a predicate in Player.nextActiveUnitIterator.
     *
     * @return True if this unit could still be moved by the player.
     */
    public boolean couldMove() {
<span class="nc bnc" id="L2530" title="All 2 branches missed.">        return readyAndAble()</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            &amp;&amp; getDestination() == null</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">            &amp;&amp; getTradeRoute() == null;</span>
    }

    /**
     * Is this unit a suitable `going-to unit', that is, the unit
     * needs have a valid destination and be able to progress towards it.
     *
     * Used as a predicate in Player.nextGoingToUnitIterator.
     *
     * @return True if this unit can go to its destination.
     */
    public boolean goingToDestination() {
<span class="nc bnc" id="L2544" title="All 2 branches missed.">        return readyAndAble()</span>
<span class="nc bnc" id="L2545" title="All 2 branches missed.">            &amp;&amp; getTradeRoute() == null</span>
<span class="nc bnc" id="L2546" title="All 2 branches missed.">            &amp;&amp; getDestination() != null;</span>
    }

    /**
     * Is this unit available to move along a trade route?
     *
     * Used as a predicate in Player.nextTradeRouteUnitIterator.
     *
     * @return True if this unit can follow a trade route.
     */
    public boolean followingTradeRoute() {
<span class="nc bnc" id="L2557" title="All 2 branches missed.">        return readyAndAble()</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">            &amp;&amp; getTradeRoute() != null;</span>
            // Trade route code might set destination
    }

    
    // Map support routines

    /**
     * Gets a suitable location to start path searches for a unit.
     *
     * Must handle all the cases where the unit is off the map, and
     * take account of the use of a carrier.
     *
     * @return A suitable starting location, or null if none found.
     */
    public Location getPathStartLocation() {
<span class="fc" id="L2574">        final Unit carrier = getCarrier();</span>
<span class="fc" id="L2575">        Location ret = getTile();</span>
<span class="pc bpc" id="L2576" title="1 of 2 branches missed.">        if (isOnCarrier()) {</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2579" title="All 2 branches missed.">            } else if (carrier.getDestination() == null) {</span>
<span class="nc" id="L2580">                ret = null;</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Map) {</span>
<span class="nc" id="L2582">                ret = carrier.getFullEntryLocation();</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2584">                ret = carrier.getDestination();</span>
<span class="nc" id="L2585">            } else { // destination must be Europe</span>
<span class="nc" id="L2586">                ret = null;</span>
            }
<span class="pc bpc" id="L2588" title="1 of 2 branches missed.">        } else if (isNaval()) {</span>
<span class="nc bnc" id="L2589" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2591" title="All 2 branches missed.">            } else if (getDestination() == null</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">                || getDestination() instanceof Map) {</span>
<span class="nc" id="L2593">                ret = getFullEntryLocation();</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">            } else if (getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2595">                ret = getDestination();</span>
<span class="nc" id="L2596">            } else {</span>
<span class="nc" id="L2597">                ret = getFullEntryLocation();</span>
            }
        }
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">        if (ret != null) return ret;</span>

        // Must be a land unit not on the map.  May have a carrier.
        // Get our nearest settlement to Europe, fallback to any other.
<span class="nc" id="L2604">        final Player owner = getOwner();</span>
<span class="nc" id="L2605">        int bestValue = INFINITY;</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">        for (Settlement s : owner.getSettlements()) {</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">            if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2608">                int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2609" title="All 2 branches missed.">                if (bestValue &gt; value) {</span>
<span class="nc" id="L2610">                    bestValue = value;</span>
<span class="nc" id="L2611">                    ret = s;</span>
                }
<span class="nc bnc" id="L2613" title="All 2 branches missed.">            } else if (bestValue == INFINITY) ret = s;</span>
        }
<span class="nc bnc" id="L2615" title="All 2 branches missed.">        if (ret != null) return ret;</span>

        // Owner has no settlements.  If it is the REF, start from a
        // rebel colony.  Prefer the closest port.
<span class="nc bnc" id="L2619" title="All 2 branches missed.">        if (owner.isREF()) {</span>
<span class="nc" id="L2620">            bestValue = INFINITY;</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">            for (Player p : owner.getRebels()) {</span>
<span class="nc bnc" id="L2622" title="All 2 branches missed.">                for (Settlement s : p.getSettlements()) {</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">                    if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2624">                        int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">                        if (bestValue &gt; value) {</span>
<span class="nc" id="L2626">                            bestValue = value;</span>
<span class="nc" id="L2627">                            ret = s;</span>
                        }
<span class="nc bnc" id="L2629" title="All 2 branches missed.">                    } else if (bestValue == INFINITY) ret = s;</span>
                }
            }
<span class="nc bnc" id="L2632" title="All 2 branches missed.">            if (ret != null) return ret;</span>
        }

        // Desperately find the nearest land to the entry location.
<span class="nc" id="L2636">        Location entry = getFullEntryLocation();</span>
<span class="nc bnc" id="L2637" title="All 4 branches missed.">        if (entry != null &amp;&amp; entry.getTile() != null) {</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">            for (Tile t : entry.getTile().getSurroundingTiles(INFINITY)) {</span>
<span class="nc bnc" id="L2639" title="All 2 branches missed.">                if (t.isLand()) return t;</span>
            }
        }

<span class="nc" id="L2643">        return null; // Fail</span>
    }

    /**
     * Should the unit use transport to get to a specified tile?
     *
     * True if:
     * - The location is not null
     * - The unit is not naval
     * - The unit is not there already
     * AND
     *   - there is no path OR the path uses an existing carrier
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to go to.
     * @return True if the unit should use transport.
     */
    public boolean shouldTakeTransportTo(Location loc) {
        PathNode path;
<span class="pc bpc" id="L2661" title="1 of 2 branches missed.">        return loc != null</span>
<span class="pc bpc" id="L2662" title="1 of 2 branches missed.">            &amp;&amp; !isNaval()</span>
<span class="fc bfc" id="L2663" title="All 2 branches covered.">            &amp;&amp; !isAtLocation(loc)</span>
<span class="pc bpc" id="L2664" title="1 of 2 branches missed.">            &amp;&amp; ((path = findPath(getLocation(), loc,</span>
<span class="fc" id="L2665">                                 getCarrier(), null)) == null</span>
<span class="pc bpc" id="L2666" title="1 of 2 branches missed.">                || path.usesCarrier());</span>
    }

    /**
     * Gets the trivial path for this unit.  That is, the path to the
     * nearest available safe settlement.
     *
     * @return A path to the trivial target, or null if none found.
     */
    public PathNode getTrivialPath() {
<span class="pc bpc" id="L2676" title="2 of 4 branches missed.">        if (isDisposed() || getLocation() == null) return null;</span>
<span class="fc bfc" id="L2677" title="All 2 branches covered.">        if (!isNaval()) return findOurNearestSettlement();</span>
<span class="fc" id="L2678">        PathNode path = findOurNearestPort();</span>
<span class="fc bfc" id="L2679" title="All 2 branches covered.">        if (path == null) {</span>
            // This is unusual, but can happen when a ship is up a
            // river and foreign ship creates a blockage downstream.
            // If so, the rational thing to do is to go to a tile
            // where other units can pass and which has the best
            // connectivity to the high seas.
<span class="fc" id="L2685">            Tile tile = getTile();</span>
<span class="pc bpc" id="L2686" title="2 of 4 branches missed.">            if (tile != null &amp;&amp; tile.isOnRiver()</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">                &amp;&amp; tile.isHighSeasConnected()) {</span>
<span class="nc" id="L2688">                path = search(getLocation(), </span>
<span class="nc" id="L2689">                    GoalDeciders.getCornerGoalDecider(),</span>
<span class="nc" id="L2690">                    CostDeciders.avoidSettlementsAndBlockingUnits(),</span>
<span class="nc" id="L2691">                    INFINITY, null);</span>
<span class="nc bnc" id="L2692" title="All 4 branches missed.">                if (path == null &amp;&amp; tile.isRiverCorner()) {</span>
                    // Return trivial path if already present.
<span class="nc" id="L2694">                    return new PathNode(tile, 0, 0, false, null, null);</span>
                }
            }
        }
<span class="fc" id="L2698">        return path;</span>
    }

    /**
     * Finds the fastest path from the current location to the
     * specified one.  No carrier is provided, and the default cost
     * decider for this unit is used.
     *
     * @param end The &lt;code&gt;Location&lt;/code&gt; in which the path ends.
     * @return A &lt;code&gt;PathNode&lt;/code&gt; from the current location to the
     *     end location, or null if none found.
     */
    public PathNode findPath(Location end) {
<span class="fc" id="L2711">        return findPath(getLocation(), end, null, null);</span>
    }

    /**
     * Finds a quickest path between specified locations, optionally
     * using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Location&lt;/code&gt; to end at.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPath(Location start, Location end, Unit carrier,
                             CostDecider costDecider) {
<span class="fc" id="L2728">        return getGame().getMap().findPath(this, start, end,</span>
<span class="fc" id="L2729">                                           carrier, costDecider, null);</span>
    }

    /**
     * Finds a quickest path to a neighbouring tile to a specified target
     * tile, optionally using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Tile&lt;/code&gt; to end at a neighbour of.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPathToNeighbour(Location start, Tile end, Unit carrier,
                                        CostDecider costDecider) {
<span class="nc" id="L2746">        final Player owner = getOwner();</span>
<span class="nc" id="L2747">        int bestValue = INFINITY;</span>
<span class="nc" id="L2748">        PathNode best = null;</span>
<span class="nc bnc" id="L2749" title="All 2 branches missed.">        for (Tile t : end.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2750" title="All 2 branches missed.">            if (isTileAccessible(t)</span>
<span class="nc bnc" id="L2751" title="All 4 branches missed.">                &amp;&amp; (t.getFirstUnit() == null || owner.owns(t.getFirstUnit()))) {</span>
<span class="nc" id="L2752">                PathNode p = findPath(start, t, carrier, costDecider);</span>
<span class="nc bnc" id="L2753" title="All 4 branches missed.">                if (p != null &amp;&amp; bestValue &gt; p.getTotalTurns()) {</span>
<span class="nc" id="L2754">                    bestValue = p.getTotalTurns();</span>
<span class="nc" id="L2755">                    best = p;</span>
                }
            }
        }
<span class="nc" id="L2759">        return best;</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from its current position.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the destination,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location end) {
<span class="fc" id="L2772">        return getTurnsToReach(getLocation(), end);</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end) {
<span class="fc" id="L2786">        return getTurnsToReach(start, end, getCarrier(),</span>
<span class="fc" id="L2787">            CostDeciders.avoidSettlementsAndBlockingUnits());</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location, using an optional
     * carrier and cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; to
     *     score the path with.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end, Unit carrier,
                               CostDecider costDecider) {
<span class="fc" id="L2805">        PathNode path = findPath(start, end, carrier, costDecider);</span>
<span class="pc bpc" id="L2806" title="1 of 2 branches missed.">        return (path == null) ? MANY_TURNS : path.getTotalTurns();</span>
    }

    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A list of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(List&lt;Colony&gt; colonies) {
<span class="nc" id="L2817">        return getClosestColony(colonies.stream());</span>
    }
    
    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A stream of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(Stream&lt;Colony&gt; colonies) {
<span class="fc" id="L2828">        final Comparator&lt;Colony&gt; comp = cachingIntComparator(col -&gt;</span>
<span class="nc bnc" id="L2829" title="All 2 branches missed.">            (col == null) ? MANY_TURNS-1 : this.getTurnsToReach(col));</span>
<span class="fc" id="L2830">        return minimize(Stream.concat(Stream.of((Colony)null), colonies), comp);</span>
    }
    
    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2845">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2846" title="1 of 4 branches missed.">        if (!player.hasSettlements() || !hasTile()) return null;</span>
<span class="fc" id="L2847">        return findOurNearestSettlement(getTile(), excludeStart,</span>
<span class="fc" id="L2848">                                        range, coastal);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param startTile The &lt;code&gt;Tile&lt;/code&gt; to start searching from.
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final Tile startTile,
                                             final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2865">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2866" title="2 of 4 branches missed.">        if (startTile == null || !player.hasSettlements()) return null;</span>
<span class="fc" id="L2867">        final GoalDecider gd = new GoalDecider() {</span>

<span class="fc" id="L2869">                private int bestValue = Integer.MAX_VALUE;</span>
<span class="fc" id="L2870">                private PathNode best = null;</span>

                @Override
<span class="fc" id="L2873">                public PathNode getGoal() { return best; }</span>
                @Override
<span class="fc" id="L2875">                public boolean hasSubGoals() { return true; }</span>
                @Override
                public boolean check(Unit u, PathNode path) {
<span class="fc" id="L2878">                    Tile t = path.getTile();</span>
<span class="pc bpc" id="L2879" title="1 of 2 branches missed.">                    if (t == null</span>
<span class="pc bpc" id="L2880" title="1 of 4 branches missed.">                        || (t == startTile &amp;&amp; excludeStart)) return false;</span>
<span class="fc" id="L2881">                    Settlement settlement = t.getSettlement();</span>
                    int value;
<span class="fc bfc" id="L2883" title="All 2 branches covered.">                    if (settlement != null</span>
<span class="pc bpc" id="L2884" title="1 of 2 branches missed.">                        &amp;&amp; player.owns(settlement)</span>
<span class="pc bpc" id="L2885" title="1 of 4 branches missed.">                        &amp;&amp; (!coastal || settlement.isConnectedPort())</span>
<span class="fc bfc" id="L2886" title="All 2 branches covered.">                        &amp;&amp; (value = path.getTotalTurns()) &lt; bestValue) {</span>
<span class="fc" id="L2887">                        bestValue = value;</span>
<span class="fc" id="L2888">                        best = path;</span>
<span class="fc" id="L2889">                        return true;</span>
                    }
<span class="fc" id="L2891">                    return false;</span>
                }
            };
<span class="fc" id="L2894">        return search(startTile, gd, CostDeciders.avoidIllegal(), range, null);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @return A path to the nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement() {
<span class="fc" id="L2904">        return findOurNearestSettlement(false, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier and is connected to
     * Europe by sea, or Europe if it is closer.
     *
     * @return A path to the nearest settlement if any, otherwise null
     *     (for now including if in Europe or at sea).
     */
    public PathNode findOurNearestPort() {
<span class="fc" id="L2916">        PathNode ePath = null;</span>
<span class="fc" id="L2917">        int eTurns = -1;</span>
<span class="fc" id="L2918">        Europe europe = getOwner().getEurope();</span>
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">        if (getType().canMoveToHighSeas()) {</span>
<span class="pc bpc" id="L2920" title="1 of 2 branches missed.">            ePath = (europe == null) ? null : findPath(europe);</span>
<span class="fc bfc" id="L2921" title="All 2 branches covered.">            eTurns = (ePath == null) ? -1 : ePath.getTotalTurns();</span>
        }
<span class="fc" id="L2923">        PathNode sPath = findOurNearestSettlement(false, INFINITY, true);</span>
<span class="fc bfc" id="L2924" title="All 2 branches covered.">        int sTurns = (sPath == null) ? -1 : sPath.getTotalTurns();</span>
<span class="fc bfc" id="L2925" title="All 2 branches covered.">        return (ePath == null) ? sPath</span>
<span class="fc bfc" id="L2926" title="All 2 branches covered.">            : (sPath == null) ? ePath</span>
<span class="pc bpc" id="L2927" title="1 of 2 branches missed.">            : (sTurns &lt;= eTurns) ? sPath : ePath;</span>
    }

    /**
     * Find a path to a settlement nearer to a destination.
     *
     * Used to find where to deliver goods to/from inland colonies,
     * or when blocked.
     *
     * @param dst The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return A path to the port, or null if none found.
     */
    public PathNode findIntermediatePort(Location dst) {
<span class="nc" id="L2940">        final Settlement ignoreSrc = getSettlement();</span>
<span class="nc" id="L2941">        final Settlement ignoreDst = dst.getSettlement();</span>
<span class="nc" id="L2942">        final Tile srcTile = getTile();</span>
<span class="nc" id="L2943">        final Tile dstTile = dst.getTile();</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">        final int dstCont = (dstTile == null) ? -1 : dstTile.getContiguity();</span>
<span class="nc" id="L2945">        PathNode path, best = null;</span>
<span class="nc" id="L2946">        int value, bestValue = INFINITY;</span>
        int type;

<span class="nc bnc" id="L2949" title="All 2 branches missed.">        if (isNaval()) {</span>
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            if (!srcTile.isHighSeasConnected()) {</span>
                // On a lake!  FIXME: do better
<span class="nc" id="L2952">                type = 0;</span>
<span class="nc bnc" id="L2953" title="All 2 branches missed.">            } else if (dstTile == null) {</span>
                // Carrier must be blocked from high seas
<span class="nc" id="L2955">                type = 1;</span>
<span class="nc bnc" id="L2956" title="All 2 branches missed.">            } else if (dstTile.isHighSeasConnected()) {</span>
                // Carrier is blocked or destination is blocked.
<span class="nc bnc" id="L2958" title="All 2 branches missed.">                type = (getTile().isOnRiver()) ? 1 : 2;</span>
<span class="nc" id="L2959">            } else {</span>
                // Destination must be blocked
<span class="nc" id="L2961">                type = 2;</span>
            }
<span class="nc" id="L2963">        } else {</span>
<span class="nc bnc" id="L2964" title="All 4 branches missed.">            if (dstTile == null || getTile().getContiguity() != dstCont) {</span>
                // Ocean travel will be required
                // If already at port try to improve its connectivity,
                // otherwise go to a port.
<span class="nc bnc" id="L2968" title="All 2 branches missed.">                type = (srcTile.isHighSeasConnected()) ? 1 : 2;</span>
<span class="nc" id="L2969">            } else {</span>
                // Pure land travel, just find a nearer settlement.
<span class="nc" id="L2971">                type = 3;</span>
            }
        }

<span class="nc bnc" id="L2975" title="All 5 branches missed.">        switch (type) {</span>
        case 0:
            // No progress possible.
<span class="nc" id="L2978">            break;</span>
        case 1:
            // Starting on a river, probably blocked in there.
            // Find the settlement that most reduces the high seas count.
<span class="nc" id="L2982">            best = search(getLocation(),</span>
<span class="nc" id="L2983">                          GoalDeciders.getReduceHighSeasCountGoalDecider(this),</span>
<span class="nc" id="L2984">                          null, INFINITY, null);</span>
<span class="nc" id="L2985">            break;</span>
        case 2:
            // Ocean travel required, destination blocked.
            // Find the closest available connected port.
<span class="nc bnc" id="L2989" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L2990" title="All 6 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.isConnectedPort()</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L2992">                    value = path.getTotalTurns()</span>
<span class="nc" id="L2993">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L2995">                        bestValue = value;</span>
<span class="nc" id="L2996">                        best = path;</span>
                    }
                }
            }
<span class="nc" id="L3000">            break;</span>
        case 3:
            // Land travel.  Find nearby settlement with correct contiguity.
<span class="nc bnc" id="L3003" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L3004" title="All 4 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">                    &amp;&amp; s.getTile().getContiguity() == dstCont</span>
<span class="nc bnc" id="L3006" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L3007">                    value = path.getTotalTurns()</span>
<span class="nc" id="L3008">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L3009" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L3010">                        bestValue = value;</span>
<span class="nc" id="L3011">                        best = path;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L3016" title="All 2 branches missed.">        return (best != null) ? best</span>
<span class="nc" id="L3017">            : findOurNearestSettlement(false, INFINITY, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier, excepting any
     * on the current tile.
     *
     * @return The nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestOtherSettlement() {
<span class="nc" id="L3028">        return findOurNearestSettlement(true, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Convenience wrapper for the
     * {@link net.sf.freecol.common.model.Map#search} function.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param gd The object responsible for determining whether a
     *     given &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
     * @param cd An optional &lt;code&gt;CostDecider&lt;/code&gt;
     *     responsible for determining the path cost.
     * @param maxTurns The maximum number of turns the given
     *     &lt;code&gt;Unit&lt;/code&gt; is allowed to move. This is the
     *     maximum search range for a goal.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @return The path to a goal, or null if none can be found.
     */
    public PathNode search(Location start, GoalDecider gd,
                           CostDecider cd, int maxTurns, Unit carrier) {
<span class="pc bpc" id="L3048" title="1 of 2 branches missed.">        return (start == null) ? null</span>
<span class="fc" id="L3049">            : getGame().getMap().search(this, start, gd, cd, maxTurns,</span>
<span class="fc" id="L3050">                                        carrier, null);</span>
    }

    /**
     * Can this unit attack a specified defender?
     *
     * A naval unit can never attack a land unit or settlement,
     * but a land unit *can* attack a naval unit if it is beached.
     * Otherwise naval units can only fight at sea, land units
     * only on land.
     *
     * @param defender The defending &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can attack.
     */
    public boolean canAttack(Unit defender) {
<span class="pc bpc" id="L3065" title="2 of 4 branches missed.">        if (!isOffensiveUnit() || defender == null</span>
<span class="pc bpc" id="L3066" title="1 of 2 branches missed.">            || !defender.hasTile()) return false;</span>

<span class="fc" id="L3068">        Tile tile = defender.getTile();</span>
<span class="pc bpc" id="L3069" title="1 of 2 branches missed.">        return (isNaval())</span>
<span class="nc bnc" id="L3070" title="All 4 branches missed.">            ? !tile.hasSettlement() &amp;&amp; defender.isNaval()</span>
<span class="pc bpc" id="L3071" title="3 of 4 branches missed.">            : !defender.isNaval() || defender.isBeached();</span>
    }

    /**
     * Searches for a unit that is a credible threatening unit to this
     * unit within a range.
     *
     * @param range The number of turns to search for a threat in.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return A path to the threat, or null if not found.
     */
    public PathNode searchForDanger(final int range, final float threat) {
<span class="nc" id="L3084">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L3085">        final Tile start = getTile();</span>
<span class="nc" id="L3086">        final GoalDecider threatDecider = new GoalDecider() {</span>
<span class="nc" id="L3087">                private PathNode found = null;</span>

                @Override
<span class="nc" id="L3090">                public PathNode getGoal() { return found; }</span>
                @Override
<span class="nc" id="L3092">                public boolean hasSubGoals() { return false; }</span>
                @Override
                public boolean check(Unit unit, PathNode path) {
<span class="nc" id="L3095">                    Tile tile = path.getTile();</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">                    if (tile == null) return false;</span>
<span class="nc" id="L3097">                    Unit first = tile.getFirstUnit();</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">                    if (first == null</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">                        || !getOwner().atWarWith(first.getOwner())) {</span>
<span class="nc" id="L3100">                        return false;</span>
                    }
<span class="nc bnc" id="L3102" title="All 2 branches missed.">                    for (Unit u : tile.getUnitList()) {</span>
                        PathNode reverse;
<span class="nc bnc" id="L3104" title="All 2 branches missed.">                        if (u.canAttack(unit)</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">                            &amp;&amp; cm.calculateCombatOdds(u, unit).win &gt;= threat</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">                            &amp;&amp; (reverse = u.findPath(start)) != null</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">                            &amp;&amp; reverse.getTotalTurns() &lt; range) {</span>
<span class="nc" id="L3108">                            found = path;</span>
<span class="nc" id="L3109">                            return true;</span>
                        }
                    }
<span class="nc" id="L3112">                    return false;</span>
                }
            };
        // The range to search will depend on the speed of the other
        // unit.  We can not know what it will be in advance, and it
        // might be significantly faster than this unit.  We do not
        // want to just use an unbounded search range because this
        // routine must be quick (especially when the supplied range
        // is low).  So use the heuristic of increasing the range by
        // the ratio of the fastest appropriate (land/naval) unit type
        // speed over the unit speed.
<span class="nc bnc" id="L3123" title="All 2 branches missed.">        int reverseRange = range * (((isNaval())</span>
<span class="nc" id="L3124">                ? getSpecification().getFastestNavalUnitType()</span>
<span class="nc" id="L3125">                : getSpecification().getFastestLandUnitType())</span>
<span class="nc" id="L3126">            .getMovement()) / this.getType().getMovement();</span>

<span class="nc bnc" id="L3128" title="All 2 branches missed.">        return (start == null) ? null</span>
<span class="nc" id="L3129">            : search(start, threatDecider, CostDeciders.avoidIllegal(),</span>
<span class="nc" id="L3130">                     reverseRange, getCarrier());</span>
    }

    /**
     * Checks if there is a credible threatening unit to this unit
     * within a range of moves.
     *
     * @param range The number of turns to search for a threat within.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return True if a threat was found.
     */
    public boolean isInDanger(int range, float threat) {
<span class="nc bnc" id="L3143" title="All 2 branches missed.">        return searchForDanger(range, threat) != null;</span>
    }

    /**
     * Gets the line of sight of this &lt;code&gt;Unit&lt;/code&gt;.  That is the
     * distance this &lt;code&gt;Unit&lt;/code&gt; can sight new tiles.
     *
     * @return The line of sight of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getLineOfSight() {
<span class="fc" id="L3153">        final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L3154">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3155">        result.addAll(this.getModifiers(Modifier.LINE_OF_SIGHT_BONUS,</span>
<span class="fc" id="L3156">                                        unitType, turn));</span>
<span class="pc bpc" id="L3157" title="1 of 4 branches missed.">        if (hasTile() &amp;&amp; getTile().isExplored()) {</span>
<span class="fc" id="L3158">            result.addAll(getTile().getType()</span>
<span class="fc" id="L3159">                .getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
        }
<span class="fc" id="L3161">        float base = unitType.getLineOfSight();</span>
<span class="fc" id="L3162">        return (int)applyModifiers(base, turn, result);</span>
    }


    // Goods handling

    /**
     * Get the goods carried by this unit.
     *
     * @return A list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getGoodsList() {
<span class="pc bpc" id="L3174" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3175">            : getGoodsContainer().getGoods();</span>
    }

    /**
     * Get a compact version of the goods carried by this unit.
     *
     * @return A compact list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getCompactGoodsList() {
<span class="pc bpc" id="L3184" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3185">            : getGoodsContainer().getCompactGoods();</span>
    }

    /**
     * Can this unit carry other units?
     *
     * @return True if the unit can carry units.
     */
    public boolean canCarryUnits() {
<span class="fc" id="L3194">        return hasAbility(Ability.CARRY_UNITS);</span>
    }

    /**
     * Could this unit carry a specified one?
     * This ignores the current load.
     *
     * @param u The potential cargo &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Unit u) {
<span class="pc bpc" id="L3205" title="1 of 4 branches missed.">        return canCarryUnits()</span>
<span class="fc" id="L3206">            &amp;&amp; getCargoCapacity() &gt;= u.getSpaceTaken();</span>
    }

    /**
     * Can this unit carry goods.
     *
     * @return True if the unit can carry goods.
     */
    public boolean canCarryGoods() {
<span class="fc" id="L3215">        return hasAbility(Ability.CARRY_GOODS);</span>
    }

    /**
     * Could this unit carry some specified goods?
     * This ignores the current load.
     *
     * @param g The potential cargo &lt;code&gt;Goods&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Goods g) {
<span class="pc bpc" id="L3226" title="2 of 4 branches missed.">        return canCarryGoods()</span>
<span class="fc" id="L3227">            &amp;&amp; getCargoCapacity() &gt;= g.getSpaceTaken();</span>
    }

    /**
     * Gets the number of free cargo slots left on this unit.
     *
     * @return The number of free cargo slots on this unit.
     */
    public int getSpaceLeft() {
<span class="fc" id="L3236">        return getCargoCapacity() - getCargoSpaceTaken();</span>
    }

    /**
     * Is there free space left on this unit?
     *
     * @return True if there is free space.
     */
    public boolean hasSpaceLeft() {
<span class="fc bfc" id="L3245" title="All 2 branches covered.">        return getSpaceLeft() &gt; 0;</span>
    }

    /**
     * Gets the total space this unit has to carry cargo.
     *
     * @return The total space.
     */
    public int getCargoCapacity() {
<span class="fc" id="L3254">        return unitType.getSpace();</span>
    }

    /**
     * Gets the space occupied by goods in this unit.  Must defend
     * against goods container being null as this can be called in the
     * client on foreign units, which will not have goods containers.
     *
     * @return The number cargo slots occupied by goods.
     */
    public int getGoodsSpaceTaken() {
<span class="pc bpc" id="L3265" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3266">        GoodsContainer gc = getGoodsContainer();</span>
<span class="pc bpc" id="L3267" title="1 of 2 branches missed.">        return (gc == null) ? 0 : gc.getSpaceTaken();</span>
    }

    /**
     * Gets the space occupied by units in this unit.
     *
     * @return The number of cargo slots occupied by units.
     */
    public int getUnitSpaceTaken() {
<span class="fc bfc" id="L3276" title="All 2 branches covered.">        return (canCarryUnits()) ? sum(getUnitList(), u -&gt; u.getSpaceTaken())</span>
<span class="fc" id="L3277">            : 0;</span>
    }

    /**
     * Gets the space occupied by cargo in this unit (both goods and units).
     *
     * @return The number of occupied cargo slots.
     */
    public int getCargoSpaceTaken() {
<span class="fc" id="L3286">        return getGoodsSpaceTaken() + getUnitSpaceTaken();</span>
    }

    /**
     * Is this unit carrying any goods cargo?
     *
     * @return True if the unit is carrying any goods cargo.
     */
    public boolean hasGoodsCargo() {
<span class="fc bfc" id="L3295" title="All 2 branches covered.">        return getGoodsSpaceTaken() &gt; 0;</span>
    }

    /**
     * Is this unit carrying any cargo (goods or unit).
     *
     * @return True if the unit is carrying any cargo.
     */
    public boolean hasCargo() {
<span class="nc bnc" id="L3304" title="All 2 branches missed.">        return getCargoSpaceTaken() &gt; 0;</span>
    }

    /**
     * Gets the extra amount of a specified type of goods that could
     * be loaded onto this unit.  Includes empty cargo slots and any
     * spare space in a slot partially filled with the specified
     * goods.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to examine.
     * @return The amount of goods that could be loaded onto this unit.
     */
    public int getLoadableAmount(GoodsType type) {
<span class="pc bpc" id="L3317" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3318">        int result = getSpaceLeft() * GoodsContainer.CARGO_SIZE;</span>
<span class="fc" id="L3319">        int count = getGoodsCount(type) % GoodsContainer.CARGO_SIZE;</span>
<span class="fc bfc" id="L3320" title="All 2 branches covered.">        if (count != 0) result += GoodsContainer.CARGO_SIZE - count;</span>
<span class="fc" id="L3321">        return result;</span>
    }


    // Miscellaneous more complex functionality

    /**
     * Get a label for the current unit occupation.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewing the unit, as the
     *     owner has access to more information.
     * @param full If true, return a more detailed result.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the unit occupation.
     */
    public StringTemplate getOccupationLabel(Player player, boolean full) {
<span class="nc" id="L3336">        final TradeRoute tradeRoute = getTradeRoute();</span>
        StringTemplate ret;
<span class="nc bnc" id="L3338" title="All 4 branches missed.">        if (player != null &amp;&amp; player.owns(this)) {</span>
<span class="nc bnc" id="L3339" title="All 2 branches missed.">            if (isDamaged()) {</span>
<span class="nc bnc" id="L3340" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3341">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3342">                        .add(&quot;model.unit.occupation.underRepair&quot;)</span>
<span class="nc" id="L3343">                        .addName(String.valueOf(getTurnsForRepair()));</span>
<span class="nc" id="L3344">                } else {</span>
<span class="nc" id="L3345">                    ret = StringTemplate.key(&quot;model.unit.occupation.underRepair&quot;);</span>
                }
<span class="nc bnc" id="L3347" title="All 2 branches missed.">            } else if (tradeRoute != null) {</span>
<span class="nc bnc" id="L3348" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3349">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3350">                        .add(&quot;model.unit.occupation.inTradeRoute&quot;)</span>
<span class="nc" id="L3351">                        .addName(tradeRoute.getName());</span>
<span class="nc" id="L3352">                } else {</span>
<span class="nc" id="L3353">                    ret = StringTemplate.key(&quot;model.unit.occupation.inTradeRoute&quot;);</span>
                }
<span class="nc bnc" id="L3355" title="All 4 branches missed.">            } else if (getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() == 0) {</span>
<span class="nc" id="L3356">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
<span class="nc bnc" id="L3357" title="All 2 branches missed.">            } else if (getState() == UnitState.IMPROVING</span>
<span class="nc bnc" id="L3358" title="All 2 branches missed.">                &amp;&amp; getWorkImprovement() != null) {</span>
<span class="nc bnc" id="L3359" title="All 2 branches missed.">                if (full) {</span>
<span class="nc" id="L3360">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="nc" id="L3361">                        .add(getWorkImprovement().getType() + &quot;.occupationString&quot;)</span>
<span class="nc" id="L3362">                        .addName(String.valueOf(getWorkTurnsLeft()));</span>
<span class="nc" id="L3363">                } else {</span>
<span class="nc" id="L3364">                    ret = StringTemplate.key(getWorkImprovement().getType() + &quot;.occupationString&quot;);</span>
                }
<span class="nc bnc" id="L3366" title="All 2 branches missed.">            } else if (getDestination() != null) {</span>
<span class="nc" id="L3367">                ret = StringTemplate.key(&quot;model.unit.occupation.goingSomewhere&quot;);</span>
<span class="nc" id="L3368">            } else {</span>
<span class="nc" id="L3369">                ret = StringTemplate.key(&quot;model.unit.&quot; + getState().getKey());</span>
            }
<span class="nc" id="L3371">        } else {</span>
<span class="nc bnc" id="L3372" title="All 2 branches missed.">            if (isNaval()) {</span>
<span class="nc" id="L3373">                ret = StringTemplate.name(String.valueOf(getVisibleGoodsCount()));</span>
<span class="nc" id="L3374">            } else {</span>
<span class="nc" id="L3375">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
            }
        }
<span class="nc" id="L3378">        return ret;</span>
    }

    /**
     * Gets the probability that an attack by this unit will provoke a
     * native to convert.
     *
     * @return A probability of conversion.
     */
    public float getConvertProbability() {
<span class="fc" id="L3388">        final Specification spec = getSpecification();</span>
<span class="fc" id="L3389">        int opt = spec.getInteger(GameOptions.NATIVE_CONVERT_PROBABILITY);</span>
<span class="fc" id="L3390">        return 0.01f * applyModifiers(opt, getGame().getTurn(),</span>
<span class="fc" id="L3391">                                      Modifier.NATIVE_CONVERT_BONUS);</span>
    }

    /**
     * Gets the probability that an attack by this unit will provoke natives
     * to burn our missions.
     *
     * FIXME: enhance burn probability proportionally with tension
     *
     * @return A probability of burning missions.
     */
    public float getBurnProbability() {
<span class="nc" id="L3403">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3404">        return 0.01f * spec.getInteger(GameOptions.BURN_PROBABILITY);</span>
    }

    /**
     * Get a type change for this unit.
     *
     * @param change The &lt;code&gt;ChangeType&lt;/code&gt; to consider.
     * @param owner The &lt;code&gt;Player&lt;/code&gt; to own this unit after a
     *    change of type CAPTURE or UNDEAD.
     * @return The resulting unit type or null if there is no change suitable.
     */
    public UnitType getTypeChange(ChangeType change, Player owner) {
<span class="fc" id="L3416">        return getType().getTargetType(change, owner);</span>
    }

    /**
     * Checks if the treasure train can be cashed in at it's current
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain() {
<span class="fc" id="L3427">        return canCashInTreasureTrain(getLocation());</span>
    }

    /**
     * Checks if the treasure train can be cashed in at the given
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain(Location loc) {
<span class="pc bpc" id="L3439" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L3440">            throw new IllegalStateException(&quot;Can't carry treasure&quot;);</span>
        }
<span class="fc bfc" id="L3442" title="All 2 branches covered.">        if (loc == null) return false;</span>

<span class="pc bpc" id="L3444" title="1 of 2 branches missed.">        if (getOwner().getEurope() == null) {</span>
            // Any colony will do once independent, as the treasure stays
            // in the New World.
<span class="nc bnc" id="L3447" title="All 2 branches missed.">            return loc.getColony() != null;</span>
        }
<span class="fc bfc" id="L3449" title="All 2 branches covered.">        if (loc.getColony() != null) {</span>
            // Cash in if at a colony which has connectivity to Europe
            // unless the player has a suitable carrier and no free transport.
<span class="fc bfc" id="L3452" title="All 2 branches covered.">            return loc.getColony().isConnectedPort()</span>
<span class="fc bfc" id="L3453" title="All 2 branches covered.">                &amp;&amp; (getOwner().getCarriersForUnit(this).isEmpty()</span>
<span class="pc bpc" id="L3454" title="1 of 2 branches missed.">                    || getTransportFee() == 0);</span>
        }
        // Otherwise, cash in if in Europe.
<span class="pc bpc" id="L3457" title="1 of 2 branches missed.">        return loc instanceof Europe</span>
<span class="pc bpc" id="L3458" title="1 of 4 branches missed.">            || (loc instanceof Unit &amp;&amp; ((Unit)loc).isInEurope());</span>
    }

    /**
     * Get the fee that would have to be paid to transport this
     * treasure to Europe.
     *
     * @return The fee required for transport.
     */
    public int getTransportFee() {
<span class="pc bpc" id="L3468" title="1 of 4 branches missed.">        if (!isInEurope() &amp;&amp; getOwner().getEurope() != null) {</span>
<span class="fc" id="L3469">            float fee = (getSpecification()</span>
<span class="fc" id="L3470">                .getInteger(GameOptions.TREASURE_TRANSPORT_FEE)</span>
<span class="fc" id="L3471">                * getTreasureAmount()) / 100.0f;</span>
<span class="fc" id="L3472">            return (int)getOwner().applyModifiers(fee, getGame().getTurn(),</span>
<span class="fc" id="L3473">                Modifier.TREASURE_TRANSPORT_FEE, unitType);</span>
        }
<span class="fc" id="L3475">        return 0;</span>
    }

    /**
     * Gets the skill level.
     *
     * @return The level of skill for this unit.  A higher value
     *     signals a more advanced type of units.
     */
    public int getSkillLevel() {
<span class="fc" id="L3485">        return getSkillLevel(unitType);</span>
    }

    /**
     * Gets the skill level of the given type of &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param unitType The type of &lt;code&gt;Unit&lt;/code&gt;.
     * @return The level of skill for the given unit.  A higher value
     *     signals a more advanced type of units.
     */
    public static int getSkillLevel(UnitType unitType) {
<span class="pc bpc" id="L3496" title="1 of 2 branches missed.">        return (unitType.hasSkill()) ? unitType.getSkill() : 0;</span>
    }

    /**
     * Gets the appropriate trade bonuses due to a missionary unit.
     *
     * @param sense The sense to apply the modifiers.
     * @return The missionary trade bonuses.
     */
    public Set&lt;Modifier&gt; getMissionaryTradeModifiers(boolean sense) {
<span class="nc" id="L3506">        return transform(getModifiers(Modifier.MISSIONARY_TRADE_BONUS),</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">                         m -&gt; m.getValue() != 0,</span>
<span class="nc" id="L3508">                         m -&gt; {</span>
<span class="nc" id="L3509">                             Modifier mod = new Modifier(m);</span>
<span class="nc bnc" id="L3510" title="All 2 branches missed.">                             if (!sense) mod.setValue(-m.getValue());</span>
<span class="nc" id="L3511">                             return mod;</span>
<span class="nc" id="L3512">                         }, Collectors.toSet());</span>
    }

    /**
     * Adds a feature to the Unit.  This method always throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, since features can
     * not be added to Units directly.
     *
     * @param feature The &lt;code&gt;Feature&lt;/code&gt; to add.
     */
    public void addFeature(Feature feature) {
<span class="nc" id="L3523">        throw new UnsupportedOperationException(&quot;Can not add Feature to Unit directly!&quot;);</span>
    }

    /**
     * Gets the &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     *
     * FIXME: the input parameter is ignored! Fix?
     *
     * @param input A list of input &lt;code&gt;AbstractGoods&lt;/code&gt;.
     * @return The &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     */
    public ProductionInfo getProductionInfo(List&lt;AbstractGoods&gt; input) {
<span class="fc" id="L3535">        ProductionInfo result = new ProductionInfo();</span>
<span class="fc" id="L3536">        result.setConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3537">        result.setMaximumConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3538">        return result;</span>
    }

    /**
     * Score this unit with its suitability for pioneering.
     *
     * A pioneer must be a colonst.  Favour:
     * - existing pioneers especially if on the map
     * - expert pioneer units
     * - then by skill but not other experts
     *
     * @return A pioneering score.
     */
    public int getPioneerScore() {
<span class="nc bnc" id="L3552" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3553" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3554" title="All 2 branches missed.">            : (hasAbility(Ability.IMPROVE_TERRAIN)) ? 900 + ht</span>
<span class="nc bnc" id="L3555" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_PIONEER)) ? 700</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3557" title="All 2 branches missed.">            : (getSkillLevel() &gt; 0) ? 0</span>
<span class="nc" id="L3558">            : 200 + getSkillLevel() * 50;</span>
    }

    /**
     * Score this unit with its suitability for scouting.
     *
     * A scout must be a colonist.  Favour:
     * - existing scouts especially if on the map
     * - expert scouts
     * - lower skill level as scouting is a good career for crims and servants
     *   which might become seasoned scouts
     *
     * @return A scouting score.
     */
    public int getScoutScore() {
<span class="nc bnc" id="L3573" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3574" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3575" title="All 2 branches missed.">            : (hasAbility(Ability.SPEAK_WITH_CHIEF)) ? 900 + ht</span>
<span class="nc bnc" id="L3576" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_SCOUT)) ? 700</span>
<span class="nc bnc" id="L3577" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">            : (getSkillLevel() &lt;= 0) ? -200 * getSkillLevel()</span>
<span class="nc" id="L3579">            : 0;</span>
    }

    /**
     * Evaluate this unit for trade purposes.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
     * @return A value of this unit.
     */
    public int evaluateFor(Player player) {
<span class="nc" id="L3589">        final Europe europe = player.getEurope();</span>
<span class="nc bnc" id="L3590" title="All 4 branches missed.">        if (player.isAI() &amp;&amp; player.getUnits().size() &lt; 10) {</span>
<span class="nc" id="L3591">            return Integer.MIN_VALUE;</span>
        }
<span class="nc bnc" id="L3593" title="All 2 branches missed.">        return (europe == null) ? 500 : europe.getUnitPrice(getType());</span>
    }

    // @compat 0.11.0
    /**
     * Get modifiers required for combat.
     *
     * This can be replaced with just getModifiers() when accepted
     * specifications have all combat modifiers with correct index
     * values.
     *
     * @param id The identifier to get combat modifiers for.
     * @param fcgot An optional &lt;code&gt;FreeColSpecObjectType&lt;/code&gt; the
     *     modifier applies to.
     * @param turn An optional applicable &lt;code&gt;Turn&lt;/code&gt;.
     * @return The set of &lt;code&gt;Modifier&lt;/code&gt;s found.
     */
    public Set&lt;Modifier&gt; getCombatModifiers(String id,
        FreeColSpecObjectType fcgot, Turn turn) {
<span class="fc" id="L3612">        final Player owner = getOwner();</span>
<span class="fc" id="L3613">        final UnitType unitType = getType();</span>
<span class="fc" id="L3614">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc bfc" id="L3617" title="All 2 branches covered.">        for (Modifier m : unitType.getModifiers(id, fcgot, turn)) {</span>
<span class="fc bfc" id="L3618" title="All 2 branches covered.">            switch (m.getType()) {</span>
            case ADDITIVE:
<span class="fc" id="L3620">                m.setModifierIndex(Modifier.UNIT_ADDITIVE_COMBAT_INDEX);</span>
<span class="fc" id="L3621">                break;</span>
            default:
<span class="fc" id="L3623">                m.setModifierIndex(Modifier.UNIT_NORMAL_COMBAT_INDEX);</span>
                break;
            }
<span class="fc" id="L3626">            result.add(m);</span>
        }

        // The player's modifiers may not all apply
<span class="fc bfc" id="L3630" title="All 2 branches covered.">        for (Modifier m : owner.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3631">            m.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
<span class="fc" id="L3632">            result.add(m);</span>
        }
        
        // Role modifiers apply
<span class="fc bfc" id="L3636" title="All 2 branches covered.">        for (Modifier m : role.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3637">            m.setModifierIndex(Modifier.ROLE_COMBAT_INDEX);</span>
<span class="fc" id="L3638">            result.add(m);</span>
        }

<span class="fc" id="L3641">        return result;</span>
    }
    // end @compat 0.11.0


    // Message unpacking support.

    /**
     * Gets the tile in a given direction.
     *
     * @param directionString The direction.
     * @return The &lt;code&gt;Tile&lt;/code&gt; in the given direction.
     * @throws IllegalStateException if there is trouble.
     */
    public Tile getNeighbourTile(String directionString) {
<span class="nc bnc" id="L3656" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3657">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3658">                + getId());</span>
        }

<span class="nc" id="L3661">        Direction direction = Enum.valueOf(Direction.class, directionString);</span>
<span class="nc" id="L3662">        Tile tile = getTile().getNeighbourOrNull(direction);</span>
<span class="nc bnc" id="L3663" title="All 2 branches missed.">        if (tile == null) {</span>
<span class="nc" id="L3664">            throw new IllegalStateException(&quot;Could not find tile&quot;</span>
<span class="nc" id="L3665">                + &quot; in direction: &quot; + direction + &quot; from unit: &quot; + getId());</span>
        }
<span class="nc" id="L3667">        return tile;</span>
    }

    /**
     * Get a settlement by identifier, validating as much as possible.
     * Designed for message unpacking where the identifier should not
     * be trusted.
     *
     * @param settlementId The identifier of the
     *     &lt;code&gt;Settlement&lt;/code&gt; to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public Settlement getAdjacentSettlementSafely(String settlementId)
        throws IllegalStateException {
<span class="nc" id="L3683">        Game game = getOwner().getGame();</span>

<span class="nc" id="L3685">        Settlement settlement = game.getFreeColGameObject(settlementId,</span>
<span class="nc" id="L3686">                                                          Settlement.class);</span>
<span class="nc bnc" id="L3687" title="All 2 branches missed.">        if (settlement == null) {</span>
<span class="nc" id="L3688">            throw new IllegalStateException(&quot;Not a settlement: &quot;</span>
<span class="nc" id="L3689">                + settlementId);</span>
<span class="nc bnc" id="L3690" title="All 2 branches missed.">        } else if (settlement.getTile() == null) {</span>
<span class="nc" id="L3691">            throw new IllegalStateException(&quot;Settlement is not on the map: &quot;</span>
<span class="nc" id="L3692">                + settlementId);</span>
        }

<span class="nc bnc" id="L3695" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3696">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3697">                + getId());</span>
<span class="nc bnc" id="L3698" title="All 2 branches missed.">        } else if (getTile().getDistanceTo(settlement.getTile()) &gt; 1) {</span>
<span class="nc" id="L3699">            throw new IllegalStateException(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L3700">                + &quot; is not adjacent to settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3701" title="All 2 branches missed.">        } else if (getOwner() == settlement.getOwner()) {</span>
<span class="nc" id="L3702">            throw new IllegalStateException(&quot;Unit: &quot; + getId()</span>
<span class="nc" id="L3703">                + &quot; and settlement: &quot; + settlementId</span>
<span class="nc" id="L3704">                + &quot; are both owned by player: &quot; + getOwner().getId());</span>
        }

<span class="nc" id="L3707">        return settlement;</span>
    }

    /**
     * Get an adjacent Indian settlement by identifier, validating as
     * much as possible, including checking whether the nation
     * involved has been contacted.  Designed for message unpacking
     * where the identifier should not be trusted.
     *
     * @param id The identifier of the &lt;code&gt;IndianSettlement&lt;/code&gt;
     *     to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public IndianSettlement getAdjacentIndianSettlementSafely(String id)
        throws IllegalStateException {
<span class="nc" id="L3724">        Settlement settlement = getAdjacentSettlementSafely(id);</span>
<span class="nc bnc" id="L3725" title="All 2 branches missed.">        if (!(settlement instanceof IndianSettlement)) {</span>
<span class="nc" id="L3726">            throw new IllegalStateException(&quot;Not an indianSettlement: &quot; + id);</span>
<span class="nc bnc" id="L3727" title="All 2 branches missed.">        } else if (!getOwner().hasContacted(settlement.getOwner())) {</span>
<span class="nc" id="L3728">            throw new IllegalStateException(&quot;Player has not contacted the &quot;</span>
<span class="nc" id="L3729">                + settlement.getOwner().getNation());</span>
        }

<span class="nc" id="L3732">        return (IndianSettlement)settlement;</span>
    }


    // Interface Consumer

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;AbstractGoods&gt; getConsumedGoods() {
<span class="fc" id="L3743">        return unitType.getConsumedGoods();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getPriority() {
<span class="fc" id="L3751">        return unitType.getPriority();</span>
    }


    // Interface Ownable

    /**
     * {@inheritDoc}
     */
    @Override
    public Player getOwner() {
<span class="fc" id="L3762">        return owner;</span>
    }

    /**
     * {@inheritDoc}
     *
     * -vis: This routine has visibility implications.
     */
    @Override
    public void setOwner(Player player) {
<span class="fc" id="L3772">        this.owner = player;</span>
<span class="fc" id="L3773">    }</span>


    // Interface Locatable
    //   getTile and getSpaceTaken are shared with Location below

    /**
     * Gets the location of this unit.
     *
     * @return The location of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    @Override
    public Location getLocation() {
<span class="fc" id="L3786">        return this.location;</span>
    }

    /**
     * Sets the location of this unit.
     *
     * -vis: This routine changes player visibility.
     * -til: While units do not contribute to tile appearance as such, if
     *     they move in/out of a colony the visible colony size changes.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     * @return True if the location change succeeds.
     */
    @Override
    public boolean setLocation(Location newLocation) {
        // It is possible to add a unit to a non-specific location
        // within a colony by specifying the colony as the new
        // location.  Colony.joinColony handles this special case.
<span class="fc bfc" id="L3804" title="All 2 branches covered.">        if (newLocation instanceof Colony) {</span>
<span class="fc" id="L3805">            return ((Colony)newLocation).joinColony(this);</span>
        }

<span class="fc bfc" id="L3808" title="All 2 branches covered.">        if (newLocation == this.location) return true;</span>
<span class="fc bfc" id="L3809" title="All 4 branches covered.">        if (newLocation != null &amp;&amp; !newLocation.canAdd(this)) {</span>
<span class="fc" id="L3810">            logger.warning(&quot;Can not add &quot; + this + &quot; to &quot;</span>
<span class="fc" id="L3811">                + newLocation.getId());</span>
<span class="fc" id="L3812">            return false;</span>
        }

        // If the unit either starts or ends this move in a colony
        // then teaching status can change.  However, if it moves
        // between locations within the same colony with the same
        // teaching ability, the teaching state should *not* change.
        // We have to handle this issue here in setLocation as this is
        // the only place that contains information about both
        // locations.
<span class="fc bfc" id="L3822" title="All 2 branches covered.">        Colony oldColony = (isInColony()) ? this.location.getColony() : null;</span>
<span class="fc bfc" id="L3823" title="All 2 branches covered.">        Colony newColony = (newLocation instanceof WorkLocation)</span>
<span class="fc" id="L3824">            ? newLocation.getColony() : null;</span>
<span class="fc bfc" id="L3825" title="All 4 branches covered.">        boolean withinColony = newColony != null &amp;&amp; newColony == oldColony;</span>
<span class="fc bfc" id="L3826" title="All 2 branches covered.">        boolean preserveEducation = withinColony</span>
<span class="fc" id="L3827">            &amp;&amp; (((WorkLocation)this.location).canTeach()</span>
<span class="fc bfc" id="L3828" title="All 2 branches covered.">                == ((WorkLocation)newLocation).canTeach());</span>

        // First disable education that will fail due to the move.
<span class="fc bfc" id="L3831" title="All 4 branches covered.">        if (oldColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3832">            oldColony.updateEducation(this, false);</span>
        }

        // Move out of the old location.
<span class="fc bfc" id="L3836" title="All 2 branches covered.">        if (this.location == null) {</span>
            ; // do nothing
<span class="pc bpc" id="L3838" title="1 of 2 branches missed.">        } else if (!this.location.remove(this)) {//-vis</span>
            // &quot;Should not happen&quot; (should always be able to remove)
<span class="nc" id="L3840">            throw new RuntimeException(&quot;Failed to remove &quot; + this</span>
<span class="nc" id="L3841">                + &quot; from &quot; + this.location.getId());</span>
        }

        // Move in to the new location.
<span class="fc bfc" id="L3845" title="All 2 branches covered.">        if (newLocation == null) {</span>
<span class="fc" id="L3846">            setLocationNoUpdate(null);//-vis</span>
<span class="pc bpc" id="L3847" title="1 of 2 branches missed.">        } else if (!newLocation.add(this)) {//-vis</span>
            // &quot;Should not happen&quot; (canAdd was checked above)
<span class="nc" id="L3849">            throw new RuntimeException(&quot;Failed to add &quot;</span>
<span class="nc" id="L3850">                + this + &quot; to &quot; + newLocation.getId());</span>
        }

        // See if education needs to be re-enabled.
<span class="fc bfc" id="L3854" title="All 4 branches covered.">        if (newColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3855">            newColony.updateEducation(this, true);</span>
        }

        // Update population of any colonies involved.
<span class="fc bfc" id="L3859" title="All 2 branches covered.">        if (!withinColony) {</span>
<span class="fc bfc" id="L3860" title="All 2 branches covered.">            if (oldColony != null) oldColony.updatePopulation();</span>
<span class="fc bfc" id="L3861" title="All 2 branches covered.">            if (newColony != null) newColony.updatePopulation();</span>
        }
<span class="fc" id="L3863">        return true;</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is located in Europe.  That
     * is; either directly or onboard a carrier which is in Europe.
     *
     * @return True if in &lt;code&gt;Europe&lt;/code&gt;.
     */
    @Override
    public boolean isInEurope() {
<span class="fc bfc" id="L3874" title="All 2 branches covered.">        return (isOnCarrier()) ? getCarrier().isInEurope()</span>
<span class="fc" id="L3875">            : getLocation() instanceof Europe;</span>
    }


    // Interface Location (from GoodsLocation via UnitLocation)
    // Inherits
    //   FreeColObject.getId
    //   UnitLocation.getLocationLabelFor
    //   UnitLocation.contains
    //   UnitLocation.canAdd
    //   UnitLocation.getUnitCount
    //   UnitLocation.getUnitList
    //   GoodsLocation.getGoodsContainer

    /**
     * {@inheritDoc}
     */
    @Override
    public Tile getTile() {
<span class="fc bfc" id="L3894" title="All 2 branches covered.">        return (getLocation() != null) ? getLocation().getTile() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabel() {
<span class="nc" id="L3902">        return StringTemplate.template(&quot;model.unit.onBoard&quot;)</span>
<span class="nc" id="L3903">            .addStringTemplate(&quot;%unit%&quot;, this.getLabel());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(Locatable locatable) {
<span class="fc bfc" id="L3911" title="All 2 branches covered.">        if (!canAdd(locatable)) {</span>
<span class="fc" id="L3912">            return false;</span>
<span class="fc bfc" id="L3913" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="fc" id="L3914">            Unit unit = (Unit)locatable;</span>
<span class="pc bpc" id="L3915" title="1 of 2 branches missed.">            if (super.add(locatable)) {</span>
                // FIXME: there seems to be an inconsistency between
                // units moving from an adjacent tile onto a ship and
                // units boarding a ship in-colony.  The former does not
                // appear to come through here (which it probably should)
                // as the ship's moves do not get zeroed.
<span class="fc" id="L3921">                spendAllMoves();</span>
<span class="fc" id="L3922">                unit.setState(UnitState.SENTRY);</span>
<span class="fc" id="L3923">                return true;</span>
            }
<span class="pc bpc" id="L3925" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L3926">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L3927" title="1 of 2 branches missed.">            if (super.addGoods(goods)) {</span>
<span class="fc" id="L3928">                spendAllMoves();</span>
<span class="fc" id="L3929">                return true;</span>
            }
        } else {
<span class="nc" id="L3932">            throw new IllegalStateException(&quot;Can not be added to unit: &quot;</span>
<span class="nc" id="L3933">                + locatable);</span>
        }
<span class="nc" id="L3935">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Locatable locatable) {
<span class="pc bpc" id="L3943" title="1 of 2 branches missed.">        if (locatable == null) {</span>
<span class="nc" id="L3944">            throw new IllegalArgumentException(&quot;Locatable must not be 'null'.&quot;);</span>
<span class="pc bpc" id="L3945" title="2 of 4 branches missed.">        } else if (locatable instanceof Unit &amp;&amp; canCarryUnits()) {</span>
<span class="pc bpc" id="L3946" title="1 of 2 branches missed.">            if (super.remove(locatable)) {</span>
<span class="fc" id="L3947">                spendAllMoves();</span>
<span class="fc" id="L3948">                return true;</span>
            }
<span class="nc bnc" id="L3950" title="All 4 branches missed.">        } else if (locatable instanceof Goods &amp;&amp; canCarryGoods()) {</span>
<span class="nc bnc" id="L3951" title="All 2 branches missed.">            if (super.removeGoods((Goods)locatable) != null) {</span>
<span class="nc" id="L3952">                spendAllMoves();</span>
<span class="nc" id="L3953">                return true;</span>
            }
        } else {
<span class="nc" id="L3956">            logger.warning(&quot;Tried to remove from unit: &quot;</span>
<span class="nc" id="L3957">                + locatable);</span>
        }
<span class="nc" id="L3959">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Settlement getSettlement() {
<span class="fc" id="L3967">        Location loc = getLocation();</span>
<span class="fc bfc" id="L3968" title="All 2 branches covered.">        return (loc != null) ? loc.getSettlement() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Location up() {
<span class="nc bnc" id="L3976" title="All 2 branches missed.">        return (isInEurope()) ? getLocation().up()</span>
<span class="nc bnc" id="L3977" title="All 2 branches missed.">            : (isInColony()) ? getColony()</span>
<span class="nc bnc" id="L3978" title="All 2 branches missed.">            : (hasTile()) ? getTile().up()</span>
<span class="nc" id="L3979">            : this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getRank() {
<span class="nc" id="L3987">        return Location.getRank(getLocation());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toShortString() {
<span class="fc" id="L3995">        StringBuilder sb = new StringBuilder(32);</span>
<span class="fc" id="L3996">        sb.append(getId()).append(&quot;-&quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L3997" title="All 2 branches covered.">        if (!hasDefaultRole()) {</span>
<span class="fc" id="L3998">            sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L3999">            int count = getRoleCount();</span>
<span class="fc bfc" id="L4000" title="All 2 branches covered.">            if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
        }
<span class="fc" id="L4002">        return sb.toString();</span>
    }


    // UnitLocation
    // Inherits
    //   UnitLocation.getSpaceTaken
    //   UnitLocation.moveToFront
    //   UnitLocation.clearUnitList

    /**
     * {@inheritDoc}
     */
    @Override
    public int getSpaceTaken() {
        // We do not have to consider what this unit is carrying
        // because carriers can not be put onto carriers.  Yet.
<span class="fc" id="L4019">        return unitType.getSpaceTaken();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public NoAddReason getNoAddReason(Locatable locatable) {
<span class="pc bpc" id="L4027" title="1 of 2 branches missed.">        if (locatable == this) {</span>
<span class="nc" id="L4028">            return NoAddReason.ALREADY_PRESENT;</span>
<span class="fc bfc" id="L4029" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="pc bpc" id="L4030" title="1 of 2 branches missed.">            return (!canCarryUnits())</span>
<span class="nc" id="L4031">                ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4032" title="All 2 branches covered.">                : (locatable.getSpaceTaken() &gt; getSpaceLeft())</span>
<span class="fc" id="L4033">                ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="fc" id="L4034">                : super.getNoAddReason(locatable);</span>
<span class="pc bpc" id="L4035" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L4036">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L4037" title="1 of 2 branches missed.">            return (!canCarryGoods())</span>
<span class="nc" id="L4038">                ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4039" title="All 2 branches covered.">                : (goods.getAmount() &gt; getLoadableAmount(goods.getType()))</span>
<span class="fc" id="L4040">                ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="fc" id="L4041">                : NoAddReason.NONE;</span>
            // Do not call super.getNoAddReason for goods because
            // the capacity test in GoodsLocation.getNoAddReason does not
            // account for packing and is thus too conservative.
        }
<span class="nc" id="L4046">        return super.getNoAddReason(locatable);</span>
    }


    // GoodsLocation
    // Inherits
    //   GoodsLocation.addGoods
    //   GoodsLocation.removeGoods

    /**
     * {@inheritDoc}
     */
    @Override
    public int getGoodsCapacity() {
<span class="nc" id="L4060">        return getCargoCapacity();</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     *
     * -vis: This routine can change player visibility.
     */
    @Override
    public void disposeResources() {
<span class="fc" id="L4073">        Location loc = getLocation();</span>
<span class="fc bfc" id="L4074" title="All 2 branches covered.">        if (loc != null) {</span>
<span class="fc" id="L4075">            loc.remove(this);</span>
            // Do not set location to null, units that are slaughtered in
            // battle need to remain valid during the animation.
        }

<span class="pc bpc" id="L4080" title="1 of 2 branches missed.">        if (teacher != null) {</span>
<span class="nc" id="L4081">            teacher.setStudent(null);</span>
<span class="nc" id="L4082">            teacher = null;</span>
        }

<span class="pc bpc" id="L4085" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="nc" id="L4086">            student.setTeacher(null);</span>
<span class="nc" id="L4087">            student = null;</span>
        }

<span class="fc" id="L4090">        setHomeIndianSettlement(null);</span>

<span class="fc" id="L4092">        getOwner().removeUnit(this);</span>

<span class="fc" id="L4094">        super.disposeResources();</span>
<span class="fc" id="L4095">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public FreeColGameObject getLinkTarget(Player player) {
<span class="nc bnc" id="L4102" title="All 2 branches missed.">        return (hasTile()) ? (FreeColGameObject)getTile().up()</span>
<span class="nc" id="L4103">            : player.getEurope();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="fc" id="L4111">        int result = super.checkIntegrity(fix);</span>
<span class="pc bpc" id="L4112" title="1 of 2 branches missed.">        if (this.role == null) {</span>
<span class="nc bnc" id="L4113" title="All 2 branches missed.">            if (fix) {</span>
<span class="nc" id="L4114">                this.role = getSpecification().getDefaultRole();</span>
<span class="nc" id="L4115">                logger.warning(&quot;Fixed missing role for: &quot; + getId());</span>
<span class="nc" id="L4116">                result = 0;</span>
<span class="nc" id="L4117">            } else {</span>
<span class="nc" id="L4118">                logger.warning(&quot;Missing role for: &quot; + getId());</span>
<span class="nc" id="L4119">                result = -1;</span>
            }
        }
<span class="pc bpc" id="L4122" title="1 of 2 branches missed.">        if (this.destination != null) {</span>
<span class="nc bnc" id="L4123" title="All 2 branches missed.">            if (!((FreeColGameObject)this.destination).isInitialized()) {</span>
<span class="nc bnc" id="L4124" title="All 2 branches missed.">                if (fix) {</span>
<span class="nc" id="L4125">                    this.destination = null;</span>
<span class="nc" id="L4126">                    logger.warning(&quot;Cleared uninitialized destination for: &quot;</span>
<span class="nc" id="L4127">                        + getId());</span>
<span class="nc" id="L4128">                    result = Math.min(result, 0);</span>
<span class="nc" id="L4129">                } else {</span>
<span class="nc" id="L4130">                    logger.warning(&quot;Uninitialized destination for: &quot;</span>
<span class="nc" id="L4131">                        + getId());</span>
<span class="nc" id="L4132">                    result = -1;</span>
                }
            }
        }
<span class="pc bpc" id="L4136" title="1 of 2 branches missed.">        if (this.state == UnitState.IMPROVING</span>
<span class="nc bnc" id="L4137" title="All 2 branches missed.">            &amp;&amp; this.workImprovement == null) {</span>
            // This can happen as a result of trying to read an invalid
            // improvement.
<span class="nc bnc" id="L4140" title="All 2 branches missed.">            if (fix) {</span>
<span class="nc" id="L4141">                this.state = UnitState.ACTIVE;</span>
<span class="nc" id="L4142">                logger.warning(&quot;Made improving unit active: &quot; + getId());</span>
<span class="nc" id="L4143">                result = Math.min(result, 0);</span>
<span class="nc" id="L4144">            } else {</span>
<span class="nc" id="L4145">                logger.warning(&quot;Improving unit with no improvement: &quot;</span>
<span class="nc" id="L4146">                    + getId());</span>
<span class="nc" id="L4147">                result = -1;</span>
            }
        }
<span class="fc" id="L4150">        return result;</span>
    }


    // Override FreeColObject

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Ability&gt; getAbilities(String id, FreeColSpecObjectType fcgot,
                                     Turn turn) {
<span class="fc" id="L4162">        final Player owner = getOwner();</span>
<span class="fc" id="L4163">        final UnitType unitType = getType();</span>
<span class="fc" id="L4164">        Set&lt;Ability&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType abilities always apply.
<span class="fc" id="L4167">        result.addAll(unitType.getAbilities(id));</span>

        // Roles apply with qualification.
<span class="fc" id="L4170">        result.addAll(role.getAbilities(id, fcgot, turn));</span>

        // The player's abilities require more qualification.
<span class="fc" id="L4173">        result.addAll(owner.getAbilities(id, fcgot, turn));</span>

        // Location abilities may apply.
        // FIXME: extend this to all locations?  May simplify
        // code.  Units are also Locations however, which complicates
        // the issue as we do not want Units aboard other Units to share
        // the abilities of the carriers.
<span class="fc bfc" id="L4180" title="All 2 branches covered.">        if (getSettlement() != null) {</span>
<span class="fc" id="L4181">            result.addAll(getSettlement().getAbilities(id, unitType, turn));</span>
<span class="fc bfc" id="L4182" title="All 2 branches covered.">        } else if (isInEurope()) {</span>
            // @compat 0.10.x
            // It makes sense here to do:
            //   Europe europe = owner.getEurope();
            // However while there is fixup code in readChildren that calls
            // this routine we can not rely on owner.europe being initialized
            // yet.  Hence the following:
<span class="fc" id="L4189">            Location loc = getLocation();</span>
<span class="fc bfc" id="L4190" title="All 2 branches covered.">            Europe europe = (loc instanceof Europe) ? (Europe)loc</span>
<span class="pc bpc" id="L4191" title="1 of 2 branches missed.">                : (loc instanceof Unit) ? (Europe)((Unit)loc).getLocation()</span>
<span class="nc" id="L4192">                : null;</span>
            // end @compat 0.10.x
<span class="fc" id="L4194">            result.addAll(europe.getAbilities(id, unitType, turn));</span>
        }
<span class="fc" id="L4196">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Modifier&gt; getModifiers(String id, FreeColSpecObjectType fcgot,
                                      Turn turn) {
<span class="fc" id="L4205">        final Player owner = getOwner();</span>
<span class="fc" id="L4206">        final UnitType unitType = getType();</span>
<span class="fc" id="L4207">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc" id="L4210">        result.addAll(unitType.getModifiers(id, fcgot, turn));</span>

        // The player's modifiers may not all apply
<span class="fc" id="L4213">        result.addAll(owner.getModifiers(id, fcgot, turn));</span>
        
        // Role modifiers apply
<span class="fc" id="L4216">        result.addAll(role.getModifiers(id, fcgot, turn));</span>

<span class="fc" id="L4218">        return result;</span>
    }


    // Serialization

    private static final String ATTRITION_TAG = &quot;attrition&quot;;
    private static final String COUNT_TAG = &quot;count&quot;;
    private static final String CURRENT_STOP_TAG = &quot;currentStop&quot;;
    private static final String DESTINATION_TAG = &quot;destination&quot;;
    private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;
    private static final String ETHNICITY_TAG = &quot;ethnicity&quot;;
    private static final String EXPERIENCE_TAG = &quot;experience&quot;;
    private static final String EXPERIENCE_TYPE_TAG = &quot;experienceType&quot;;
    private static final String HIT_POINTS_TAG = &quot;hitPoints&quot;;
    private static final String INDIAN_SETTLEMENT_TAG = &quot;indianSettlement&quot;;
    private static final String LOCATION_TAG = &quot;location&quot;;
    private static final String MOVES_LEFT_TAG = &quot;movesLeft&quot;;
    private static final String NAME_TAG = &quot;name&quot;;
    private static final String NATIONALITY_TAG = &quot;nationality&quot;;
    private static final String OWNER_TAG = &quot;owner&quot;;
    private static final String ROLE_TAG = &quot;role&quot;;
    private static final String ROLE_COUNT_TAG = &quot;roleCount&quot;;
    private static final String STATE_TAG = &quot;state&quot;;
    private static final String STUDENT_TAG = &quot;student&quot;;
    private static final String TRADE_ROUTE_TAG = &quot;tradeRoute&quot;;
    private static final String TEACHER_TAG = &quot;teacher&quot;;
    private static final String TREASURE_AMOUNT_TAG = &quot;treasureAmount&quot;;
    private static final String TURNS_OF_TRAINING_TAG = &quot;turnsOfTraining&quot;;
    private static final String UNIT_TYPE_TAG = &quot;unitType&quot;;
    private static final String VISIBLE_GOODS_COUNT_TAG = &quot;visibleGoodsCount&quot;;
    private static final String WORK_LEFT_TAG = &quot;workLeft&quot;;
    private static final String WORK_TYPE_TAG = &quot;workType&quot;;
    // @compat 0.10.5
    private static final String OLD_UNITS_TAG = &quot;units&quot;;
    // end @compat
    // @compat 0.10.7
    private static final String OLD_HIT_POINTS_TAG = &quot;hitpoints&quot;;
    private static final String EQUIPMENT_TAG = &quot;equipment&quot;;
    /** The equipment this Unit carries.  Now subsumed into roles. */
<span class="pc" id="L4258">    private final TypeCountMap&lt;EquipmentType&gt; equipment</span>
<span class="pc" id="L4259">        = new TypeCountMap&lt;&gt;();</span>
    // end @compat 0.10.x
    // @compat 0.11.3
<span class="fc" id="L4262">    private static final String OLD_TILE_IMPROVEMENT_TAG = &quot;tileimprovement&quot;;</span>
    // end @compat 0.11.3


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4271">        super.writeAttributes(xw);</span>

<span class="fc" id="L4273">        boolean full = xw.validFor(getOwner());</span>

<span class="fc bfc" id="L4275" title="All 2 branches covered.">        if (name != null) xw.writeAttribute(NAME_TAG, name);</span>

<span class="fc" id="L4277">        xw.writeAttribute(UNIT_TYPE_TAG, unitType);</span>

<span class="fc" id="L4279">        xw.writeAttribute(MOVES_LEFT_TAG, movesLeft);</span>

<span class="fc" id="L4281">        xw.writeAttribute(STATE_TAG, state);</span>

<span class="fc" id="L4283">        xw.writeAttribute(ROLE_TAG, role);</span>

<span class="fc" id="L4285">        xw.writeAttribute(ROLE_COUNT_TAG, roleCount);</span>

<span class="pc bpc" id="L4287" title="1 of 4 branches missed.">        if (!full &amp;&amp; hasAbility(Ability.PIRACY)) {</span>
            // Pirates do not disclose national characteristics.
<span class="nc" id="L4289">            xw.writeAttribute(OWNER_TAG, getGame().getUnknownEnemy());</span>

<span class="nc" id="L4291">        } else {</span>
<span class="fc" id="L4292">            xw.writeAttribute(OWNER_TAG, getOwner());</span>

<span class="fc bfc" id="L4294" title="All 2 branches covered.">            if (isPerson()) {</span>
                // Do not write out nationality and ethnicity for non-persons.
<span class="pc bpc" id="L4296" title="1 of 2 branches missed.">                xw.writeAttribute(NATIONALITY_TAG, (nationality != null)</span>
<span class="fc" id="L4297">                    ? nationality</span>
<span class="nc" id="L4298">                    : getOwner().getNationId());</span>

<span class="pc bpc" id="L4300" title="1 of 2 branches missed.">                xw.writeAttribute(ETHNICITY_TAG, (ethnicity != null)</span>
<span class="fc" id="L4301">                    ? ethnicity</span>
<span class="nc" id="L4302">                    : getOwner().getNationId());</span>
            }
        }

<span class="fc bfc" id="L4306" title="All 2 branches covered.">        if (location != null) {</span>
<span class="fc" id="L4307">            xw.writeLocationAttribute(LOCATION_TAG, location);</span>
        }

<span class="fc" id="L4310">        xw.writeAttribute(TREASURE_AMOUNT_TAG, treasureAmount);</span>

<span class="fc bfc" id="L4312" title="All 2 branches covered.">        if (full) {</span>
<span class="pc bpc" id="L4313" title="1 of 2 branches missed.">            if (entryLocation != null) {</span>
<span class="nc" id="L4314">                xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
            }

<span class="fc" id="L4317">            xw.writeAttribute(TURNS_OF_TRAINING_TAG, turnsOfTraining);</span>

<span class="fc bfc" id="L4319" title="All 2 branches covered.">            if (workType != null) xw.writeAttribute(WORK_TYPE_TAG, workType);</span>

<span class="fc bfc" id="L4321" title="All 2 branches covered.">            if (experienceType != null) {</span>
<span class="fc" id="L4322">                xw.writeAttribute(EXPERIENCE_TYPE_TAG, experienceType);</span>
            }

<span class="fc" id="L4325">            xw.writeAttribute(EXPERIENCE_TAG, experience);</span>

<span class="fc" id="L4327">            xw.writeAttribute(INDIAN_SETTLEMENT_TAG, indianSettlement);</span>

<span class="fc" id="L4329">            xw.writeAttribute(WORK_LEFT_TAG, workLeft);</span>

<span class="fc" id="L4331">            xw.writeAttribute(HIT_POINTS_TAG, hitPoints);</span>

<span class="fc" id="L4333">            xw.writeAttribute(ATTRITION_TAG, attrition);</span>

<span class="pc bpc" id="L4335" title="1 of 2 branches missed.">            if (student != null) xw.writeAttribute(STUDENT_TAG, student);</span>

<span class="pc bpc" id="L4337" title="1 of 2 branches missed.">            if (teacher != null) xw.writeAttribute(TEACHER_TAG, teacher);</span>

<span class="fc bfc" id="L4339" title="All 2 branches covered.">            if (destination != null) {</span>
<span class="fc" id="L4340">                xw.writeLocationAttribute(DESTINATION_TAG, destination);</span>
            }

<span class="pc bpc" id="L4343" title="1 of 2 branches missed.">            if (tradeRoute != null) {</span>
<span class="nc" id="L4344">                xw.writeAttribute(TRADE_ROUTE_TAG, tradeRoute);</span>

<span class="nc" id="L4346">                xw.writeAttribute(CURRENT_STOP_TAG, currentStop);</span>
            }
        }
<span class="fc" id="L4349">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc bfc" id="L4356" title="All 2 branches covered.">        if (xw.validFor(getOwner())) {</span>

            // Do not show goods or units carried by this unit.
<span class="fc" id="L4359">            super.writeChildren(xw);</span>

<span class="pc bpc" id="L4361" title="1 of 2 branches missed.">            if (workImprovement != null) workImprovement.toXML(xw);</span>

<span class="pc bfc" id="L4363" title="All 2 branches covered.">        } else if (getType().canCarryGoods()) {</span>
<span class="fc" id="L4364">            xw.writeAttribute(VISIBLE_GOODS_COUNT_TAG, getVisibleGoodsCount());</span>
        }
<span class="fc" id="L4366">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4373">        super.readAttributes(xr);</span>

<span class="fc" id="L4375">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4376">        final Game game = getGame();</span>

<span class="fc" id="L4378">        name = xr.getAttribute(NAME_TAG, (String)null);</span>

<span class="fc" id="L4380">        Player oldOwner = owner;</span>
<span class="fc" id="L4381">        owner = xr.findFreeColGameObject(game, OWNER_TAG,</span>
<span class="fc" id="L4382">                                         Player.class, (Player)null, true);</span>
<span class="fc bfc" id="L4383" title="All 2 branches covered.">        if (xr.shouldIntern()) game.checkOwners(this, oldOwner);</span>

<span class="fc" id="L4385">        UnitType oldUnitType = unitType;</span>
<span class="fc" id="L4386">        unitType = xr.getType(spec, UNIT_TYPE_TAG,</span>
<span class="fc" id="L4387">                              UnitType.class, (UnitType)null);</span>

<span class="fc" id="L4389">        state = xr.getAttribute(STATE_TAG, UnitState.class, UnitState.ACTIVE);</span>

<span class="fc" id="L4391">        role = xr.getRole(spec, ROLE_TAG, Role.class,</span>
<span class="fc" id="L4392">                          spec.getDefaultRole());</span>
        // @compat 0.10.x
        // Fix roles
<span class="fc bfc" id="L4395" title="All 2 branches covered.">        if (owner.isIndian()) {</span>
<span class="pc bpc" id="L4396" title="1 of 2 branches missed.">            if (&quot;model.role.scout&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4397">                role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="pc bpc" id="L4398" title="1 of 2 branches missed.">            } else if (&quot;model.role.soldier&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4399">                role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="pc bpc" id="L4400" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4401">                role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
            }
<span class="pc bfc" id="L4403" title="All 2 branches covered.">        } else if (owner.isREF()) {</span>
<span class="pc bpc" id="L4404" title="1 of 2 branches missed.">            if (&quot;model.role.soldier&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4406">                role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="pc bpc" id="L4407" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4408" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4409">                role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="pc bpc" id="L4410" title="1 of 2 branches missed.">            } else if (&quot;model.role.infantry&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4411" title="All 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4412">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bpc" id="L4413" title="1 of 2 branches missed.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())</span>
<span class="pc bpc" id="L4414" title="1 of 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4415">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
<span class="nc" id="L4417">        } else {</span>
<span class="pc bpc" id="L4418" title="1 of 2 branches missed.">            if (&quot;model.role.infantry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4419">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bfc" id="L4420" title="All 2 branches covered.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())) {</span>
<span class="fc" id="L4421">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
        }            
        // end @compat 0.10.x

<span class="fc" id="L4426">        roleCount = xr.getAttribute(ROLE_COUNT_TAG,</span>
            // @compat 0.10.x
<span class="fc" id="L4428">            -1</span>
            // Should be role.getMaximumCount()
            // end @compat 0.10.x
            );

<span class="fc" id="L4433">        setLocationNoUpdate(xr.getLocationAttribute(game, LOCATION_TAG, true));</span>

<span class="fc" id="L4435">        entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG,</span>
<span class="fc" id="L4436">                                                true);</span>

<span class="fc" id="L4438">        movesLeft = xr.getAttribute(MOVES_LEFT_TAG, 0);</span>

<span class="fc" id="L4440">        workLeft = xr.getAttribute(WORK_LEFT_TAG, 0);</span>

<span class="fc" id="L4442">        attrition = xr.getAttribute(ATTRITION_TAG, 0);</span>

<span class="fc" id="L4444">        nationality = xr.getAttribute(NATIONALITY_TAG, (String)null);</span>

<span class="fc" id="L4446">        ethnicity = xr.getAttribute(ETHNICITY_TAG, (String)null);</span>

<span class="fc" id="L4448">        turnsOfTraining = xr.getAttribute(TURNS_OF_TRAINING_TAG, 0);</span>

<span class="fc" id="L4450">        hitPoints = xr.getAttribute(HIT_POINTS_TAG, -1);</span>
        // @compat 0.10.7
<span class="pc bpc" id="L4452" title="1 of 2 branches missed.">        if (hitPoints &lt; 0) hitPoints = xr.getAttribute(OLD_HIT_POINTS_TAG, -1);</span>
        // end @compat

<span class="fc" id="L4455">        teacher = xr.makeFreeColGameObject(game, TEACHER_TAG,</span>
<span class="fc" id="L4456">                                           Unit.class, false);</span>

<span class="fc" id="L4458">        student = xr.makeFreeColGameObject(game, STUDENT_TAG,</span>
<span class="fc" id="L4459">                                           Unit.class, false);</span>

<span class="fc" id="L4461">        setHomeIndianSettlement(xr.makeFreeColGameObject(game,</span>
<span class="fc" id="L4462">                INDIAN_SETTLEMENT_TAG, IndianSettlement.class, false));</span>

<span class="fc" id="L4464">        treasureAmount = xr.getAttribute(TREASURE_AMOUNT_TAG, 0);</span>

<span class="fc" id="L4466">        destination = xr.getLocationAttribute(game, DESTINATION_TAG, true);</span>

<span class="fc" id="L4468">        tradeRoute = xr.findFreeColGameObject(game, TRADE_ROUTE_TAG,</span>
<span class="fc" id="L4469">            TradeRoute.class, (TradeRoute)null, false);</span>

<span class="pc bpc" id="L4471" title="1 of 2 branches missed.">        currentStop = (tradeRoute == null) ? -1</span>
<span class="nc" id="L4472">            : xr.getAttribute(CURRENT_STOP_TAG, 0);</span>

<span class="fc" id="L4474">        experienceType = xr.getType(spec, EXPERIENCE_TYPE_TAG,</span>
<span class="fc" id="L4475">                                    GoodsType.class, (GoodsType)null);</span>
<span class="pc bpc" id="L4476" title="1 of 4 branches missed.">        if (experienceType == null &amp;&amp; workType != null) {</span>
<span class="nc" id="L4477">            experienceType = workType;</span>
        }

<span class="fc" id="L4480">        experience = xr.getAttribute(EXPERIENCE_TAG, 0);</span>

<span class="fc" id="L4482">        visibleGoodsCount = xr.getAttribute(VISIBLE_GOODS_COUNT_TAG, -1);</span>

        // Make sure you do this after experience and location stuff.
<span class="fc" id="L4485">        changeWorkType(xr.getType(spec, WORK_TYPE_TAG, GoodsType.class, null));</span>
<span class="fc" id="L4486">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // Clear containers.
<span class="pc bpc" id="L4494" title="1 of 2 branches missed.">        if (getGoodsContainer() != null) getGoodsContainer().removeAll();</span>
<span class="fc" id="L4495">        equipment.clear();</span>
<span class="fc" id="L4496">        workImprovement = null;</span>

<span class="fc" id="L4498">        super.readChildren(xr);</span>

        // @compat 0.10.x
<span class="fc bfc" id="L4501" title="All 2 branches covered.">        if (roleCount &lt; 0) {</span>
            // If roleCount was not present, set it from equipment
<span class="fc" id="L4503">            final Specification spec = getSpecification();</span>
<span class="fc" id="L4504">            Role role = spec.getDefaultRole();</span>
<span class="fc" id="L4505">            boolean horses = false, muskets = false;</span>
<span class="fc" id="L4506">            int count = 1;</span>
<span class="pc bpc" id="L4507" title="1 of 2 branches missed.">            for (EquipmentType type : equipment.keySet()) {</span>
<span class="nc bnc" id="L4508" title="All 2 branches missed.">                if (&quot;model.equipment.horses&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4509" title="All 2 branches missed.">                    || &quot;model.equipment.indian.horses&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4510">                    horses = true;</span>
<span class="nc bnc" id="L4511" title="All 2 branches missed.">                } else if (&quot;model.equipment.muskets&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4512" title="All 2 branches missed.">                    || &quot;model.equipment.indian.muskets&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4513">                    muskets = true;</span>
<span class="nc" id="L4514">                } else {</span>
<span class="nc" id="L4515">                    role = type.getRole();</span>
<span class="nc bnc" id="L4516" title="All 2 branches missed.">                    if (&quot;model.equipment.tools&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4517">                        count = equipment.getCount(type);</span>
                    }
                }
            }
<span class="pc bpc" id="L4521" title="3 of 4 branches missed.">            if (horses &amp;&amp; muskets) {</span>
<span class="nc bnc" id="L4522" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4523">                    role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
<span class="nc bnc" id="L4524" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4525">                    role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="nc" id="L4526">                } else {</span>
<span class="nc" id="L4527">                    role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
                }
<span class="pc bpc" id="L4529" title="1 of 2 branches missed.">            } else if (horses) {</span>
<span class="nc bnc" id="L4530" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4531">                    role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4532" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4533">                    logger.warning(&quot;Undefined role: REF Scout&quot;);</span>
<span class="nc" id="L4534">                } else {</span>
<span class="nc" id="L4535">                    role = spec.getRole(&quot;model.role.scout&quot;);</span>
                }
<span class="pc bpc" id="L4537" title="1 of 2 branches missed.">            } else if (muskets) {</span>
<span class="nc bnc" id="L4538" title="All 2 branches missed.">                if (owner.isIndian()) {</span>
<span class="nc" id="L4539">                    role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4540" title="All 4 branches missed.">                } else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4541">                    role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="nc" id="L4542">                } else {</span>
<span class="nc" id="L4543">                    role = spec.getRole(&quot;model.role.soldier&quot;);</span>
                }
            }
<span class="fc" id="L4546">            setRoleCount(Math.min(role.getMaximumCount(), count));</span>
<span class="fc" id="L4547">        } else {</span>
            // If roleCount was present, we are now ignoring equipment.
<span class="fc" id="L4549">            equipment.clear();</span>
        }
        // end @compat 0.10.x

        // @compat 0.10.x
        // There was a bug in 0.10.x that did not clear tile
        // improvements after they were complete, leading to units
        // that still had a tile improvement after they had moved
        // away.  Consequently when reading such bogus improvements,
        // there is no guarantee that the tile is defined so
        // compatibility code in TileImprovement.readAttributes
        // tolerates null tile references.  These are obviously bogus,
        // so drop them.
<span class="pc bpc" id="L4562" title="3 of 4 branches missed.">        if (workImprovement != null &amp;&amp; workImprovement.getTile() == null) {</span>
<span class="nc" id="L4563">            workImprovement = null;</span>
        }
        // end @compat 0.10.x
<span class="fc" id="L4566">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4573">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4574">        final Game game = getGame();</span>
<span class="fc" id="L4575">        final String tag = xr.getLocalName();</span>

        // @compat 0.10.x
<span class="pc bpc" id="L4578" title="1 of 2 branches missed.">        if (EQUIPMENT_TAG.equals(tag)) {</span>
<span class="nc" id="L4579">            equipment.incrementCount(spec.getEquipmentType(xr.readId()),</span>
<span class="nc" id="L4580">                                     xr.getAttribute(COUNT_TAG, 0));</span>
<span class="nc" id="L4581">            xr.closeTag(EQUIPMENT_TAG);</span>
        // end @compat 0.10.x

        // @compat 0.10.5
<span class="pc bpc" id="L4585" title="1 of 2 branches missed.">        } else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="nc bnc" id="L4586" title="All 2 branches missed.">            while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L4587">                super.readChild(xr);</span>
            }
        // end @compat 0.10.5

<span class="pc bpc" id="L4591" title="1 of 2 branches missed.">        } else if (TileImprovement.getTagName().equals(tag)</span>
                   // @compat 0.11.3
<span class="pc bpc" id="L4593" title="1 of 2 branches missed.">                   || OLD_TILE_IMPROVEMENT_TAG.equals(tag)</span>
                   // end @compat 0.11.3
                   ) {
<span class="nc" id="L4596">            workImprovement = xr.readFreeColGameObject(game,</span>
<span class="nc" id="L4597">                                                       TileImprovement.class);</span>

<span class="nc" id="L4599">        } else {</span>
<span class="fc" id="L4600">            super.readChild(xr);</span>
        }
<span class="fc" id="L4602">    }</span>

    /**
     * Gets a string representation of this unit.
     *
     * @param prefix A prefix (e.g. &quot;AIUnit&quot;)
     * @return A string representation of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public String toString(String prefix) {
<span class="fc" id="L4611">        StringBuilder sb = new StringBuilder(64);</span>
<span class="fc" id="L4612">        sb.append(&quot;[&quot;).append(prefix).append(getId());</span>
<span class="pc bpc" id="L4613" title="1 of 2 branches missed.">        if (!isInitialized()) {</span>
<span class="nc" id="L4614">            sb.append(&quot; uninitialized&quot;);</span>
<span class="pc bpc" id="L4615" title="1 of 2 branches missed.">        } else if (isDisposed()) {</span>
<span class="nc" id="L4616">            sb.append(&quot; disposed&quot;);</span>
<span class="nc" id="L4617">        } else {</span>
<span class="fc" id="L4618">            sb.append(&quot; &quot;).append(lastPart(owner.getNationId(), &quot;.&quot;))</span>
<span class="fc" id="L4619">                .append(&quot; &quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L4620" title="All 2 branches covered.">            if (!hasDefaultRole()) {</span>
<span class="fc" id="L4621">                sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L4622">                int count = getRoleCount();</span>
<span class="pc bpc" id="L4623" title="1 of 2 branches missed.">                if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
            }
<span class="fc" id="L4625">            sb.append(&quot; &quot;).append(getMovesAsString());</span>
        }
<span class="fc" id="L4627">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L4628">        return sb.toString();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="fc" id="L4636">        return toString(&quot;&quot;);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
<span class="fc" id="L4643">    public String getXMLTagName() { return getTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;unit&quot;
     */
    public static String getTagName() {
<span class="fc" id="L4651">        return &quot;unit&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>