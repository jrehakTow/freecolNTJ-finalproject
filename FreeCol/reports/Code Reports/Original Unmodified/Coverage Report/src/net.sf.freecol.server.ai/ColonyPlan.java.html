<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ColonyPlan.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (May 7, 2016 6:04:12 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.ai</a> &gt; <span class="el_source">ColonyPlan.java</span></div><h1>ColonyPlan.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.ai;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.ToIntFunction;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.AbstractGoods;
import net.sf.freecol.common.model.BuildableType;
import net.sf.freecol.common.model.BuildingType;
import net.sf.freecol.common.model.Colony;
import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.GoodsContainer;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.Market;
import net.sf.freecol.common.model.Modifier;
import net.sf.freecol.common.model.NationType;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Role;
import net.sf.freecol.common.model.Scope;
import net.sf.freecol.common.model.Specification;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.UnitType;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import net.sf.freecol.common.model.WorkLocation;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;


/**
 * Objects of this class describes the plan the AI has for a
 * &lt;code&gt;Colony&lt;/code&gt;.
 *
 * A &lt;code&gt;ColonyPlan&lt;/code&gt; contains a list of
 * {@link WorkLocationPlan}s which suggests the food and non-food
 * production of each {@link WorkLocation}, and a list of
 * {@link BuildableType}s to build.  It takes account of the available
 * tiles and building production, but does not make decisions to claim
 * tiles or change the current buildable.  It does takes account of
 * goods present in the colony, and overall colony size but not the
 * exact composition of the units involved.  However there is
 * extensive structure for making a trial assignment of workers in
 * {@link #assignWorkers}.
 *
 * {@link AIColony#rearrangeWorkers} is responsible for making
 * the real decisions.
 *
 * @see Colony
 */
public class ColonyPlan {

<span class="fc" id="L80">    private static final Logger logger = Logger.getLogger(ColonyPlan.class.getName());</span>

    /** The things to build, and their priority. */
    private static class BuildPlan {

        public final BuildableType type;
        public double weight;
        public double support;
        public double difficulty;

<span class="fc" id="L90">        public BuildPlan(BuildableType type, double weight, double support) {</span>
<span class="fc" id="L91">            this.type = type;</span>
<span class="fc" id="L92">            this.weight = weight;</span>
<span class="fc" id="L93">            this.support = support;</span>
<span class="fc" id="L94">            this.difficulty = 1.0f;</span>
<span class="fc" id="L95">        }</span>

        public double getValue() {
<span class="fc" id="L98">            return weight * support / difficulty;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L106">            return String.format(&quot;%s (%1.3f * %1.3f / %1.3f = %1.3f)&quot;,</span>
<span class="nc" id="L107">                                 type.getSuffix(), weight, support,</span>
<span class="nc" id="L108">                                 difficulty, getValue());</span>
        }
    };

    /** Comparator to sort buildable by descending value. */
<span class="fc" id="L113">    private static final Comparator&lt;BuildPlan&gt; buildPlanComparator</span>
<span class="fc" id="L114">        = Comparator.comparingDouble(BuildPlan::getValue).reversed();</span>

    /** Require production plans to always produce an amount exceeding this. */
    private static final int LOW_PRODUCTION_THRESHOLD = 1;

    /**
     * Number of turns to require production of without exhausting the
     * input goods.
     */
    private static final int PRODUCTION_TURNOVER_TURNS = 5;

    /** The profile of the colony (a sort of general flavour). */
<span class="fc" id="L126">    private static enum ProfileType {</span>
<span class="fc" id="L127">        OUTPOST,</span>
<span class="fc" id="L128">        SMALL,</span>
<span class="fc" id="L129">        MEDIUM,</span>
<span class="fc" id="L130">        LARGE,</span>
<span class="fc" id="L131">        CAPITAL;</span>

        /**
         * Chooses a suitable profile type given a size of colony.
         *
         * @param size A proposed colony size.
         * @return The colony profile type.
         */
        public static ProfileType getProfileTypeFromSize(int size) {
<span class="fc bfc" id="L140" title="All 2 branches covered.">            return (size &lt;= 1) ? ProfileType.OUTPOST</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">                : (size &lt;= 2) ? ProfileType.SMALL</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">                : (size &lt;= 4) ? ProfileType.MEDIUM</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                : (size &lt;= 8) ? ProfileType.LARGE</span>
<span class="nc" id="L144">                : ProfileType.CAPITAL;</span>
        }
    };
    private ProfileType profileType;

    /** Private copy of the AIMain. */
    private final AIMain aiMain;

    /** The colony this AIColony manages. */
    private final Colony colony;

 
<span class="fc" id="L156">   private final List&lt;BuildPlan&gt; buildPlans = new ArrayList&lt;&gt;();</span>

    /** Plans for work locations available to this colony. */
<span class="fc" id="L159">    private final List&lt;WorkLocationPlan&gt; workPlans = new ArrayList&lt;&gt;();</span>

    /** The goods types to produce. */
<span class="fc" id="L162">    private final List&lt;GoodsType&gt; produce = new ArrayList&lt;&gt;();</span>

    /**
     * Lists of goods types to be produced in this colony.
     * Temporary variables that do not need to be serialized.
     */
<span class="fc" id="L168">    private final List&lt;GoodsType&gt; foodGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L169">    private final List&lt;GoodsType&gt; libertyGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L170">    private final List&lt;GoodsType&gt; immigrationGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L171">    private final List&lt;GoodsType&gt; militaryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L172">    private final List&lt;GoodsType&gt; rawBuildingGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L173">    private final List&lt;GoodsType&gt; buildingGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L174">    private final List&lt;GoodsType&gt; rawLuxuryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L175">    private final List&lt;GoodsType&gt; luxuryGoodsTypes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L176">    private final List&lt;GoodsType&gt; otherRawGoodsTypes = new ArrayList&lt;&gt;();</span>


    /**
     * Creates a new &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @param aiMain The main AI-object.
     * @param colony The colony to make a &lt;code&gt;ColonyPlan&lt;/code&gt; for.
     */
<span class="fc" id="L185">    public ColonyPlan(AIMain aiMain, Colony colony) {</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (aiMain == null) throw new IllegalArgumentException(&quot;Null AIMain&quot;);</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (colony == null) throw new IllegalArgumentException(&quot;Null colony&quot;);</span>

<span class="fc" id="L189">        this.aiMain = aiMain;</span>
<span class="fc" id="L190">        this.colony = colony;</span>
<span class="fc" id="L191">        this.profileType = ProfileType</span>
<span class="fc" id="L192">            .getProfileTypeFromSize(colony.getUnitCount());</span>
<span class="fc" id="L193">    }</span>


    /**
     * Gets the main AI-object.
     *
     * @return The main AI-object.
     */
    private AIMain getAIMain() {
<span class="fc" id="L202">        return aiMain;</span>
    }

    /**
     * Gets the specification.
     *
     * @return The specification.
     */
    private Specification spec() {
<span class="fc" id="L211">        return aiMain.getGame().getSpecification();</span>
    }


    // Public functionality.

    /**
     * Gets the preferred goods to produce.
     *
     * @return A copy of the preferred goods production list in this plan.
     */
    public List&lt;GoodsType&gt; getPreferredProduction() {
<span class="fc" id="L223">        return new ArrayList&lt;&gt;(produce);</span>
    }

    /**
     * Gets a copy of the current list of buildable types associated
     * with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A copy of the of &lt;code&gt;BuildableType&lt;/code&gt;s list.
     */
    public List&lt;BuildableType&gt; getBuildableTypes() {
<span class="fc" id="L233">        return toList(map(buildPlans, bp -&gt; bp.type));</span>
    }

    /**
     * Gets the best buildable type from this plan that can currently
     * be built by the colony.
     *
     * @return The best current &lt;code&gt;BuildableType&lt;/code&gt;.
     */
    public BuildableType getBestBuildableType() {
<span class="fc" id="L243">        BuildPlan bp = find(buildPlans, p -&gt; colony.canBuild(p.type));</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        return (bp == null) ? null : bp.type;</span>
    }

    /**
     * Get a report on the build plans.
     *
     * @return A build plan report.
     */
    public String getBuildableReport() {
<span class="nc" id="L253">        LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L254">        lb.add(&quot;Buildables:\n&quot;);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        for (BuildPlan b : buildPlans) lb.add(b, &quot;\n&quot;);</span>
<span class="nc" id="L256">        return lb.toString();</span>
    }

    /**
     * Gets the food-producing and non-autoproducing work location
     * plans associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A list of food producing plans.
     */
    public List&lt;WorkLocationPlan&gt; getFoodPlans() {
<span class="fc" id="L266">        return transform(workPlans,</span>
<span class="pc bpc" id="L267" title="1 of 4 branches missed.">            wp -&gt; wp.isFoodPlan() &amp;&amp; !wp.getWorkLocation().canAutoProduce(),</span>
<span class="fc" id="L268">            Collectors.toList());</span>
    }

    /**
     * Gets the non-food-producing/non-autoproducing work location
     * plans associated with this &lt;code&gt;ColonyPlan&lt;/code&gt;.
     *
     * @return A list of non-food producing plans.
     */
    public List&lt;WorkLocationPlan&gt; getWorkPlans() {
<span class="fc" id="L278">        return transform(workPlans,</span>
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">            wp -&gt; !wp.isFoodPlan() &amp;&amp; !wp.getWorkLocation().canAutoProduce(),</span>
<span class="fc" id="L280">            Collectors.toList());</span>
    }

    /**
     * Refines this plan given the colony choice of what to build.
     *
     * @param build The &lt;code&gt;BuildableType&lt;/code&gt; to be built (may be null).
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     */
    public void refine(BuildableType build, LogBuilder lb) {
<span class="fc" id="L290">        List&lt;GoodsType&gt; required = toList(map(colony.getFullRequiredGoods(build), AbstractGoods::getType));</span>
<span class="fc" id="L291">        Map&lt;GoodsType, List&lt;WorkLocationPlan&gt;&gt; suppressed = new HashMap&lt;&gt;();</span>

        // Examine a copy of the work plans, but operate on the
        // original list.  Maintain a offset between the index in the
        // copied list and the original to aid reinsertion.
        //
        // Remove any work plans to make raw/building goods that are
        // not required to complete the current buildable, but take
        // care to put such plans back again if a plan is encountered
        // that makes goods that are made from a type that was removed
        // and there is less than CARGO_SIZE/2 of that type in stock.
        // Note though in such cases the position of the
        // building-goods plans in the work plans list will have moved
        // from their usual high priority to immediately before the
        // position of the manufactured goods.
        //
        // So, for example, we should suppress tool building when a
        // colony is building a warehouse, unless we find a plan to
        // make muskets and the tool stock is low.
        //
        // FIXME: generalize this further to make tools for pioneers.
        //
<span class="fc" id="L313">        List&lt;WorkLocationPlan&gt; plans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L314">        int offset = 0;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">        for (int i = 0; i &lt; plans.size(); i++) {</span>
            List&lt;WorkLocationPlan&gt; wls;
<span class="fc" id="L317">            WorkLocationPlan wlp = plans.get(i);</span>
<span class="fc" id="L318">            GoodsType g = wlp.getGoodsType();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            if ((rawBuildingGoodsTypes.contains(g)</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">                    &amp;&amp; !required.contains(g.getOutputType()))</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">                || (buildingGoodsTypes.contains(g)</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                    &amp;&amp; !required.contains(g))) {</span>
<span class="fc" id="L323">                workPlans.remove(i - offset);</span>
<span class="fc" id="L324">                offset++;</span>
<span class="fc" id="L325">                wls = suppressed.get(g);</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">                if (wls == null) wls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L327">                wls.add(0, wlp); // reverses list</span>
<span class="fc" id="L328">                suppressed.put(g, wls);</span>
<span class="fc" id="L329">                produce.remove(g);</span>
<span class="fc" id="L330">                lb.add(&quot;, suppress production of &quot;, g);</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            } else if (g.isRefined()</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                &amp;&amp; (rawBuildingGoodsTypes.contains(g.getInputType())</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                    || buildingGoodsTypes.contains(g.getInputType()))) {</span>
<span class="fc" id="L334">                int n = 0, idx = produce.indexOf(g);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">                for (GoodsType type = g.getInputType(); type != null;</span>
<span class="nc" id="L336">                     type = type.getInputType()) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                    if ((wls = suppressed.get(type)) == null) break;</span>
<span class="nc" id="L338">                    if (colony.getGoodsCount(type)</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                        &gt;= GoodsContainer.CARGO_SIZE/2) break;</span>
<span class="nc" id="L340">                    n += wls.size();</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    while (!wls.isEmpty()) {</span>
                        // reverses again when adding, cancelling reversal above
<span class="nc" id="L343">                        workPlans.add(i - offset, wls.remove(0));</span>
                    }
<span class="nc" id="L345">                    produce.add(idx, type);</span>
<span class="nc" id="L346">                    lb.add(&quot;, restore production of &quot;, type);</span>
                }
<span class="fc" id="L348">                offset -= n;</span>
            }
        }
<span class="fc" id="L351">    }</span>

    /**
     * Recreates the buildables and work location plans for this
     * colony.
     */
    public void update() {
        // Update the profile type.
<span class="fc" id="L359">        profileType = ProfileType.getProfileTypeFromSize(colony.getUnitCount());</span>

        // Build the total map of all possible production with standard units.
<span class="fc" id="L362">        Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production</span>
<span class="fc" id="L363">            = createProductionMap();</span>

        // Set the goods type lists, and prune production of manufactured
        // goods that are missing raw materials and other non-interesting.
<span class="fc" id="L367">        updateGoodsTypeLists(production);</span>

        // Set the preferred raw materials.  Prune production and
        // goods lists further removing the non-preferred new world
        // raw and refined materials.
<span class="fc" id="L372">        updateRawMaterials(production);</span>

        // The buildables depend on the profile type, the goods type lists
        // and/or goods-to-produce list.
<span class="fc" id="L376">        updateBuildableTypes();</span>

        // Make plans for each valid &lt;goods, location&gt; production and
        // complete the list of goods to produce.
<span class="fc" id="L380">        updatePlans(production);</span>
<span class="fc" id="L381">    }</span>


    // Internals

    /**
     * Creates a map of potential production of all goods types
     * from all available work locations using the default unit type.
     * Includes non-workable locations (e.g. chapel, colony-center-tile)
     * as their production can influence the choice of goods to produce.
     *
     * @return The map of potential production.
     */
    private Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; createProductionMap() {
<span class="fc" id="L395">        Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        for (WorkLocation wl : colony.getAvailableWorkLocations()) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc" id="L398">                int p = wl.getGenericPotential(g);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">                if (p &gt; 0) {</span>
<span class="fc" id="L400">                    Map&lt;WorkLocation, Integer&gt; m = production.get(g);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">                    if (m == null) {</span>
<span class="fc" id="L402">                        m = new HashMap&lt;&gt;();</span>
<span class="fc" id="L403">                        production.put(g, m);</span>
                    }
<span class="fc" id="L405">                    m.put(wl, p);</span>
                }
            }
        }
<span class="fc" id="L409">        return production;</span>
    }

    /**
     * Updates the goods type lists.  The categories are:&lt;UL&gt;
     * &lt;LI&gt;food&lt;/LI&gt;
     * &lt;LI&gt;liberty&lt;/LI&gt;
     * &lt;LI&gt;immigration&lt;/LI&gt;
     * &lt;LI&gt;military&lt;/LI&gt;
     * &lt;LI&gt;raw building&lt;/LI&gt;
     * &lt;LI&gt;building&lt;/LI&gt;
     * &lt;LI&gt;raw luxury&lt;/LI&gt;
     * &lt;LI&gt;luxury&lt;/LI&gt;
     * &lt;LI&gt;raw other&lt;/LI&gt;
     * &lt;/UL&gt;
     *
     * Ignore raw materials which can not be refined and refined goods
     * that have no raw materials available.  Also ignore other goods
     * that do not fit these categories (e.g. trade goods).
     *
     * @param production The production map.
     */
    private void updateGoodsTypeLists(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L432">        foodGoodsTypes.clear();</span>
<span class="fc" id="L433">        libertyGoodsTypes.clear();</span>
<span class="fc" id="L434">        immigrationGoodsTypes.clear();</span>
<span class="fc" id="L435">        militaryGoodsTypes.clear();</span>
<span class="fc" id="L436">        rawBuildingGoodsTypes.clear();</span>
<span class="fc" id="L437">        buildingGoodsTypes.clear();</span>
<span class="fc" id="L438">        rawLuxuryGoodsTypes.clear();</span>
<span class="fc" id="L439">        luxuryGoodsTypes.clear();</span>
<span class="fc" id="L440">        otherRawGoodsTypes.clear();</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">        for (GoodsType g : new ArrayList&lt;&gt;(production.keySet())) {</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (g.isFoodType()) {</span>
<span class="fc" id="L443">                foodGoodsTypes.add(g);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">            } else if (g.isLibertyType()) {</span>
<span class="fc" id="L445">                libertyGoodsTypes.add(g);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">            } else if (g.isImmigrationType()) {</span>
<span class="nc" id="L447">                immigrationGoodsTypes.add(g);</span>
<span class="pc bfc" id="L448" title="All 2 branches covered.">            } else if (g.isMilitaryGoods()) {</span>
<span class="fc" id="L449">                militaryGoodsTypes.add(g);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            } else if (g.isRawBuildingMaterial()) {</span>
<span class="fc" id="L451">                rawBuildingGoodsTypes.add(g);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">            } else if (g.isBuildingMaterial()</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">                &amp;&amp; g.getInputType().isRawBuildingMaterial()) {</span>
<span class="fc" id="L454">                buildingGoodsTypes.add(g);</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">            } else if (g.isNewWorldGoodsType()) {</span>
<span class="fc" id="L456">                rawLuxuryGoodsTypes.add(g);</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">            } else if (g.isRefined()</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">                &amp;&amp; g.getInputType().isNewWorldGoodsType()) {</span>
<span class="fc" id="L459">                luxuryGoodsTypes.add(g);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">            } else if (g.isFarmed()) {</span>
<span class="fc" id="L461">                otherRawGoodsTypes.add(g);</span>
<span class="fc" id="L462">            } else { // Not interested in this goods type.  Should not happen.</span>
<span class="nc" id="L463">                logger.warning(&quot;Ignoring goods type &quot; + g</span>
<span class="nc" id="L464">                    + &quot; at &quot; + colony.getName());</span>
<span class="nc" id="L465">                production.remove(g);</span>
            }
        }
<span class="fc" id="L468">    }</span>

    /**
     * Chooses the two best raw materials, updating the production
     * map and lists.
     *
     * FIXME: scale with colony size.
     *
     * @param production The production map.
     */
    private void updateRawMaterials(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L479">        Player player = colony.getOwner();</span>
<span class="fc" id="L480">        Market market = player.getMarket();</span>
<span class="fc" id="L481">        NationType nationType = player.getNationType();</span>
<span class="fc" id="L482">        GoodsType primaryRawMaterial = null;</span>
<span class="fc" id="L483">        GoodsType secondaryRawMaterial = null;</span>
<span class="fc" id="L484">        int primaryValue = -1;</span>
<span class="fc" id="L485">        int secondaryValue = -1;</span>

<span class="fc" id="L487">        produce.clear();</span>
<span class="fc" id="L488">        List&lt;GoodsType&gt; rawMaterials = new ArrayList&lt;&gt;(rawLuxuryGoodsTypes);</span>
<span class="fc" id="L489">        rawMaterials.addAll(otherRawGoodsTypes);</span>
<span class="fc bfc" id="L490" title="All 2 branches covered.">        for (GoodsType g : rawMaterials) {</span>
<span class="fc" id="L491">            int value = sum(production.get(g).entrySet(), Entry::getValue);</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">            if (value &lt;= LOW_PRODUCTION_THRESHOLD) {</span>
<span class="fc" id="L493">                production.remove(g);</span>
<span class="fc" id="L494">                continue;</span>
            }
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">            if (market != null) {</span>
                // If the market is available, weight by sale price of
                // the material, or if it is the raw material for a
                // refined goods type, the average of the raw and
                // refined goods prices.
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">                if (g.getOutputType() == null) {</span>
<span class="nc" id="L502">                    value *= market.getSalePrice(g, 1);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">                } else if (production.containsKey(g.getOutputType())) {</span>
<span class="fc" id="L504">                    value *= (market.getSalePrice(g, 1)</span>
<span class="fc" id="L505">                        + market.getSalePrice(g.getOutputType(), 1)) / 2;</span>
                }
            }
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">            if (nationType.hasModifier(g.getId())) {</span>
<span class="nc" id="L509">                value = (value * 12) / 10; // Bonus for national advantages</span>
            }
<span class="pc bpc" id="L511" title="2 of 4 branches missed.">            if (value &gt; secondaryValue &amp;&amp; secondaryRawMaterial != null) {</span>
<span class="nc" id="L512">                production.remove(secondaryRawMaterial);</span>
<span class="nc" id="L513">                production.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (rawLuxuryGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L515">                    rawLuxuryGoodsTypes.remove(secondaryRawMaterial);</span>
<span class="nc" id="L516">                    luxuryGoodsTypes.remove(secondaryRawMaterial.getOutputType());</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                } else if (otherRawGoodsTypes.contains(secondaryRawMaterial)) {</span>
<span class="nc" id="L518">                    otherRawGoodsTypes.remove(secondaryRawMaterial);</span>
                }
            }
<span class="fc bfc" id="L521" title="All 2 branches covered.">            if (value &gt; primaryValue) {</span>
<span class="fc" id="L522">                secondaryRawMaterial = primaryRawMaterial;</span>
<span class="fc" id="L523">                secondaryValue = primaryValue;</span>
<span class="fc" id="L524">                primaryRawMaterial = g;</span>
<span class="fc" id="L525">                primaryValue = value;</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">            } else if (value &gt; secondaryValue) {</span>
<span class="fc" id="L527">                secondaryRawMaterial = g;</span>
<span class="fc" id="L528">                secondaryValue = value;</span>
            }
        }
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (primaryRawMaterial != null) {</span>
<span class="fc" id="L532">            produce.add(primaryRawMaterial);</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">            if (primaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L534">                produce.add(primaryRawMaterial.getOutputType());</span>
            }
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (secondaryRawMaterial != null) {</span>
<span class="fc" id="L537">                produce.add(secondaryRawMaterial);</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">                if (secondaryRawMaterial.getOutputType() != null) {</span>
<span class="fc" id="L539">                    produce.add(secondaryRawMaterial.getOutputType());</span>
                }
            }
        }
<span class="fc" id="L543">    }</span>


    // Relative weights of the various building categories.
    // FIXME: split out/parameterize into a &quot;building strategy&quot;
    //
    // BuildableTypes that improve breeding.
    private static final double BREEDING_WEIGHT    = 0.1;
    // BuildableTypes that improve building production.
    private static final double BUILDING_WEIGHT    = 0.9;
    // BuildableTypes that produce defensive units.
    private static final double DEFENCE_WEIGHT     = 0.1;
    // BuildableTypes that provide export ability.
    private static final double EXPORT_WEIGHT      = 0.6;
    // BuildableTypes that allow water to be used.
    private static final double FISH_WEIGHT        = 0.25;
    // BuildableTypes that improve the colony fortifications.
    private static final double FORTIFY_WEIGHT     = 0.3;
    // BuildableTypes that improve immigration production.
    private static final double IMMIGRATION_WEIGHT = 0.05;
    // BuildableTypes that improve liberty production.
    private static final double LIBERTY_WEIGHT     = 0.75;
    // BuildableTypes that improve military goods production.
    private static final double MILITARY_WEIGHT    = 0.4;
    // BuildableTypes that improve luxury goods production.
    private static final double PRODUCTION_WEIGHT  = 0.25;
    // BuildableTypes that improve colony storage.
    private static final double REPAIR_WEIGHT      = 0.1;
    // BuildableTypes that improve colony storage.
    private static final double STORAGE_WEIGHT     = 0.85;
    // BuildableTypes that improve education.
    private static final double TEACH_WEIGHT       = 0.2;
    // BuildableTypes that improve transport.
<span class="fc" id="L576">    private static final double TRANSPORT_WEIGHT   = 0.15;</span>

    /**
     * Finds a build plan for this type.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to search for.
     * @return A &lt;code&gt;BuildPlan&lt;/code&gt; with this type, or null if not found.
     */
    private BuildPlan findBuildPlan(BuildableType type) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        return find(buildPlans, bp -&gt; bp.type == type);</span>
    }

    /**
     * Adds or improves the priority of a buildable in a list.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to use.
     * @param weight The relative weight of this class of buildable with
     *     respect to other buildable classes.
     * @param support The support for this buildable within its class.
     * @return True if this type was prioritized.
     */
    private boolean prioritize(BuildableType type,
                               double weight, double support) {
<span class="fc" id="L599">        BuildPlan bp = findBuildPlan(type);</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (bp == null) {</span>
<span class="fc" id="L601">            buildPlans.add(new BuildPlan(type, weight, support));</span>
<span class="fc" id="L602">            return true;</span>
        }
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        if (bp.weight * bp.support &lt; weight * support) {</span>
<span class="fc" id="L605">            bp.weight = weight;</span>
<span class="fc" id="L606">            bp.support = support;</span>
<span class="fc" id="L607">            return true;</span>
        }
<span class="nc" id="L609">        return false;</span>
    }

    /**
     * Given a buildable that improves production of a goods type,
     * prioritize it.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to consider.
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; improved by the buildable.
     * @return True if this type was prioritized.
     */
    private boolean prioritizeProduction(BuildableType type,
                                         GoodsType goodsType) {
<span class="fc" id="L622">        Player player = colony.getOwner();</span>
<span class="fc" id="L623">        NationType nationType = player.getNationType();</span>
<span class="fc" id="L624">        String advantage = getAIMain().getAIPlayer(player).getAIAdvantage();</span>
<span class="fc" id="L625">        boolean ret = false;</span>
<span class="fc" id="L626">        double factor = 1.0;</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">        if (nationType.hasModifier(goodsType.getId())) {</span>
            // Handles building, agriculture, furTrapping advantages
<span class="nc" id="L629">            factor *= 1.2;</span>
        }
<span class="fc bfc" id="L631" title="All 2 branches covered.">        if (goodsType.isMilitaryGoods()) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">            if (&quot;conquest&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L633">            ret = prioritize(type, MILITARY_WEIGHT * factor,</span>
<span class="fc" id="L634">                1.0/*FIXME: amount present wrt amount to equip*/);</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        } else if (goodsType.isBuildingMaterial()) {</span>
<span class="fc" id="L636">            ret = prioritize(type, BUILDING_WEIGHT * factor,</span>
<span class="fc" id="L637">                1.0/*FIXME: need for this type*/);</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">        } else if (goodsType.isLibertyType()) {</span>
<span class="pc bpc" id="L639" title="1 of 2 branches missed.">            if (player.isREF()) return false; // no bells for REF colonies</span>
<span class="fc" id="L640">            ret = prioritize(type, LIBERTY_WEIGHT,</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">                (colony.getSoL() &gt;= 100) ? 0.01 : 1.0);</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        } else if (goodsType.isImmigrationType()) {</span>
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">            if (&quot;immigration&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L644">            ret = prioritize(type, IMMIGRATION_WEIGHT * factor,</span>
<span class="fc" id="L645">                1.0/*FIXME: Brewster?*/);</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">        } else if (produce.contains(goodsType)) {</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">            if (&quot;trade&quot;.equals(advantage)) factor = 1.2;</span>
<span class="fc" id="L648">            double f = 0.1 * colony.getTotalProductionOf(goodsType.getInputType());</span>
<span class="fc" id="L649">            ret = prioritize(type, PRODUCTION_WEIGHT,</span>
<span class="fc" id="L650">                f/*FIXME: improvement?*/);</span>
        }
<span class="fc" id="L652">        return ret;</span>
    }

    /**
     * Updates the build plans for this colony.
     */
    private void updateBuildableTypes() {
<span class="fc" id="L659">        final AIPlayer euaip = getAIMain()</span>
<span class="fc" id="L660">            .getAIPlayer(colony.getOwner());</span>
<span class="fc" id="L661">        String advantage = euaip.getAIAdvantage();</span>
<span class="fc" id="L662">        buildPlans.clear();</span>

        int maxLevel;
<span class="pc bpc" id="L665" title="2 of 5 branches missed.">        switch (profileType) {</span>
        case OUTPOST:
<span class="fc" id="L667">        case SMALL:   maxLevel = 1; break;</span>
<span class="fc" id="L668">        case MEDIUM:  maxLevel = 2; break;</span>
<span class="fc" id="L669">        case LARGE:   maxLevel = 3; break;</span>
<span class="nc" id="L670">        case CAPITAL: maxLevel = 4; break;</span>
        default:
<span class="nc" id="L672">            throw new IllegalStateException(&quot;Bogus profile type: &quot;</span>
<span class="nc" id="L673">                + profileType);</span>
        }

<span class="fc" id="L676">        Player player = colony.getOwner();</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">        for (BuildingType type : spec().getBuildingTypeList()) {</span>
<span class="fc" id="L678">            boolean expectFail = false;</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (!colony.canBuild(type)) continue;</span>

            // Exempt defence and export from the level check.
<span class="fc bfc" id="L682" title="All 2 branches covered.">            if (type.hasModifier(Modifier.DEFENCE)) {</span>
<span class="fc" id="L683">                double factor = 1.0;</span>
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">                if (&quot;conquest&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L685">                prioritize(type, FORTIFY_WEIGHT * factor,</span>
<span class="fc" id="L686">                    1.0/*FIXME: 0 if FF underway*/);</span>
            }
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.EXPORT)) {</span>
<span class="nc" id="L689">                double factor = 1.0;</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">                if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L691">                prioritize(type, EXPORT_WEIGHT * factor,</span>
<span class="nc" id="L692">                    1.0/*FIXME: weigh production v transport*/);</span>
            }

            // Skip later stage buildings for smaller settlements.
<span class="fc bfc" id="L696" title="All 2 branches covered.">            if (type.getLevel() &gt; maxLevel) continue;</span>

            // Scale docks by the improvement available to the food supply.
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.PRODUCE_IN_WATER)) {</span>
<span class="nc" id="L700">                double factor = 0.0;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                if (!colony.hasAbility(Ability.PRODUCE_IN_WATER)</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                    &amp;&amp; colony.getTile().isShore()) {</span>
<span class="nc" id="L703">                    int landFood = 0, seaFood = 0;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                    for (Tile t : colony.getTile().getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                        if (t.getOwningSettlement() == colony</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                            || player.canClaimForSettlement(t)) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                            for (AbstractGoods ag : t.getSortedPotential()) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                                if (ag.getType().isFoodType()) {</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                                    if (t.isLand()) {</span>
<span class="nc" id="L710">                                        landFood += ag.getAmount();</span>
<span class="nc" id="L711">                                    } else {</span>
<span class="nc" id="L712">                                        seaFood += ag.getAmount();</span>
                                    }
                                }
                            }
                        }
                    }
<span class="nc bnc" id="L718" title="All 2 branches missed.">                    factor = (seaFood + landFood == 0) ? 0.0</span>
<span class="nc" id="L719">                        : seaFood / (double)(seaFood + landFood);</span>
                }
<span class="nc" id="L721">                prioritize(type, FISH_WEIGHT, factor);</span>
            }

<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (type.hasAbility(Ability.BUILD)) {</span>
<span class="fc" id="L725">                double factor = 1.0;</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">                if (&quot;building&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L727">                double support = 1.0;</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                for (Ability a : type.getAbilities(Ability.BUILD)) {</span>
<span class="fc" id="L729">                    List&lt;Scope&gt; scopes = a.getScopes();</span>
<span class="pc bpc" id="L730" title="2 of 4 branches missed.">                    if (scopes != null &amp;&amp; !scopes.isEmpty()) support = 0.1;</span>
                }
<span class="fc" id="L732">                prioritize(type, BUILDING_WEIGHT * factor,</span>
<span class="fc" id="L733">                    support/*FIXME: need for the thing now buildable*/);</span>
            }

<span class="fc bfc" id="L736" title="All 2 branches covered.">            if (type.hasAbility(Ability.TEACH)) {</span>
<span class="fc" id="L737">                prioritize(type, TEACH_WEIGHT,</span>
<span class="fc" id="L738">                    1.0/*FIXME: #students, #specialists here, #wanted*/);</span>
            }

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">            if (type.hasAbility(Ability.REPAIR_UNITS)) {</span>
<span class="nc" id="L742">                double factor = 1.0;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                if (&quot;naval&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L744">                prioritize(type, REPAIR_WEIGHT * factor,</span>
<span class="nc" id="L745">                    1.0/*FIXME: #units-to-repair, has-Europe etc*/);</span>
            }

<span class="fc" id="L748">            GoodsType output = type.getProducedGoodsType();</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">            if (output != null) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">                if (!prioritizeProduction(type, output)) {</span>
                    // Allow failure if this building can not build.
<span class="fc" id="L752">                    expectFail = true;</span>
                }
<span class="fc" id="L754">            } else {</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                for (GoodsType g : spec().getGoodsTypeList()) {</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">                    if (type.hasModifier(g.getId())) {</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">                        if (!prioritizeProduction(type, g)) {</span>
<span class="nc" id="L758">                            expectFail = true;</span>
                        }
                    }
                }
                // Hacks.  No good way to make this really generic.
<span class="fc bfc" id="L763" title="All 2 branches covered.">                if (type.hasModifier(Modifier.WAREHOUSE_STORAGE)) {</span>
<span class="fc" id="L764">                    double factor = 1.0;</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">                    if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="fc" id="L766">                    prioritize(type, STORAGE_WEIGHT * factor,</span>
<span class="fc" id="L767">                        1.0/*FIXME: amount of goods*/);</span>
                }
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">                if (type.hasModifier(Modifier.BREEDING_DIVISOR)) {</span>
<span class="nc" id="L770">                    prioritize(type, BREEDING_WEIGHT,</span>
<span class="nc" id="L771">                        1.0/*FIXME: horses present?*/);</span>
                }
            }

<span class="pc bpc" id="L775" title="1 of 4 branches missed.">            if (findBuildPlan(type) == null &amp;&amp; !expectFail) {</span>
<span class="nc" id="L776">                logger.warning(&quot;No building priority found for: &quot; + type);</span>
            }
        }

<span class="fc" id="L780">        double wagonNeed = 0.0;</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        if (!colony.isConnectedPort()) { // Inland colonies need transportation</span>
<span class="fc" id="L782">            int wagons = euaip.getNeededWagons(colony.getTile());</span>
<span class="pc bpc" id="L783" title="3 of 4 branches missed.">            wagonNeed = (wagons &lt;= 0) ? 0.0 : (wagons &gt; 3) ? 1.0</span>
<span class="nc" id="L784">                : wagons / 3.0;</span>
        }
<span class="fc bfc" id="L786" title="All 2 branches covered.">        for (UnitType unitType : spec().getUnitTypeList()) {</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">            if (!colony.canBuild(unitType)) continue;</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">            if (unitType.hasAbility(Ability.NAVAL_UNIT)) {</span>
                ; // FIXME: decide to build a ship
<span class="pc bfc" id="L790" title="All 2 branches covered.">            } else if (unitType.isDefensive()) {</span>
<span class="pc bpc" id="L791" title="1 of 2 branches missed.">                if (colony.isBadlyDefended()) {</span>
<span class="fc" id="L792">                    prioritize(unitType, DEFENCE_WEIGHT,</span>
<span class="fc" id="L793">                        1.0/*FIXME: how badly defended?*/);</span>
                }
<span class="fc bfc" id="L795" title="All 2 branches covered.">            } else if (unitType.hasAbility(Ability.CARRY_GOODS)) {</span>
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                if (wagonNeed &gt; 0.0) {</span>
<span class="nc" id="L797">                    double factor = 1.0;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                    if (&quot;trade&quot;.equals(advantage)) factor = 1.1;</span>
<span class="nc" id="L799">                    prioritize(unitType, TRANSPORT_WEIGHT * factor,</span>
<span class="nc" id="L800">                        wagonNeed/*FIXME: type.getSpace()*/);</span>
                }
            }
        }

        // Weight by lower required goods.
<span class="fc bfc" id="L806" title="All 2 branches covered.">        for (BuildPlan bp : buildPlans) {</span>
<span class="fc" id="L807">            int difficulty = sum(bp.type.getRequiredGoods(),</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">                ag -&gt; ag.getAmount() &gt; colony.getGoodsCount(ag.getType()),</span>
<span class="fc" id="L809">                ag -&gt; {</span>
<span class="fc" id="L810">                    final GoodsType type = ag.getType();</span>
<span class="fc" id="L811">                    return (ag.getAmount() - colony.getGoodsCount(type))</span>
                    // Penalize building with type that can not be
                    // made locally.
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">                        * ((produce.contains(type.getInputType())) ? 1 : 5);</span>
                });
<span class="fc" id="L816">            bp.difficulty = Math.max(1.0f, Math.sqrt((double)difficulty));</span>
        }

<span class="fc" id="L819">        Collections.sort(buildPlans, buildPlanComparator);</span>
<span class="fc" id="L820">    }</span>

    /**
     * Makes a plan for each type of possible production, that is
     * those work locations that can use a unit or can auto-produce.
     * Note that this will almost certainly include clashes over work
     * locations.  That gets sorted out elsewhere as ColonyPlans do
     * not examine the units present.
     *
     * With the complete list of work plans, finish creating the list
     * of goods to produce.
     *
     * Then filter out the auto-production plans as they are not
     * going to be helpful for unit allocation.
     *
     * Finally sort by desirability.
     *
     * @param production A map of the goods type and production.
     */
    private void updatePlans(Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L840">        workPlans.clear();</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">        for (Entry&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; entry</span>
<span class="fc" id="L842">                 : production.entrySet()) {</span>
<span class="fc" id="L843">            GoodsType g = entry.getKey();</span>
            // Do not make plans to produce into a full warehouse.
<span class="fc bfc" id="L845" title="All 2 branches covered.">            if (g.isStorable()</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">                &amp;&amp; colony.getGoodsCount(g) &gt;= colony.getWarehouseCapacity()</span>
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">                &amp;&amp; !g.limitIgnored()) continue;</span>

<span class="fc bfc" id="L849" title="All 2 branches covered.">            for (WorkLocation wl : entry.getValue().keySet()) {</span>
<span class="pc bpc" id="L850" title="3 of 4 branches missed.">                if (wl.canBeWorked() || wl.canAutoProduce()) {</span>
<span class="fc" id="L851">                    workPlans.add(new WorkLocationPlan(getAIMain(), wl, g));</span>
                }
            }
        }

        // Now we have lots of plans, determine what goods to produce.
<span class="fc" id="L857">        updateProductionList(production);</span>

        // Filter out plans that can not use a unit.
<span class="fc" id="L860">        List&lt;WorkLocationPlan&gt; oldPlans = new ArrayList&lt;&gt;(workPlans);</span>
<span class="fc" id="L861">        workPlans.clear();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">        for (WorkLocationPlan wlp : oldPlans) {</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">            if (wlp.getWorkLocation().canBeWorked()) workPlans.add(wlp);</span>
        }

        // Sort the work plans by earliest presence in the produce
        // list, and then by amount.  If the type of goods produced is
        // not on the produce list, then make sure such plans sort to
        // the end, except for food plans.
<span class="fc" id="L870">        Collections.sort(workPlans,</span>
<span class="fc" id="L871">            Comparator.comparingInt((WorkLocationPlan wp) -&gt; {</span>
<span class="fc" id="L872">                    final GoodsType gt = wp.getGoodsType();</span>
<span class="fc" id="L873">                    int i = produce.indexOf(gt);</span>
<span class="fc bfc" id="L874" title="All 4 branches covered.">                    return (i &lt; 0 &amp;&amp; !gt.isFoodType()) ? 99999 : i;</span>
                })
<span class="fc" id="L876">            .thenComparingInt((WorkLocationPlan wp) -&gt;</span>
<span class="fc" id="L877">                wp.getWorkLocation().getGenericPotential(wp.getGoodsType()))</span>
<span class="fc" id="L878">            .thenComparing((WorkLocationPlan wp) -&gt;</span>
<span class="fc" id="L879">                wp.getGoodsType(), GoodsType.goodsTypeComparator));</span>
<span class="fc" id="L880">    }</span>

    /**
     * Add the other goods types to the production list.  When this is
     * called the new world goods production is already present on the
     * produce list.  Ignores food which is treated separately.
     *
     * @param production A map of the production.
     */
    private void updateProductionList(final Map&lt;GoodsType, Map&lt;WorkLocation, Integer&gt;&gt; production) {
<span class="fc" id="L890">        final Comparator&lt;GoodsType&gt; productionComparator</span>
<span class="fc" id="L891">            = Comparator.comparingInt((GoodsType gt) -&gt;</span>
<span class="fc" id="L892">                    sum(production.get(gt).values(), Integer::intValue))</span>
<span class="fc" id="L893">                .reversed();</span>

        // If we need liberty put it before the new world production.
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">        if (colony.getSoL() &lt; 100) {</span>
<span class="fc" id="L897">            produce.addAll(0, transformAndSort(libertyGoodsTypes,</span>
<span class="fc" id="L898">                    gt -&gt; production.containsKey(gt),</span>
<span class="fc" id="L899">                    productionComparator, Collectors.toList()));</span>
        }

        // Always add raw/building materials first.
<span class="fc" id="L903">        Collections.sort(rawBuildingGoodsTypes, productionComparator);</span>
<span class="fc" id="L904">        final ToIntFunction&lt;GoodsType&gt; indexer = gt -&gt;</span>
<span class="fc" id="L905">            rawBuildingGoodsTypes.indexOf(gt.getInputType());</span>
<span class="fc" id="L906">        List&lt;GoodsType&gt; toAdd = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L907">        toAdd.addAll(transformAndSort(buildingGoodsTypes,</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">                gt -&gt; production.containsKey(gt)</span>
<span class="fc" id="L909">                    &amp;&amp; (colony.getGoodsCount(gt.getInputType())</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">                        &gt;= GoodsContainer.CARGO_SIZE/2</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">                        || production.containsKey(gt.getInputType())),</span>
<span class="fc" id="L912">                Comparator.comparingInt(indexer).reversed(),</span>
<span class="fc" id="L913">                Collectors.toList()));</span>

<span class="fc bfc" id="L915" title="All 2 branches covered.">        for (int i = toAdd.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L916">            GoodsType make = toAdd.get(i);</span>
<span class="fc" id="L917">            GoodsType raw = make.getInputType();</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">            if (production.containsKey(raw)) {</span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">                if (colony.getGoodsCount(raw) &gt;= GoodsContainer.CARGO_SIZE/2) {</span>
<span class="fc" id="L920">                    produce.add(raw); // Add at the end, enough in stock</span>
<span class="fc" id="L921">                    produce.add(0, make);</span>
<span class="fc" id="L922">                } else {</span>
<span class="fc" id="L923">                    produce.add(0, make);</span>
<span class="fc" id="L924">                    produce.add(0, raw);</span>
                }
<span class="fc" id="L926">            } else {</span>
<span class="fc" id="L927">                produce.add(0, make);</span>
            }
        }

        // Military goods after lucrative production.
<span class="fc" id="L932">        produce.addAll(transformAndSort(militaryGoodsTypes,</span>
<span class="fc" id="L933">                gt -&gt; production.containsKey(gt), productionComparator,</span>
<span class="fc" id="L934">                Collectors.toList()));</span>

        // Immigration last.
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if (colony.getOwner().getEurope() != null) {</span>
<span class="fc" id="L938">            produce.addAll(transformAndSort(immigrationGoodsTypes,</span>
<span class="pc" id="L939">                    gt -&gt; production.containsKey(gt),</span>
<span class="fc" id="L940">                    productionComparator, Collectors.toList()));</span>
        }
<span class="fc" id="L942">    }</span>

    /**
     * Tries to swap an expert unit for another doing its job.
     *
     * @param expert The expert &lt;code&gt;Unit&lt;/code&gt;.
     * @param others A list of other &lt;code&gt;Unit&lt;/code&gt;s to test against.
     * @param colony The &lt;code&gt;Colony&lt;/code&gt; the units are working in.
     * @return The unit that was replaced by the expert, or null if none.
     */
    private Unit trySwapExpert(Unit expert, List&lt;Unit&gt; others, Colony colony) {
<span class="fc" id="L953">        Role oldRole = expert.getRole();</span>
<span class="fc" id="L954">        int oldRoleCount = expert.getRoleCount();</span>
<span class="fc" id="L955">        GoodsType work = expert.getType().getExpertProduction();</span>
<span class="fc" id="L956">        GoodsType oldWork = expert.getWorkType();</span>
<span class="fc bfc" id="L957" title="All 2 branches covered.">        for (Unit other : others) {</span>
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">            if (!other.isPerson()) continue;</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">            if (other.getWorkType() == work</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                &amp;&amp; other.getType().getExpertProduction() != work) {</span>
<span class="nc" id="L961">                Location l1 = expert.getLocation();</span>
<span class="nc" id="L962">                Location l2 = other.getLocation();</span>
<span class="nc" id="L963">                other.setLocation(colony.getTile());</span>
<span class="nc" id="L964">                expert.setLocation(l2);</span>
<span class="nc" id="L965">                expert.changeWorkType(work);</span>
<span class="nc" id="L966">                other.setLocation(l1);</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">                if (oldWork != null) other.changeWorkType(oldWork);</span>
<span class="nc" id="L968">                Role tmpRole = other.getRole();</span>
<span class="nc" id="L969">                int tmpRoleCount = other.getRoleCount();</span>
<span class="nc" id="L970">                other.changeRole(oldRole, oldRoleCount);</span>
<span class="nc" id="L971">                expert.changeRole(tmpRole, tmpRoleCount);</span>
<span class="nc" id="L972">                return other;</span>
            }
        }
<span class="fc" id="L975">        return null;</span>
    }

    /**
     * Finds a plan on a list that produces a given goods type.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @param plans The list of &lt;code&gt;WorkLocationPlan&lt;/code&gt;s to check.
     * @return The first plan found that produces the goods type, or null
     *     if none found.
     */
    private WorkLocationPlan findPlan(GoodsType goodsType,
                                      List&lt;WorkLocationPlan&gt; plans) {
<span class="fc bfc" id="L988" title="All 2 branches covered.">        return find(plans, wlp -&gt; wlp.getGoodsType() == goodsType);</span>
    }

    /**
     * Gets the best worker to execute a work location plan.
     * - The most productive one wins (which will automatically pick a
     *   relevant expert).
     * - If they are all relevant experts, pick any.
     * - Pick the unit that can upgrade to the required expert with the most
     *     relevant experience or least irrelevant expertise.
     * - Pick a unit that can not upgrade at all.
     * - Pick an otherwise upgradeable unit with the most relevant experience
     *     or least irrelevant experience.
     * - Pick the least skillful unit.
     *
     * Public for the benefit of the test suite.
     *
     * @param wl The &lt;code&gt;WorkLocation&lt;/code&gt; to work at.
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to make.
     * @param workers A list of potential &lt;code&gt;Unit&lt;/code&gt;s to try.
     * @return The best worker for the job.
     */
    public static Unit getBestWorker(WorkLocation wl, GoodsType goodsType,
                                     List&lt;Unit&gt; workers) {
<span class="fc bfc" id="L1012" title="All 4 branches covered.">        if (workers == null || workers.isEmpty()) return null;</span>
<span class="fc" id="L1013">        final Colony colony = wl.getColony();</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">        final GoodsType outputType = (goodsType.isStoredAs())</span>
<span class="fc" id="L1015">            ? goodsType.getStoredAs() : goodsType;</span>

        // Avoid some nasty autodestructions by accepting singleton
        // workers that do *something*.
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (workers.size() == 1) {</span>
<span class="fc" id="L1020">            Unit u = workers.get(0);</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">            if (!wl.canAdd(u)) return null;</span>
<span class="fc" id="L1022">            Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1023">            GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1024">            u.setLocation(wl);</span>
<span class="fc" id="L1025">            u.changeWorkType(goodsType);</span>
<span class="fc" id="L1026">            int production = wl.getProductionOf(u, goodsType);</span>
<span class="fc" id="L1027">            u.setLocation(oldLoc);</span>
<span class="fc" id="L1028">            u.changeWorkType(oldWork);</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">            return (production &gt; 0) ? u : null;</span>
        }

        // Do not mutate the workers list!
<span class="fc" id="L1033">        List&lt;Unit&gt; todo = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1034">        List&lt;Unit&gt; best = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1035">        int bestValue = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc" id="L1036">        Unit special = null;</span>
<span class="fc" id="L1037">        best.clear();</span>
<span class="fc bfc" id="L1038" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">            if (!wl.canAdd(u)) continue;</span>
<span class="fc" id="L1040">            Location oldLoc = u.getLocation();</span>
<span class="fc" id="L1041">            GoodsType oldWork = u.getWorkType();</span>
<span class="fc" id="L1042">            u.setLocation(wl);</span>
<span class="fc" id="L1043">            u.changeWorkType(goodsType);</span>

<span class="fc" id="L1045">            int value = colony.getAdjustedNetProductionOf(outputType);</span>
<span class="fc bfc" id="L1046" title="All 2 branches covered.">            if (value &gt; bestValue) {</span>
<span class="fc" id="L1047">                bestValue = value;</span>
<span class="fc" id="L1048">                best.clear();</span>
<span class="fc" id="L1049">                best.add(u);</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">                if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="fc" id="L1051">                    special = u;</span>
                }
<span class="fc bfc" id="L1053" title="All 4 branches covered.">            } else if (value == bestValue &amp;&amp; !best.isEmpty()) {</span>
<span class="fc" id="L1054">                best.add(u);</span>
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">                if (u.getType().getExpertProduction() == goodsType) {</span>
<span class="nc" id="L1056">                    special = u;</span>
                }
            }

<span class="fc" id="L1060">            u.setLocation(oldLoc);</span>
<span class="fc" id="L1061">            u.changeWorkType(oldWork);</span>
        }

<span class="fc bfc" id="L1064" title="All 3 branches covered.">        switch (best.size()) {</span>
<span class="fc" id="L1065">        case 0: return null; // Not good.  No unit improves production.</span>
<span class="fc" id="L1066">        case 1: return best.get(0);</span>
<span class="fc" id="L1067">        default:todo.clear(); todo.addAll(best); break;</span>
        }
        // Several winners including an expert implies they are all experts.
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">        if (special != null) return special;</span>

        // Partition units into those that can upgrade-by-experience
        // to the relevant expert (which we favour), those that can
        // upgrade-by-experience in some way but not to the expert
        // (which we avoid), and the rest.  Within the groups, favour
        // those with the most relevant experience and the least irrelevant
        // experience.
<span class="fc" id="L1078">        Specification spec = colony.getSpecification();</span>
<span class="fc" id="L1079">        UnitType expert = spec.getExpertForProducing(goodsType);</span>
<span class="fc" id="L1080">        best.clear();</span>
<span class="fc" id="L1081">        bestValue = Integer.MIN_VALUE;</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="fc bfc" id="L1083" title="All 2 branches covered.">            boolean relevant = u.getWorkType() == goodsType;</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">            int score = (relevant) ? u.getExperience() : -u.getExperience();</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">            if (expert != null</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">                &amp;&amp; u.getType().canBeUpgraded(expert, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1087">                score += 10000;</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">            } else if (expert != null</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                &amp;&amp; u.getType().canBeUpgraded(null, ChangeType.EXPERIENCE)) {</span>
<span class="fc" id="L1090">                score -= 10000;</span>
            }
<span class="fc bfc" id="L1092" title="All 2 branches covered.">            if (score &gt; bestValue) {</span>
<span class="fc" id="L1093">                best.clear();</span>
<span class="fc" id="L1094">                best.add(u);</span>
<span class="fc" id="L1095">                bestValue = score;</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">            } else if (score == bestValue) {</span>
<span class="fc" id="L1097">                best.add(u);</span>
            }
        }
<span class="pc bpc" id="L1100" title="1 of 3 branches missed.">        switch (best.size()) {</span>
<span class="nc" id="L1101">        case 0: break;</span>
<span class="fc" id="L1102">        case 1: return best.get(0);</span>
<span class="fc" id="L1103">        default:todo.clear(); todo.addAll(best); break;</span>
        }

        // Use the unit with the least skill, in the hope that
        // remaining experts will be called upon in due course.
<span class="fc" id="L1108">        int worstSkill = Integer.MAX_VALUE;</span>
<span class="fc" id="L1109">        special = null;</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">        for (Unit u : todo) {</span>
<span class="fc bfc" id="L1111" title="All 2 branches covered.">            if (u.getType().getSkill() &lt; worstSkill) {</span>
<span class="fc" id="L1112">                special = u;</span>
<span class="fc" id="L1113">                worstSkill = u.getType().getSkill();</span>
            }
        }
<span class="fc" id="L1116">        return special;</span>
    }

    /**
     * Equips a unit for a role, trying extra possibilities.
     *
     * @param spec The &lt;code&gt;Specification&lt;/code&gt; defining the roles.
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to equip if possible.
     * @param role The &lt;code&gt;Role&lt;/code&gt; for the unit to take.
     * @param colony The &lt;code&gt;Colony&lt;/code&gt; storing the equipment.
     * @return True if the unit was equipped.
     */
    private static boolean fullEquipUnit(Specification spec, Unit unit,
                                         Role role, Colony colony) {
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        if (role.isOffensive()) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">            for (Role r : unit.getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="nc" id="L1132">                if (colony.equipForRole(unit, </span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">                        r, r.getMaximumCount())) return true;</span>
            }
<span class="nc" id="L1135">            return false;</span>
        }
<span class="nc" id="L1137">        return colony.equipForRole(unit, role, role.getMaximumCount());</span>
    }

    /**
     * Tries to apply a colony plan given a list of workers.
     *
     * @param workers A list of &lt;code&gt;Unit&lt;/code&gt;s to assign.
     * @param preferScout Prefer to make scouts rather than soldiers.
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return A scratch colony with the workers in place.
     */
    public Colony assignWorkers(List&lt;Unit&gt; workers, boolean preferScout,
                                LogBuilder lb) {
<span class="fc" id="L1150">        final GoodsType foodType = spec().getPrimaryFoodType();</span>

        // Collect the work location plans.  Note that the plans are
        // pre-sorted in order of desirability.
<span class="fc" id="L1154">        final List&lt;GoodsType&gt; produce = getPreferredProduction();</span>
<span class="fc" id="L1155">        List&lt;WorkLocationPlan&gt; foodPlans = getFoodPlans();</span>
<span class="fc" id="L1156">        List&lt;WorkLocationPlan&gt; workPlans = getWorkPlans();</span>

        // Make a scratch colony to work on.
<span class="fc" id="L1159">        Colony col = colony.copyColony();</span>
<span class="fc" id="L1160">        Tile tile = col.getTile();</span>

        // Replace the given workers with those in the scratch colony.
<span class="fc" id="L1163">        List&lt;Unit&gt; otherWorkers = new ArrayList&lt;&gt;(workers);</span>
<span class="fc" id="L1164">        workers.clear();</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">        for (Unit u : otherWorkers) workers.add(col.getCorresponding(u));</span>

        // Move all workers to the tile.
        // Also remove equipment, which is safe because no missionaries
        // or active pioneers should be on the worker list.
<span class="fc bfc" id="L1170" title="All 2 branches covered.">        for (Unit u : workers) {</span>
<span class="fc" id="L1171">            u.setLocation(tile);</span>
<span class="fc" id="L1172">            col.equipForRole(u, spec().getDefaultRole(), 0);</span>
        }

        // Move outdoor experts outside if possible.
        // Prefer scouts in early game if there are very few.
<span class="fc" id="L1177">        Role[] outdoorRoles = {</span>
<span class="fc" id="L1178">            spec().getRoleWithAbility(Ability.IMPROVE_TERRAIN, null),</span>
            null,
<span class="fc" id="L1180">            spec().getRoleWithAbility(Ability.SPEAK_WITH_CHIEF, null)</span>
        };
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">        if (preferScout) {</span>
<span class="fc" id="L1183">            Role tmp = outdoorRoles[1];</span>
<span class="fc" id="L1184">            outdoorRoles[1] = outdoorRoles[2];</span>
<span class="fc" id="L1185">            outdoorRoles[2] = tmp;</span>
        }
<span class="fc bfc" id="L1187" title="All 2 branches covered.">        for (Role outdoorRole : outdoorRoles) {</span>
<span class="fc bfc" id="L1188" title="All 2 branches covered.">            for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">                if (workers.size() &lt;= 1) break;</span>
<span class="fc" id="L1190">                Role role = outdoorRole;</span>
<span class="fc bfc" id="L1191" title="All 2 branches covered.">                if (role == null) {</span>
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">                    if ((role = u.getMilitaryRole()) == null) continue;</span>
                }
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">                if (u.getType() == role.getExpertUnit()</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                    &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1196">                    workers.remove(u);</span>
<span class="nc" id="L1197">                    lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
<span class="nc" id="L1198">                        &quot;) -&gt; &quot;, role.getSuffix(), &quot;\n&quot;);</span>
                }
            }
        }

        // Consider the defence situation.
        // FIXME: scan for neighbouring hostiles
        // Favour low-skill units for defenders, then order experts
        // in reverse order of their production on the produce-list,
        // and finally by least experience.
<span class="fc" id="L1208">        final Comparator&lt;Unit&gt; soldierComparator</span>
<span class="fc" id="L1209">            = Comparator.&lt;Unit&gt;comparingInt(Unit::getSkillLevel)</span>
<span class="fc" id="L1210">                .thenComparingInt(u -&gt;</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">                    (u.getType().getExpertProduction() == null) ? 1 : 0)</span>
<span class="fc" id="L1212">                .thenComparingInt(u -&gt;</span>
<span class="fc" id="L1213">                    produce.indexOf(u.getType().getExpertProduction()))</span>
<span class="fc" id="L1214">                .reversed()</span>
<span class="fc" id="L1215">                .thenComparingInt(Unit::getExperience);</span>
<span class="fc" id="L1216">        Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1217" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="fc bfc" id="L1218" title="All 2 branches covered.">            if (workers.size() &lt;= 1) break;</span>
<span class="pc bpc" id="L1219" title="1 of 2 branches missed.">            if (!col.isBadlyDefended()) break;</span>
<span class="nc" id="L1220">            Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1221" title="All 4 branches missed.">            if (role != null &amp;&amp; fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1222">                workers.remove(u);</span>
<span class="nc" id="L1223">                lb.add(u.getId(), &quot;(&quot;, u.getType().getSuffix(), &quot;) -&gt; &quot;,</span>
<span class="nc" id="L1224">                       u.getRoleSuffix(), &quot;\n&quot;);</span>
            }
        }

        // Greedy assignment of other workers to plans.
<span class="fc" id="L1229">        List&lt;AbstractGoods&gt; buildGoods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1230">        BuildableType build = col.getCurrentlyBuilding();</span>
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">        if (build != null) buildGoods.addAll(build.getRequiredGoods());</span>
        List&lt;WorkLocationPlan&gt; wlps;
        WorkLocationPlan wlp;
<span class="fc" id="L1234">        boolean done = false;</span>
<span class="pc bpc" id="L1235" title="1 of 4 branches missed.">        while (!workers.isEmpty() &amp;&amp; !done) {</span>
            // Decide what to produce: set the work location plan to
            // try (wlp), and the list the plan came from so it can
            // be recycled if successful (wlps).
<span class="fc" id="L1239">            wlps = null;</span>
<span class="fc" id="L1240">            wlp = null;</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">            if (col.getAdjustedNetProductionOf(foodType) &gt; 0) {</span>
                // Try to produce something.
<span class="fc" id="L1243">                wlps = workPlans;</span>
<span class="pc bpc" id="L1244" title="1 of 2 branches missed.">                while (!produce.isEmpty()) {</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">                    if ((wlp = findPlan(produce.get(0), workPlans)) != null) {</span>
<span class="fc" id="L1246">                        break; // Found a plan to try.</span>
                    }
<span class="fc" id="L1248">                    produce.remove(0); // Can not produce this goods type</span>
                }
            }

            // See if a plan can be satisfied.
            Unit best;
            WorkLocation wl;
            GoodsType goodsType;
            for (;;) {
<span class="fc bfc" id="L1257" title="All 2 branches covered.">                if (wlp == null) { // Time to use a food plan.</span>
<span class="pc bpc" id="L1258" title="1 of 2 branches missed.">                    if (foodPlans.isEmpty()) {</span>
<span class="nc" id="L1259">                        lb.add(&quot;    Food plans exhausted\n&quot;);</span>
<span class="nc" id="L1260">                        done = true;</span>
<span class="nc" id="L1261">                        break;</span>
                    }
<span class="fc" id="L1263">                    wlps = foodPlans;</span>
<span class="fc" id="L1264">                    wlp = wlps.get(0);</span>
                }

<span class="fc" id="L1267">                String err = null;</span>
<span class="fc" id="L1268">                goodsType = wlp.getGoodsType();</span>
<span class="fc" id="L1269">                wl = col.getCorresponding(wlp.getWorkLocation());</span>
<span class="fc" id="L1270">                best = null;</span>
<span class="fc" id="L1271">                lb.add(&quot;    &quot;, LogBuilder.wide(2, col.getUnitCount()),</span>
<span class="fc" id="L1272">                       &quot;: &quot;, LogBuilder.wide(-15, goodsType.getSuffix()),</span>
<span class="fc" id="L1273">                       &quot;@&quot;, LogBuilder.wide(25, locationDescription(wl)),</span>
<span class="fc" id="L1274">                       &quot; =&gt; &quot;);</span>

<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">                if (!wl.canBeWorked()) {</span>
<span class="nc" id="L1277">                    err = &quot;can not be worked&quot;;</span>
<span class="pc bfc" id="L1278" title="All 2 branches covered.">                } else if (wl.isFull()) {</span>
<span class="fc" id="L1279">                    err = &quot;full&quot;;</span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">                } else if ((best = ColonyPlan.getBestWorker(wl, goodsType,</span>
<span class="fc" id="L1281">                                                            workers)) == null) {</span>
<span class="fc" id="L1282">                    err = &quot;no worker found&quot;;</span>
                }
<span class="fc bfc" id="L1284" title="All 2 branches covered.">                if (err != null) {</span>
<span class="fc" id="L1285">                    wlps.remove(wlp); // The plan can not be worked, dump it.</span>
<span class="fc" id="L1286">                    lb.add(err, &quot;\n&quot;);</span>
<span class="fc" id="L1287">                    break;</span>
                }

                // Found a suitable worker, place it.
<span class="fc" id="L1291">                best.setLocation(wl);</span>

                // Did the placement break the production bonus?
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">                if (col.getProductionBonus() &lt; 0) {</span>
<span class="nc" id="L1295">                    best.setLocation(tile);</span>
<span class="nc" id="L1296">                    done = true;</span>
<span class="nc" id="L1297">                    lb.add(&quot;    broke production bonus\n&quot;);</span>
<span class="nc" id="L1298">                    break;</span>
                }

                // Is the colony going to starve because of this placement?
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">                if (col.getAdjustedNetProductionOf(foodType) &lt; 0) {</span>
<span class="nc" id="L1303">                    int net = col.getAdjustedNetProductionOf(foodType);</span>
<span class="nc" id="L1304">                    int count = col.getGoodsCount(foodType);</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                    if (count / -net &lt; PRODUCTION_TURNOVER_TURNS) {</span>
                        // Too close for comfort.  Back out the
                        // placement and try a food plan, unless this
                        // was already a food plan.
<span class="nc" id="L1309">                        best.setLocation(tile);</span>
<span class="nc" id="L1310">                        wlp = null;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">                        if (goodsType.isFoodType()) {</span>
<span class="nc" id="L1312">                            lb.add(&quot;    starvation (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1313">                            done = true;</span>
<span class="nc" id="L1314">                            break;</span>
                        }
<span class="nc" id="L1316">                        lb.add(&quot;    would starve (&quot;, count, &quot;/&quot;, net, &quot;)\n&quot;);</span>
<span class="nc" id="L1317">                        continue;</span>
                    }
                    // Otherwise tolerate the food stock running down.
                    // Rely on the warehouse-exhaustion code to fire
                    // another rearrangement before units starve.
                }

                // Check if placing the worker will soon exhaust the
                // raw material.  Do not reduce raw materials below
                // what is needed for a building--- e.g. prevent
                // musket production from hogging the tools.
<span class="fc" id="L1328">                GoodsType raw = goodsType.getInputType();</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">                int rawNeeded = sum(buildGoods, ag -&gt; ag.getType() == raw,</span>
<span class="fc" id="L1330">                                    AbstractGoods::getAmount);</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">                if (raw == null</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">                    || col.getAdjustedNetProductionOf(raw) &gt;= 0</span>
<span class="fc" id="L1333">                    || (((col.getGoodsCount(raw) - rawNeeded)</span>
<span class="fc" id="L1334">                            / -col.getAdjustedNetProductionOf(raw))</span>
<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">                        &gt;= PRODUCTION_TURNOVER_TURNS)) {</span>
                    // No raw material problems, the placement
                    // succeeded.  Set the work type, move the
                    // successful goods type to the end of the produce
                    // list for later reuse, remove the worker from
                    // the workers pool, but leave the successful plan
                    // on its list.
<span class="fc" id="L1342">                    best.changeWorkType(goodsType);</span>
<span class="fc" id="L1343">                    workers.remove(best);</span>
<span class="fc" id="L1344">                    lb.add(&quot;    &quot;, best.getId(), &quot;(&quot;,</span>
<span class="fc" id="L1345">                           best.getType().getSuffix(),&quot;)\n&quot;);</span>
<span class="pc bpc" id="L1346" title="1 of 4 branches missed.">                    if (!goodsType.isFoodType() &amp;&amp; produce.remove(goodsType)) {</span>
<span class="fc" id="L1347">                        produce.add(goodsType);</span>
                    }
<span class="fc" id="L1349">                    break;</span>
                }

                // Yes, we need more of the raw material.  Pull the
                // unit out again and see if we can make more.
<span class="nc" id="L1354">                best.setLocation(tile);</span>

<span class="nc" id="L1356">                WorkLocationPlan rawWlp = findPlan(raw, workPlans);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                if (rawWlp != null) {</span>
                    // OK, we have an alternate plan.  Put the raw
                    // material at the start of the produce list and
                    // loop trying to satisfy the alternate plan.
<span class="nc bnc" id="L1361" title="All 2 branches missed.">                    if (produce.remove(raw)) produce.add(0, raw);</span>
<span class="nc" id="L1362">                    wlp = rawWlp;</span>
<span class="nc" id="L1363">                    lb.add(&quot;    retry with &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1364">                    continue;</span>
                }

                // No raw material available, so we have to give up on
                // both the plan and the type of production.
                // Hopefully the raw production is positive again and
                // we will succeed next time.
<span class="nc" id="L1371">                wlps.remove(wlp);</span>
<span class="nc" id="L1372">                produce.remove(goodsType);</span>
<span class="nc" id="L1373">                lb.add(&quot;    needs more &quot;, raw.getSuffix(), &quot;\n&quot;);</span>
                break;
            }
        }

        // Put the rest of the workers on the tile.
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">        for (Unit u : workers) {</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">            if (u.getLocation() != tile) u.setLocation(tile);</span>
        }

        // Check for failure to assign any workers.  This happens when:
        // - there are no useful food plans
        //   - in which case look for a `harmless' place and add one worker
        // - food is low, and perhaps partly eaten by horses, and no
        //   unit can *improve* production by being added.
        //   - find a place to produce food that at least avoids
        //     starvation and add one worker.
<span class="pc bpc" id="L1390" title="1 of 2 branches missed.">        if (col.getUnitCount() == 0) {</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">            if (getFoodPlans().isEmpty()) {</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">locations:      for (WorkLocation wl : col.getAvailableWorkLocations()) {</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">                    for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                        for (GoodsType type : libertyGoodsTypes) {</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">                            if (wl.canAdd(u)</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                                &amp;&amp; wl.getPotentialProduction(type,</span>
<span class="nc" id="L1397">                                    u.getType()) &gt; 0) {</span>
<span class="nc" id="L1398">                                u.setLocation(wl);</span>
<span class="nc" id="L1399">                                u.changeWorkType(type);</span>
<span class="nc" id="L1400">                                workers.remove(u);</span>
<span class="nc" id="L1401">                                break locations;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1406">            } else {</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">plans:          for (WorkLocationPlan w : getFoodPlans()) {</span>
<span class="nc" id="L1408">                    GoodsType goodsType = w.getGoodsType();</span>
<span class="nc" id="L1409">                    WorkLocation wl = col.getCorresponding(w.getWorkLocation());</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                    for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1411">                        GoodsType oldWork = u.getWorkType();</span>
<span class="nc" id="L1412">                        u.setLocation(wl);</span>
<span class="nc" id="L1413">                        u.changeWorkType(goodsType);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                        if (col.getAdjustedNetProductionOf(foodType) &gt;= 0) {</span>
<span class="nc" id="L1415">                            lb.add(&quot;    Subsist with &quot;, u, &quot;\n&quot;);</span>
<span class="nc" id="L1416">                            workers.remove(u);</span>
<span class="nc" id="L1417">                            break plans;</span>
                        }
<span class="nc" id="L1419">                        u.setLocation(tile);</span>
<span class="nc" id="L1420">                        u.changeWorkType(oldWork);</span>
                    }
                }
            }
        }

        // The greedy algorithm works reasonably well, but will
        // misplace experts when they are more productive at the
        // immediately required task than a lesser unit, not knowing
        // that a requirement for their speciality will subsequently
        // follow.  Do a cleanup pass to sort these out.
<span class="fc" id="L1431">        List&lt;Unit&gt; experts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1432">        List&lt;Unit&gt; nonExperts = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        for (Unit u : col.getUnitList()) {</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">            if (u.getType().getExpertProduction() != null) {</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">                if (u.getType().getExpertProduction() != u.getWorkType()) {</span>
<span class="fc" id="L1436">                    experts.add(u);</span>
                }
<span class="fc" id="L1438">            } else {</span>
<span class="fc" id="L1439">                nonExperts.add(u);</span>
            }
        }
<span class="fc" id="L1442">        int expert = 0;</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">        while (expert &lt; experts.size()) {</span>
<span class="fc" id="L1444">            Unit u1 = experts.get(expert);</span>
            Unit other;
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">            if ((other = trySwapExpert(u1, experts, col)) != null) {</span>
<span class="nc" id="L1447">                lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1448">                    u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1449">                experts.remove(u1);</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">            } else if ((other = trySwapExpert(u1, nonExperts, col)) != null) {</span>
<span class="nc" id="L1451">                lb.add(&quot;    Swapped &quot;, u1.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1452">                    u1.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1453">                experts.remove(u1);</span>
<span class="nc" id="L1454">            } else {</span>
<span class="fc" id="L1455">                expert++;</span>
            }
        }
<span class="pc bpc" id="L1458" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1459">            GoodsType work = u.getType().getExpertProduction();</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">            if (work != null) {</span>
<span class="nc" id="L1461">                Unit other = trySwapExpert(u, col.getUnitList(), col);</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">                if (other != null) {</span>
<span class="nc" id="L1463">                    lb.add(&quot;    Swapped &quot;, u.getId(), &quot;(&quot;,</span>
<span class="nc" id="L1464">                        u.getType().getSuffix(), &quot;) for &quot;, other, &quot;\n&quot;);</span>
<span class="nc" id="L1465">                    workers.remove(u);</span>
<span class="nc" id="L1466">                    workers.add(other);</span>
                }
            }
        }

        // Rearm what remains as far as possible.
<span class="fc" id="L1472">        Collections.sort(workers, soldierComparator);</span>
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">        for (Unit u : new ArrayList&lt;&gt;(workers)) {</span>
<span class="nc" id="L1474">            Role role = u.getMilitaryRole();</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">            if (role == null) continue;</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">            if (fullEquipUnit(spec(), u, role, col)) {</span>
<span class="nc" id="L1477">                lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
<span class="nc" id="L1478">                       &quot;) -&gt; &quot;, u.getRoleSuffix(), &quot;\n&quot;);</span>
<span class="nc" id="L1479">                workers.remove(u);</span>
            } else break;
        }
<span class="fc bfc" id="L1482" title="All 2 branches covered.">        for (Unit u : col.getUnitList()) {</span>
<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">            if (!u.hasDefaultRole()) {</span>
<span class="nc" id="L1484">                logger.warning(&quot;assignWorkers bogus role for &quot; + u);</span>
<span class="nc" id="L1485">                u.changeRole(spec().getDefaultRole(), 0);</span>
            }
        }

        // Log and return the scratch colony on success.
        // Otherwise abandon this rearrangement, disposing of the
        // scratch colony and returning null.
<span class="pc bpc" id="L1492" title="1 of 2 branches missed.">        for (Unit u : workers) {</span>
<span class="nc" id="L1493">            lb.add(&quot;    &quot;, u.getId(), &quot;(&quot;, u.getType().getSuffix(),</span>
<span class="nc" id="L1494">                   &quot;) -&gt; UNUSED\n&quot;);</span>
        }
<span class="pc bpc" id="L1496" title="1 of 2 branches missed.">        if (col.getUnitCount() &lt;= 0) col = null;</span>
<span class="fc" id="L1497">        return col;</span>
    }

    /**
     * Gets a concise textual description of a location associated with
     * the colony.  No i18n here, this is for debugging purposes.
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to describe.
     * @return The text description.
     */
    private String locationDescription(Location loc) {
<span class="fc" id="L1508">        String name = colony.getName() + &quot;-&quot;;</span>
<span class="fc" id="L1509">        String desc = loc.toShortString();</span>
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">        if (desc.startsWith(name)) {</span>
<span class="fc" id="L1511">            desc = desc.substring(name.length(), desc.length());</span>
        }
<span class="fc" id="L1513">        return desc;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L1521">        LogBuilder lb = new LogBuilder(256);</span>
<span class="nc" id="L1522">        lb.add(&quot;ColonyPlan: &quot;, colony,</span>
<span class="nc" id="L1523">            &quot; &quot;, colony.getTile(),</span>
<span class="nc" id="L1524">            &quot;\nProfile: &quot;, profileType, &quot;\nPreferred production:&quot;);</span>
<span class="nc" id="L1525">        FreeColObject.logFreeColObjects(getPreferredProduction(), lb);</span>
<span class="nc" id="L1526">        lb.add(getBuildableReport(), &quot;Food Plans:\n&quot;);</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        for (WorkLocationPlan wlp : getFoodPlans()) {</span>
<span class="nc" id="L1528">            WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1529">            lb.add(locationDescription(wl),</span>
<span class="nc" id="L1530">                &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()), </span>
<span class="nc" id="L1531">                &quot; &quot;, wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
        }
<span class="nc" id="L1533">        lb.add(&quot;Work Plans:\n&quot;);</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">        for (WorkLocationPlan wlp : getWorkPlans()) {</span>
<span class="nc" id="L1535">            WorkLocation wl = wlp.getWorkLocation();</span>
<span class="nc" id="L1536">            lb.add(locationDescription(wl),</span>
<span class="nc" id="L1537">                &quot;: &quot;, wl.getGenericPotential(wlp.getGoodsType()),</span>
<span class="nc" id="L1538">                &quot; &quot;, wlp.getGoodsType().getSuffix(), &quot;\n&quot;);</span>
        }
<span class="nc" id="L1540">        return lb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>src (May 7, 2016 6:04:12 PM)</div></body></html>