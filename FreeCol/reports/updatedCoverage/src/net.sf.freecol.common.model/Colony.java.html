<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Colony.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Colony.java</span></div><h1>Colony.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.Occupation;
import net.sf.freecol.common.model.Stance;
import static net.sf.freecol.common.util.CollectionUtils.*;
import net.sf.freecol.common.util.LogBuilder;
import net.sf.freecol.common.util.RandomChoice;


/**
 * Represents a colony. A colony contains {@link Building}s and
 * {@link ColonyTile}s. The latter represents the tiles around the
 * &lt;code&gt;Colony&lt;/code&gt; where working is possible.
 */
public class Colony extends Settlement implements Nameable, TradeLocation {

<span class="nc" id="L55">    private static final Logger logger = Logger.getLogger(Colony.class.getName());</span>

    public static final String REARRANGE_WORKERS = &quot;rearrangeWorkers&quot;;
    public static final int LIBERTY_PER_REBEL = 200;
    /** The number of turns of advanced warning of starvation. */
    public static final int FAMINE_TURNS = 3;
    
<span class="nc" id="L62">    public static enum ColonyChangeEvent {</span>
<span class="nc" id="L63">        POPULATION_CHANGE,</span>
<span class="nc" id="L64">        PRODUCTION_CHANGE,</span>
<span class="nc" id="L65">        BONUS_CHANGE,</span>
<span class="nc" id="L66">        WAREHOUSE_CHANGE,</span>
<span class="nc" id="L67">        BUILD_QUEUE_CHANGE,</span>
<span class="nc" id="L68">        UNIT_TYPE_CHANGE</span>
    }

    /** Reasons for not building a buildable. */
<span class="nc" id="L72">    public static enum NoBuildReason {</span>
<span class="nc" id="L73">        NONE,</span>
<span class="nc" id="L74">        NOT_BUILDING,</span>
<span class="nc" id="L75">        NOT_BUILDABLE,</span>
<span class="nc" id="L76">        POPULATION_TOO_SMALL,</span>
<span class="nc" id="L77">        MISSING_BUILD_ABILITY,</span>
<span class="nc" id="L78">        MISSING_ABILITY,</span>
<span class="nc" id="L79">        WRONG_UPGRADE,</span>
<span class="nc" id="L80">        COASTAL,</span>
<span class="nc" id="L81">        LIMIT_EXCEEDED</span>
    }

    /** A map of Buildings, indexed by the id of their basic type. */
<span class="nc" id="L85">    protected final java.util.Map&lt;String, Building&gt; buildingMap = new HashMap&lt;&gt;();</span>

    /** A list of the ColonyTiles. */
<span class="nc" id="L88">    protected final List&lt;ColonyTile&gt; colonyTiles = new ArrayList&lt;&gt;();</span>

    /** A map of ExportData, indexed by the ids of GoodsTypes. */
<span class="nc" id="L91">    protected final java.util.Map&lt;String, ExportData&gt; exportData = new HashMap&lt;&gt;();</span>

    /**
     * The number of liberty points.  Liberty points are an
     * abstract game concept.  They are generated by but are not
     * identical to bells, and subject to further modification.
     */
    protected int liberty;

    /** The SoL membership this turn. */
    protected int sonsOfLiberty;

    /** The SoL membership last turn. */
    protected int oldSonsOfLiberty;

    /** The number of tories this turn. */
    protected int tories;

    /** The number of tories last turn. */
    protected int oldTories;

    /** The current production bonus. */
    protected int productionBonus;

    /**
     * The number of immigration points.  Immigration points are an
     * abstract game concept.  They are generated by but are not
     * identical to crosses.
     */
    protected int immigration;

    /** The turn in which this colony was established. */
<span class="nc" id="L123">    protected Turn established = new Turn(0);</span>

    /** A list of items to be built. */
<span class="nc" id="L126">    protected final BuildQueue&lt;BuildableType&gt; buildQueue</span>
<span class="nc" id="L127">        = new BuildQueue&lt;&gt;(this,</span>
<span class="nc" id="L128">            BuildQueue.CompletionAction.REMOVE_EXCEPT_LAST,</span>
<span class="nc" id="L129">            Consumer.COLONY_PRIORITY);</span>

    /** The colonists that may be born. */
<span class="nc" id="L132">    protected final BuildQueue&lt;UnitType&gt; populationQueue</span>
<span class="nc" id="L133">        = new BuildQueue&lt;&gt;(this,</span>
<span class="nc" id="L134">            BuildQueue.CompletionAction.SHUFFLE,</span>
<span class="nc" id="L135">            Consumer.POPULATION_PRIORITY);</span>

    // Will only be used on enemy colonies:
<span class="nc" id="L138">    protected int displayUnitCount = -1;</span>

    // Do not serialize below.

    /** Contains information about production and consumption. */
<span class="nc" id="L143">    private final ProductionCache productionCache = new ProductionCache(this);</span>

    /** The occupation tracing status.  Do not serialize. */
<span class="nc" id="L146">    private boolean traceOccupation = false;</span>



    /**
     * Constructor for ServerColony.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param owner The &lt;code&gt;Player&lt;/code&gt; owning this &lt;code&gt;Colony&lt;/code&gt;.
     * @param name The name of the new &lt;code&gt;Colony&lt;/code&gt;.
     * @param tile The containing &lt;code&gt;Tile&lt;/code&gt;.
     */
    protected Colony(Game game, Player owner, String name, Tile tile) {
<span class="nc" id="L159">        super(game, owner, name, tile);</span>
<span class="nc" id="L160">    }</span>

    /**
     * Create a new &lt;code&gt;Colony&lt;/code&gt; with the given
     * identifier. The object should later be initialized by calling
     * either {@link #readFromXML(FreeColXMLReader)}.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param id The object identifier.
     */
    public Colony(Game game, String id) {
<span class="nc" id="L171">        super(game, id);</span>
<span class="nc" id="L172">    }</span>


    // Primitive accessors.

    /**
     * Gets a &lt;code&gt;List&lt;/code&gt; of every {@link Building} in this
     * &lt;code&gt;Colony&lt;/code&gt;.
     *
     * @return A list of &lt;code&gt;Building&lt;/code&gt;s.
     * @see Building
     */
    public List&lt;Building&gt; getBuildings() {
<span class="nc" id="L185">        synchronized (buildingMap) {</span>
<span class="nc" id="L186">            return new ArrayList&lt;&gt;(buildingMap.values());</span>
        }
    }

    /**
     * Get building of the specified general type (note: *not*
     * necessarily the exact building type supplied, but the building
     * present in the colony that is a descendant of the ultimate
     * ancestor of the specified type).
     *
     * @param type The type of the building to get.
     * @return The &lt;code&gt;Building&lt;/code&gt; found.
     */
    public Building getBuilding(BuildingType type) {
<span class="nc" id="L200">        synchronized (buildingMap) {</span>
<span class="nc" id="L201">            return buildingMap.get(type.getFirstLevel().getId());</span>
        }
    }

    /**
     * Gets a &lt;code&gt;List&lt;/code&gt; of every {@link ColonyTile} in this
     * &lt;code&gt;Colony&lt;/code&gt;.
     *
     * @return A list of &lt;code&gt;ColonyTile&lt;/code&gt;s.
     * @see ColonyTile
     */
    public List&lt;ColonyTile&gt; getColonyTiles() {
<span class="nc" id="L213">        synchronized (colonyTiles) {</span>
<span class="nc" id="L214">            return colonyTiles;</span>
        }
    }

    /**
     * Get the &lt;code&gt;ColonyTile&lt;/code&gt; matching the given
     * &lt;code&gt;Tile&lt;/code&gt;.
     *
     * @param t The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return The corresponding &lt;code&gt;ColonyTile&lt;/code&gt;, or null if not found.
     */
    public ColonyTile getColonyTile(Tile t) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        return find(getColonyTiles(), ct -&gt; ct.getWorkTile() == t);</span>
    }

    /**
     * Get the export date for a goods type.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return The required &lt;code&gt;ExportData&lt;/code&gt;.
     */
    public ExportData getExportData(final GoodsType goodsType) {
<span class="nc" id="L236">        ExportData result = exportData.get(goodsType.getId());</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L238">            result = new ExportData(goodsType, getWarehouseCapacity());</span>
<span class="nc" id="L239">            setExportData(result);</span>
        }
<span class="nc" id="L241">        return result;</span>
    }

    /**
     * Set some export data.
     *
     * @param newExportData A new &lt;code&gt;ExportData&lt;/code&gt; value.
     */
    public final void setExportData(final ExportData newExportData) {
<span class="nc" id="L250">        exportData.put(newExportData.getId(), newExportData);</span>
<span class="nc" id="L251">    }</span>

    /**
     * Gets the liberty points.
     *
     * @return The current liberty.
     */
    public int getLiberty() {
<span class="nc" id="L259">        return liberty;</span>
    }

    /**
     * Gets the production bonus of the colony.
     *
     * @return The current production bonus of the colony.
     */
    public int getProductionBonus() {
<span class="nc" id="L268">        return productionBonus;</span>
    }

    /**
     * Gets the immigration points.
     *
     * @return The current immigration.
     */
    public int getImmigration() {
<span class="nc" id="L277">        return immigration;</span>
    }

    /**
     * Modify the immigration points by amount given.
     *
     * @param amount An amount of immigration.
     */
    public void modifyImmigration(int amount) {
<span class="nc" id="L286">        immigration += amount;</span>
<span class="nc" id="L287">    }</span>

    /**
     * Get the turn this colony was established.
     *
     * @return The establishment &lt;code&gt;Turn&lt;/code&gt;.
     */
    public Turn getEstablished() {
<span class="nc" id="L295">        return established;</span>
    }

    /**
     * Set the turn of establishment.
     *
     * @param newEstablished The new &lt;code&gt;Turn&lt;/code&gt; of establishment.
     */
    public void setEstablished(final Turn newEstablished) {
<span class="nc" id="L304">        this.established = newEstablished;</span>
<span class="nc" id="L305">    }</span>

    /**
     * Get the &lt;code&gt;BuildQueue&lt;/code&gt; contents.
     *
     * @return A list of &lt;code&gt;Buildable&lt;/code&gt;s.
     */
    public List&lt;BuildableType&gt; getBuildQueue() {
<span class="nc" id="L313">        return buildQueue.getValues();</span>
    }

    /**
     * Set the build queue value.
     *
     * @param newBuildQueue A list of new values for the build queue.
     */
    public void setBuildQueue(final List&lt;BuildableType&gt; newBuildQueue) {
<span class="nc" id="L322">        buildQueue.setValues(newBuildQueue);</span>
<span class="nc" id="L323">    }</span>


    // Occupation routines

    /**
     * Gets the occupation tracing status.
     *
     * @return The occupation tracing status.
     */
    public boolean getOccupationTrace() {
<span class="nc" id="L334">        return this.traceOccupation;</span>
    }

    /**
     * Sets the occupation tracing status.
     *
     * @param trace The new occupation tracing status.
     * @return The original occupation tracing status.
     */
    public boolean setOccupationTrace(boolean trace) {
<span class="nc" id="L344">        boolean ret = this.traceOccupation;</span>
<span class="nc" id="L345">        this.traceOccupation = trace;</span>
<span class="nc" id="L346">        return ret;</span>
    }

    private void accumulateChoices(Collection&lt;GoodsType&gt; workTypes,
                                   Collection&lt;GoodsType&gt; tried,
                                   List&lt;Collection&lt;GoodsType&gt;&gt; result) {
<span class="nc" id="L352">        workTypes.removeAll(tried);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (!workTypes.isEmpty()) {</span>
<span class="nc" id="L354">            result.add(workTypes);</span>
<span class="nc" id="L355">            tried.addAll(workTypes);</span>
        }
<span class="nc" id="L357">    }</span>

    private void accumulateChoice(GoodsType workType,
                                  Collection&lt;GoodsType&gt; tried,
                                  List&lt;Collection&lt;GoodsType&gt;&gt; result) {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (workType == null) return;</span>
<span class="nc" id="L363">        accumulateChoices(workType.getEquivalentTypes(), tried, result);</span>
<span class="nc" id="L364">    }</span>

    /**
     * Get a list of collections of goods types, in order of priority
     * to try to produce in this colony by a given unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to check.
     * @param userMode If a user requested this, favour the current
     *     work type, if not favour goods that the unit requires.
     * @return The list of collections of &lt;code&gt;GoodsType&lt;/code&gt;s.
     */
    public List&lt;Collection&lt;GoodsType&gt;&gt; getWorkTypeChoices(Unit unit,
                                                          boolean userMode) {
<span class="nc" id="L377">        final Specification spec = getSpecification();</span>
<span class="nc" id="L378">        List&lt;Collection&lt;GoodsType&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L379">        Set&lt;GoodsType&gt; tried = new HashSet&lt;&gt;();</span>

        // Find the food and non-food goods types required by the unit.
<span class="nc" id="L382">        Set&lt;GoodsType&gt; food = new HashSet&lt;&gt;();</span>
<span class="nc" id="L383">        Set&lt;GoodsType&gt; nonFood = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        for (AbstractGoods ag : unit.getType().getConsumedGoods()) {</span>
<span class="nc" id="L385">            if (productionCache.getNetProductionOf(ag.getType())</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">                &lt; ag.getAmount()) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (ag.getType().isFoodType()) {</span>
<span class="nc" id="L388">                    food.addAll(ag.getType().getEquivalentTypes());</span>
<span class="nc" id="L389">                } else {</span>
<span class="nc" id="L390">                    nonFood.addAll(ag.getType().getEquivalentTypes());</span>
                }
            }
        }

<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (userMode) { // Favour current and expert types in user mode</span>
<span class="nc" id="L396">            accumulateChoice(unit.getWorkType(), tried, result);</span>
<span class="nc" id="L397">            accumulateChoice(unit.getType().getExpertProduction(), tried, result);</span>
<span class="nc" id="L398">            accumulateChoice(unit.getExperienceType(), tried, result);</span>
<span class="nc" id="L399">            accumulateChoices(food, tried, result);</span>
<span class="nc" id="L400">            accumulateChoices(nonFood, tried, result);</span>
<span class="nc" id="L401">        } else { // Otherwise favour the required goods types </span>
<span class="nc" id="L402">            accumulateChoices(food, tried, result);</span>
<span class="nc" id="L403">            accumulateChoices(nonFood, tried, result);</span>
<span class="nc" id="L404">            accumulateChoice(unit.getWorkType(), tried, result);</span>
<span class="nc" id="L405">            accumulateChoice(unit.getType().getExpertProduction(), tried, result);</span>
<span class="nc" id="L406">            accumulateChoice(unit.getExperienceType(), tried, result);</span>
        }
<span class="nc" id="L408">        accumulateChoices(spec.getFoodGoodsTypeList(), tried, result);</span>
<span class="nc" id="L409">        accumulateChoices(spec.getNewWorldLuxuryGoodsTypeList(), tried, result);</span>
<span class="nc" id="L410">        accumulateChoices(spec.getGoodsTypeList(), tried, result);</span>
<span class="nc" id="L411">        return result;</span>
    }

    /**
     * Gets the best occupation for a given unit to produce one of
     * a given set of goods types.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find an
     *     &lt;code&gt;Occupation&lt;/code&gt; for.
     * @param workTypes A collection of &lt;code&gt;GoodsType&lt;/code&gt; to
     *     consider producing.
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null
     *     if none found.
     */
    private Occupation getOccupationFor(Unit unit,
                                        Collection&lt;GoodsType&gt; workTypes,
                                        LogBuilder lb) {
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (workTypes.isEmpty()) return null;</span>

<span class="nc" id="L431">        Occupation best = new Occupation(null, null, null);</span>
<span class="nc" id="L432">        int bestAmount = 0;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="nc" id="L434">            bestAmount = best.improve(unit, wl, bestAmount, workTypes, lb);</span>
        }

<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (best.workLocation != null) {</span>
<span class="nc" id="L438">            lb.add(&quot;\n  =&gt; &quot;, best, &quot; = &quot;, bestAmount);</span>
        }
<span class="nc bnc" id="L440" title="All 2 branches missed.">        return (best.workLocation == null) ? null : best;</span>
    }

    /**
     * Gets the best occupation for a given unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find an
     *     &lt;code&gt;Occupation&lt;/code&gt; for.
     * @param userMode If a user requested this, favour the current
     *     work type, if not favour goods that the unit requires.
     * @param lb A &lt;code&gt;LogBuilder&lt;/code&gt; to log to.
     * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or
     *     null if none found.
     */
    private Occupation getOccupationFor(Unit unit, boolean userMode,
                                        LogBuilder lb) {
<span class="nc bnc" id="L456" title="All 2 branches missed.">        for (Collection&lt;GoodsType&gt; types : getWorkTypeChoices(unit, userMode)) {</span>
<span class="nc" id="L457">            lb.add(&quot;\n  &quot;);</span>
<span class="nc" id="L458">            FreeColObject.logFreeColObjects(types, lb);</span>
<span class="nc" id="L459">            Occupation occupation = getOccupationFor(unit, types, lb);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (occupation != null) return occupation;</span>
        }
<span class="nc" id="L462">        lb.add(&quot;\n  =&gt; FAILED&quot;);</span>
<span class="nc" id="L463">        return null;</span>
    }

    /**
     * Gets the best occupation for a given unit to produce one of
     * a given set of goods types.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find an
     *     &lt;code&gt;Occupation&lt;/code&gt; for.
     * @param workTypes A collection of &lt;code&gt;GoodsType&lt;/code&gt; to
     *     consider producing.
     * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or null
     *     if none found.
     */
    private Occupation getOccupationFor(Unit unit,
                                        Collection&lt;GoodsType&gt; workTypes) {
<span class="nc bnc" id="L479" title="All 2 branches missed.">        LogBuilder lb = new LogBuilder((getOccupationTrace()) ? 64 : 0);</span>
<span class="nc" id="L480">        lb.add(getName(), &quot;.getOccupationFor(&quot;, unit, &quot;, &quot;);</span>
<span class="nc" id="L481">        FreeColObject.logFreeColObjects(workTypes, lb);</span>
<span class="nc" id="L482">        lb.add(&quot;)&quot;);</span>

<span class="nc" id="L484">        Occupation occupation = getOccupationFor(unit, workTypes, lb);</span>
<span class="nc" id="L485">        lb.log(logger, Level.WARNING);</span>
<span class="nc" id="L486">        return occupation;</span>
    }

    /**
     * Gets the best occupation for a given unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to find an
     *     &lt;code&gt;Occupation&lt;/code&gt; for.
     * @param userMode If a user requested this, favour the current
     *     work type, if not favour goods that the unit requires.
     * @return An &lt;code&gt;Occupation&lt;/code&gt; for the given unit, or
     *     null if none found.
     */
    private Occupation getOccupationFor(Unit unit, boolean userMode) {
<span class="nc bnc" id="L500" title="All 2 branches missed.">        LogBuilder lb = new LogBuilder((getOccupationTrace()) ? 64 : 0);</span>
<span class="nc" id="L501">        lb.add(getName(), &quot;.getOccupationFor(&quot;, unit, &quot;)&quot;);</span>

<span class="nc" id="L503">        Occupation occupation = getOccupationFor(unit, userMode, lb);</span>
<span class="nc" id="L504">        lb.log(logger, Level.WARNING);</span>
<span class="nc" id="L505">        return occupation;</span>
    }


    // WorkLocations, Buildings, ColonyTiles

    /**
     * Gets a list of every work location in this colony.
     *
     * @return The list of work locations.
     */
    public List&lt;WorkLocation&gt; getAllWorkLocations() {
<span class="nc" id="L517">        List&lt;WorkLocation&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L518">        synchronized (colonyTiles) {</span>
<span class="nc" id="L519">            ret.addAll(colonyTiles);</span>
        }
<span class="nc" id="L521">        synchronized (buildingMap) {</span>
<span class="nc" id="L522">            ret.addAll(buildingMap.values());</span>
        }
<span class="nc" id="L524">        return ret;</span>
    }

    /**
     * Gets a list of all freely available work locations
     * in this colony.
     *
     * @return The list of available &lt;code&gt;WorkLocation&lt;/code&gt;s.
     */
    public List&lt;WorkLocation&gt; getAvailableWorkLocations() {
<span class="nc" id="L534">        return transform(getAllWorkLocations(),</span>
<span class="nc" id="L535">            WorkLocation::isAvailable, Collectors.toList());</span>
    }

    /**
     * Gets a list of all current work locations in this colony.
     *
     * @return The list of current &lt;code&gt;WorkLocation&lt;/code&gt;s.
     */
    public List&lt;WorkLocation&gt; getCurrentWorkLocations() {
<span class="nc" id="L544">        return transform(getAllWorkLocations(),</span>
<span class="nc" id="L545">            WorkLocation::isCurrent, Collectors.toList());</span>
    }

    /**
     * Add a Building to this Colony.
     *
     * Lower level routine, do not use directly in-game (use buildBuilding).
     * Used for serialization and public for the test suite.
     *
     * -til: Could change the tile appearance if the building is
     * stockade-type
     *
     * @param building The &lt;code&gt;Building&lt;/code&gt; to build.
     * @return True if the building was added.
     */
    public boolean addBuilding(final Building building) {
<span class="nc bnc" id="L561" title="All 4 branches missed.">        if (building == null || building.getType() == null) return false;</span>
<span class="nc" id="L562">        final BuildingType buildingType = building.getType().getFirstLevel();</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">        if (buildingType == null || buildingType.getId() == null) return false;</span>
<span class="nc" id="L564">        synchronized (buildingMap) {</span>
<span class="nc" id="L565">            buildingMap.put(buildingType.getId(), building);</span>
        }
<span class="nc" id="L567">        addFeatures(building.getType());</span>
<span class="nc" id="L568">        return true;</span>
    }

    /**
     * Remove a building from this Colony.
     *
     * -til: Could change the tile appearance if the building is
     * stockade-type
     *
     * @param building The &lt;code&gt;Building&lt;/code&gt; to remove.
     * @return True if the building was removed.
     */
    protected boolean removeBuilding(final Building building) {
<span class="nc" id="L581">        final BuildingType buildingType = building.getType().getFirstLevel();</span>
<span class="nc" id="L582">        synchronized (buildingMap) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            if (buildingMap.remove(buildingType.getId()) == null) return false;</span>
        }
<span class="nc" id="L585">        removeFeatures(building.getType());</span>
<span class="nc" id="L586">        return true;</span>
    }

    /**
     * Gets a building for producing a given type of goods.
     * 
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @return A &lt;code&gt;Building&lt;/code&gt; which produces
     *      the given type of goods, or null if not found.
     */
    public Building getBuildingForProducing(final GoodsType goodsType) {
<span class="nc bnc" id="L597" title="All 2 branches missed.">        for (Building b : getBuildings()) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (AbstractGoods.findByType(goodsType, b.getOutputs()) != null)</span>
<span class="nc" id="L599">                return b;</span>
        }
<span class="nc" id="L601">        return null;</span>
    }

    /**
     * Add a colony tile.
     *
     * @param ct The &lt;code&gt;ColonyTile&lt;/code&gt; to add.
     */
    private void addColonyTile(ColonyTile ct) {
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (ct == null) return;</span>
<span class="nc" id="L611">        synchronized (colonyTiles) {</span>
<span class="nc" id="L612">            colonyTiles.add(ct);</span>
        }
<span class="nc" id="L614">    }</span>

    /**
     * Gets a work location with a given ability.
     *
     * @param ability An ability key.
     * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
     *     &lt;code&gt;Ability&lt;/code&gt;, or null if not found.
     */
    public WorkLocation getWorkLocationWithAbility(String ability) {
<span class="nc bnc" id="L624" title="All 2 branches missed.">        for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (wl.hasAbility(ability)) return wl;</span>
        }
<span class="nc" id="L627">        return null;</span>
    }

    /**
     * Gets a work location of a specific class with a given ability.
     *
     * @param &lt;T&gt; The actual return type.
     * @param ability An ability key.
     * @param returnClass The expected subclass.
     * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
     *     &lt;code&gt;Ability&lt;/code&gt;, or null if not found.
     */
    public &lt;T extends WorkLocation&gt; T getWorkLocationWithAbility(String ability,
        Class&lt;T&gt; returnClass) {
<span class="nc" id="L641">        WorkLocation wl = getWorkLocationWithAbility(ability);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (wl != null) try { return returnClass.cast(wl); } catch (ClassCastException cce) {};</span>
<span class="nc" id="L643">        return null;</span>
    }

    /**
     * Gets a work location with a given modifier.
     *
     * @param modifier A modifier key.
     * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
     *     &lt;code&gt;Modifier&lt;/code&gt;, or null if not found.
     */
    public WorkLocation getWorkLocationWithModifier(String modifier) {
<span class="nc bnc" id="L654" title="All 2 branches missed.">        for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (wl.hasModifier(modifier)) return wl;</span>
        }
<span class="nc" id="L657">        return null;</span>
    }

    /**
     * Gets a work location of a specific class with a given modifier.
     *
     * @param &lt;T&gt; The actual return type.
     * @param modifier A modifier key.
     * @param returnClass The expected subclass.
     * @return A &lt;code&gt;WorkLocation&lt;/code&gt; with the required
     *     &lt;code&gt;Modifier&lt;/code&gt;, or null if not found.
     */
    public &lt;T extends WorkLocation&gt; T getWorkLocationWithModifier(String modifier,
        Class&lt;T&gt; returnClass) {
<span class="nc" id="L671">        WorkLocation wl = getWorkLocationWithModifier(modifier);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (wl != null) try { return returnClass.cast(wl); } catch (ClassCastException cce) {}</span>
<span class="nc" id="L673">        return null;</span>
    }
    
    /**
     * Collect the work locations for consuming a given type of goods.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to consume.
     * @return A list of &lt;code&gt;WorkLocation&lt;/code&gt;s which consume
     *     the given type of goods.
     */
    public List&lt;WorkLocation&gt; getWorkLocationsForConsuming(GoodsType goodsType) {
<span class="nc" id="L684">        return transform(getCurrentWorkLocations(),</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">            wl -&gt; any(wl.getInputs(), ag -&gt; ag.getType() == goodsType),</span>
<span class="nc" id="L686">            Collectors.toList());</span>
    }

    /**
     * Collect the work locations for producing a given type of goods.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @return A list of &lt;code&gt;WorkLocation&lt;/code&gt;s which produce
     *     the given type of goods.
     */
    public List&lt;WorkLocation&gt; getWorkLocationsForProducing(GoodsType goodsType) {
<span class="nc" id="L697">        return transform(getCurrentWorkLocations(),</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            wl -&gt; any(wl.getOutputs(), ag -&gt; ag.getType() == goodsType),</span>
<span class="nc" id="L699">            Collectors.toList());</span>
    }

    /**
     * Find a work location for producing a given type of goods.
     * Beware that this may not be the optimal location for the
     * production, for which {@link #getWorkLocationFor} is better.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @return A &lt;code&gt;WorkLocation&lt;/code&gt;s which produces
     *      the given type of goods, or null if not found.
     */
    public WorkLocation getWorkLocationForProducing(GoodsType goodsType) {
<span class="nc" id="L712">        List&lt;WorkLocation&gt; wls = getWorkLocationsForProducing(goodsType);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">        return (wls.isEmpty()) ? null : wls.get(0);</span>
    }

    /**
     * Gets the work location best suited for the given unit to
     * produce a type of goods.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to get the building for.
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @return The best &lt;code&gt;WorkLocation&lt;/code&gt; found.
     */
    public WorkLocation getWorkLocationFor(Unit unit, GoodsType goodsType) {
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (goodsType == null) return getWorkLocationFor(unit);</span>
<span class="nc" id="L726">        Occupation occupation</span>
<span class="nc" id="L727">            = getOccupationFor(unit, goodsType.getEquivalentTypes());</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        return (occupation == null) ? null : occupation.workLocation;</span>
    }

    /**
     * Gets the work location best suited for the given unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to check for.
     * @return The best &lt;code&gt;WorkLocation&lt;/code&gt; found.
     */
    public WorkLocation getWorkLocationFor(Unit unit) {
<span class="nc" id="L738">        Occupation occupation = getOccupationFor(unit, false);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        return (occupation == null) ? null : occupation.workLocation;</span>
    }

    /**
     * Is a tile actually in use by this colony?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to test.
     * @return True if this tile is actively in use by this colony.
     */
    public boolean isTileInUse(Tile tile) {
<span class="nc" id="L749">        ColonyTile colonyTile = getColonyTile(tile);</span>
<span class="nc bnc" id="L750" title="All 4 branches missed.">        return colonyTile != null &amp;&amp; !colonyTile.isEmpty();</span>
    }

    /**
     * Get the warehouse-type building in this colony.
     *
     * @return The warehouse &lt;code&gt;Building&lt;/code&gt;.
     */
    public Building getWarehouse() {
<span class="nc" id="L759">        return getWorkLocationWithModifier(Modifier.WAREHOUSE_STORAGE,</span>
<span class="nc" id="L760">                                           Building.class);</span>
    }

    /**
     * Does this colony have a stockade?
     *
     * @return True if the colony has a stockade.
     */
    public boolean hasStockade() {
<span class="nc bnc" id="L769" title="All 2 branches missed.">        return getStockade() != null;</span>
    }

    /**
     * Gets the stockade building in this colony.
     *
     * @return The stockade &lt;code&gt;Building&lt;/code&gt;.
     */
    public Building getStockade() {
<span class="nc" id="L778">        return getWorkLocationWithModifier(Modifier.DEFENCE, Building.class);</span>
    }

    /**
     * Gets the stockade key, as should be visible to the owner
     * or a player that can see this colony.
     *
     * @return The stockade key, or null if no stockade-building is present.
     */
    public String getStockadeKey() {
<span class="nc" id="L788">        Building stockade = getStockade();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">        return (stockade == null) ? null : stockade.getType().getSuffix();</span>
    }

    /**
     * Get a weighted list of natural disasters than can strike this
     * colony.  This list comprises all natural disasters that can
     * strike the colony's tiles.
     *
     * @return A weighted list of &lt;code&gt;Disaster&lt;/code&gt;s.
     */
    public List&lt;RandomChoice&lt;Disaster&gt;&gt; getDisasters() {
<span class="nc" id="L800">        List&lt;RandomChoice&lt;Disaster&gt;&gt; disasters = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        for (ColonyTile tile : getColonyTiles()) {</span>
<span class="nc" id="L802">            disasters.addAll(tile.getWorkTile().getDisasters());</span>
        }
<span class="nc" id="L804">        return disasters;</span>
    }


    // What are we building?  What can we build?

    /**
     * Is a building type able to be automatically built at no cost.
     * True when the player has a modifier that collapses the cost to zero.
     *
     * @param buildingType a &lt;code&gt;BuildingType&lt;/code&gt; value
     * @return True if the building is available at zero cost.
     */
    public boolean isAutomaticBuild(BuildingType buildingType) {
<span class="nc" id="L818">        float value = owner.applyModifiers(100f, getGame().getTurn(),</span>
<span class="nc" id="L819">            Modifier.BUILDING_PRICE_BONUS, buildingType);</span>
<span class="nc bnc" id="L820" title="All 4 branches missed.">        return value == 0f &amp;&amp; canBuild(buildingType);</span>
    }

    /**
     * Gets a list of every unit type this colony may build.
     *
     * @return A list of buildable &lt;code&gt;UnitType&lt;/code&gt;s.
     */
    public List&lt;UnitType&gt; getBuildableUnits() {
<span class="nc" id="L829">        return transform(getSpecification().getUnitTypeList().stream(),</span>
<span class="nc bnc" id="L830" title="All 4 branches missed.">            ut -&gt; ut.needsGoodsToBuild() &amp;&amp; canBuild(ut),</span>
<span class="nc" id="L831">            Collectors.toList());</span>
    }

    /**
     * Returns how many turns it would take to build the given
     * &lt;code&gt;BuildableType&lt;/code&gt;.
     *
     * @param buildable The &lt;code&gt;BuildableType&lt;/code&gt; to build.
     * @return The number of turns to build the buildable, negative if
     *     some goods are not being built, UNDEFINED if none is.
     */
    public int getTurnsToComplete(BuildableType buildable) {
<span class="nc" id="L843">        return getTurnsToComplete(buildable, null);</span>
    }

    /**
     * Returns how many turns it would take to build the given
     * &lt;code&gt;BuildableType&lt;/code&gt;.
     *
     * @param buildable The &lt;code&gt;BuildableType&lt;/code&gt; to build.
     * @param needed The &lt;code&gt;AbstractGoods&lt;/code&gt; needed to continue
     *     the build.
     * @return The number of turns to build the buildable (which may
     *     be zero, UNDEFINED if no useful work is being done, negative
     *     if some requirement is or will block completion (value is
     *     the negation of (turns-to-blockage + 1), and if the needed
     *     argument is supplied it is set to the goods deficit).
     */
    public int getTurnsToComplete(BuildableType buildable,
                                  AbstractGoods needed) {
<span class="nc" id="L861">        final List&lt;AbstractGoods&gt; required = buildable.getRequiredGoods();</span>
<span class="nc" id="L862">        int turns = 0, satisfied = 0, failing = 0, underway = 0;</span>
        
<span class="nc" id="L864">        ProductionInfo info = productionCache.getProductionInfo(buildQueue);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        for (AbstractGoods ag : required) {</span>
<span class="nc" id="L866">            final GoodsType type = ag.getType();</span>
<span class="nc" id="L867">            final int amountNeeded = ag.getAmount();</span>
<span class="nc" id="L868">            final int amountAvailable = getGoodsCount(type);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">            if (amountAvailable &gt;= amountNeeded) {</span>
<span class="nc" id="L870">                satisfied++;</span>
<span class="nc" id="L871">                continue;</span>
            }
<span class="nc" id="L873">            int production = productionCache.getNetProductionOf(type);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (info != null) {</span>
<span class="nc" id="L875">                AbstractGoods consumption = AbstractGoods.findByType(type,</span>
<span class="nc" id="L876">                    info.getConsumption());</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">                if (consumption != null) {</span>
                    // add the amount the build queue itself will consume
<span class="nc" id="L879">                    production += consumption.getAmount();</span>
                }
            }
<span class="nc bnc" id="L882" title="All 2 branches missed.">            if (production &lt;= 0) {</span>
<span class="nc" id="L883">                failing++;</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                if (needed != null) {</span>
<span class="nc" id="L885">                    needed.setType(type);</span>
<span class="nc" id="L886">                    needed.setAmount(amountNeeded - amountAvailable);</span>
                }
<span class="nc" id="L888">                continue;</span>
            }

<span class="nc" id="L891">            underway++;</span>
<span class="nc" id="L892">            int amountRemaining = amountNeeded - amountAvailable;</span>
<span class="nc" id="L893">            int eta = amountRemaining / production;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">            if (amountRemaining % production != 0) eta++;</span>
<span class="nc" id="L895">            turns = Math.max(turns, eta);</span>
        }

<span class="nc bnc" id="L898" title="All 2 branches missed.">        return (satisfied + underway == required.size()) ? turns // Will finish</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            : (failing == required.size()) ? UNDEFINED // Not even trying</span>
<span class="nc" id="L900">            : -(turns + 1); // Blocked by something</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this Colony can breed the given
     * type of Goods. Only animals (such as horses) are expected to be
     * breedable.
     *
     * @param goodsType a &lt;code&gt;GoodsType&lt;/code&gt; value
     * @return a &lt;code&gt;boolean&lt;/code&gt; value
     */
    public boolean canBreed(GoodsType goodsType) {
<span class="nc" id="L912">        int breedingNumber = goodsType.getBreedingNumber();</span>
<span class="nc bnc" id="L913" title="All 4 branches missed.">        return (breedingNumber &lt; GoodsType.INFINITY &amp;&amp;</span>
<span class="nc" id="L914">                breedingNumber &lt;= getGoodsCount(goodsType));</span>
    }

    /**
     * Gets the type of building currently being built.
     *
     * @return The type of building currently being built.
     */
    public BuildableType getCurrentlyBuilding() {
<span class="nc" id="L923">        return buildQueue.getCurrentlyBuilding();</span>
    }

    /**
     * Sets the current type of buildable to be built and if it is a building
     * insist that there is only one in the queue.
     *
     * @param buildable The &lt;code&gt;BuildableType&lt;/code&gt; to build.
     */
    public void setCurrentlyBuilding(BuildableType buildable) {
<span class="nc" id="L933">        buildQueue.setCurrentlyBuilding(buildable);</span>
<span class="nc" id="L934">    }</span>

    public boolean canBuild() {
<span class="nc" id="L937">        return canBuild(getCurrentlyBuilding());</span>
    }

    /**
     * Returns true if this Colony can build the given BuildableType.
     *
     * @param buildableType a &lt;code&gt;BuildableType&lt;/code&gt; value
     * @return a &lt;code&gt;boolean&lt;/code&gt; value
     */
    public boolean canBuild(BuildableType buildableType) {
<span class="nc bnc" id="L947" title="All 2 branches missed.">        return getNoBuildReason(buildableType, null) == NoBuildReason.NONE;</span>
    }

    /**
     * Return the reason why the give &lt;code&gt;BuildableType&lt;/code&gt; can
     * not be built.
     *
     * @param buildableType A &lt;code&gt;BuildableType&lt;/code&gt; to build.
     * @param assumeBuilt An optional list of other buildable types
     *     which can be assumed to be built, for the benefit of build
     *     queue checks.
     * @return A &lt;code&gt;NoBuildReason&lt;/code&gt; value decribing the failure,
     *     including &lt;code&gt;NoBuildReason.NONE&lt;/code&gt; on success.
     */
    public NoBuildReason getNoBuildReason(BuildableType buildableType,
                                          List&lt;BuildableType&gt; assumeBuilt) {
<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (buildableType == null) {</span>
<span class="nc" id="L964">            return NoBuildReason.NOT_BUILDING;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">        } else if (!buildableType.needsGoodsToBuild()) {</span>
<span class="nc" id="L966">            return NoBuildReason.NOT_BUILDABLE;</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">        } else if (buildableType.getRequiredPopulation() &gt; getUnitCount()) {</span>
<span class="nc" id="L968">            return NoBuildReason.POPULATION_TOO_SMALL;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">        } else if (buildableType.hasAbility(Ability.COASTAL_ONLY)</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">            &amp;&amp; !getTile().isCoastland()) {</span>
<span class="nc" id="L971">            return NoBuildReason.COASTAL;</span>
        } else {
<span class="nc" id="L973">            if (!all(buildableType.getRequiredAbilities().entrySet(),</span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">                    e -&gt; e.getValue() == hasAbility(e.getKey()))) {</span>
<span class="nc" id="L975">                return NoBuildReason.MISSING_ABILITY;</span>
            }
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (!all(buildableType.getLimits(), l -&gt; l.evaluate(this))) {</span>
<span class="nc" id="L978">                return NoBuildReason.LIMIT_EXCEEDED;</span>
            }
        }
<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (assumeBuilt == null) {</span>
<span class="nc" id="L982">            assumeBuilt = Collections.&lt;BuildableType&gt;emptyList();</span>
        }
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (buildableType instanceof BuildingType) {</span>
<span class="nc" id="L985">            BuildingType newBuildingType = (BuildingType) buildableType;</span>
<span class="nc" id="L986">            Building colonyBuilding = this.getBuilding(newBuildingType);</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            if (colonyBuilding == null) {</span>
                // the colony has no similar building yet
<span class="nc" id="L989">                BuildingType from = newBuildingType.getUpgradesFrom();</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">                if (from != null &amp;&amp; !assumeBuilt.contains(from)) {</span>
                    // we are trying to build an advanced factory, we
                    // should build lower level shop first
<span class="nc" id="L993">                    return NoBuildReason.WRONG_UPGRADE;</span>
                }
            } else {
                // a building of the same family already exists
<span class="nc" id="L997">                BuildingType from = colonyBuilding.getType().getUpgradesTo();</span>
<span class="nc bnc" id="L998" title="All 4 branches missed.">                if (from != newBuildingType &amp;&amp; !assumeBuilt.contains(from)) {</span>
                    // the existing building's next upgrade is not the
                    // new one we want to build
<span class="nc" id="L1001">                    return NoBuildReason.WRONG_UPGRADE;</span>
                }
            }
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        } else if (buildableType instanceof UnitType) {</span>
            // Non-person units need a BUILD ability, present or assumed.
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            if (!buildableType.hasAbility(Ability.PERSON)</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                &amp;&amp; !hasAbility(Ability.BUILD, buildableType)</span>
<span class="nc" id="L1008">                &amp;&amp; none(assumeBuilt, bt -&gt; bt.hasAbility(Ability.BUILD,</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                        buildableType))) {</span>
<span class="nc" id="L1010">                return NoBuildReason.MISSING_BUILD_ABILITY;</span>
            }
        }
<span class="nc" id="L1013">        return NoBuildReason.NONE;</span>
    }

    /**
     * Returns the price for the remaining hammers and tools for the
     * {@link Building} that is currently being built.
     *
     * @return The price.
     * @see net.sf.freecol.client.control.InGameController#payForBuilding
     */
    public int getPriceForBuilding() {
<span class="nc" id="L1024">        return getPriceForBuilding(getCurrentlyBuilding());</span>
    }

    /**
     * Gets the price for the remaining resources to build a given buildable.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to build.
     * @return The price.
     * @see net.sf.freecol.client.control.InGameController#payForBuilding
     */
    public int getPriceForBuilding(BuildableType type) {
<span class="nc" id="L1035">        return priceGoodsForBuilding(getRequiredGoods(type));</span>
    }

    /**
     * Gets a price for a map of resources to build a given buildable.
     *
     * @param required A list of required &lt;code&gt;AbstractGoods&lt;/code&gt;.
     * @return The price.
     * @see net.sf.freecol.client.control.InGameController#payForBuilding
     */
    public int priceGoodsForBuilding(List&lt;AbstractGoods&gt; required) {
<span class="nc" id="L1046">        final Market market = getOwner().getMarket();</span>
        // FIXME: magic number!
<span class="nc" id="L1048">        return sum(required,</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">            ag -&gt; (ag.getType().isStorable())</span>
<span class="nc" id="L1050">                ? (market.getBidPrice(ag.getType(), ag.getAmount()) * 110)/100</span>
<span class="nc" id="L1051">                : ag.getType().getPrice() * ag.getAmount());</span>
    }

    /**
     * Gets a map of the types of goods and amount thereof required to
     * finish a buildable in this colony.
     *
     * @param type The &lt;code&gt;BuildableType&lt;/code&gt; to build.
     * @return The map to completion.
     */
    public List&lt;AbstractGoods&gt; getRequiredGoods(BuildableType type) {
<span class="nc" id="L1062">        return transform(type.getRequiredGoods(),</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            ag -&gt; ag.getAmount() &gt; getGoodsCount(ag.getType()),</span>
<span class="nc" id="L1064">            ag -&gt; new AbstractGoods(ag.getType(),</span>
<span class="nc" id="L1065">                ag.getAmount() - getGoodsCount(ag.getType())),</span>
<span class="nc" id="L1066">            Collectors.toList());</span>
    }

    /**
     * Gets all the goods required to complete a build.  The list
     * includes the prerequisite raw materials as well as the direct
     * requirements (i.e. hammers, tools).  If enough of a required
     * goods is present in the colony, then that type is not returned.
     * Take care to order types with raw materials first so that we
     * can prioritize gathering what is required before manufacturing.
     *
     * Public for the benefit of AI planning and the test suite.
     *
     * @param buildable The &lt;code&gt;BuildableType&lt;/code&gt; to consider.
     * @return A list of required abstract goods.
     */
    public List&lt;AbstractGoods&gt; getFullRequiredGoods(BuildableType buildable) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (buildable == null) return Collections.&lt;AbstractGoods&gt;emptyList();</span>

<span class="nc" id="L1085">        List&lt;AbstractGoods&gt; required = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        for (AbstractGoods ag : buildable.getRequiredGoods()) {</span>
<span class="nc" id="L1087">            int amount = ag.getAmount();</span>
<span class="nc" id="L1088">            GoodsType type = ag.getType();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            while (type != null) {</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                if (amount &lt;= this.getGoodsCount(type)) break; // Shortcut</span>
<span class="nc" id="L1091">                required.add(0, new AbstractGoods(type,</span>
<span class="nc" id="L1092">                        amount - this.getGoodsCount(type)));</span>
<span class="nc" id="L1093">                type = type.getInputType();</span>
            }
        }
<span class="nc" id="L1096">        return required;</span>
    }

    /**
     * Check if the owner can buy the remaining hammers and tools for
     * the {@link Building} that is currently being built.
     *
     * @return True if the user can afford to pay.
     * @exception IllegalStateException If the owner of this
     *     &lt;code&gt;Colony&lt;/code&gt; has an insufficient amount of gold.
     * @see #getPriceForBuilding
     */
    public boolean canPayToFinishBuilding() {
<span class="nc" id="L1109">        return canPayToFinishBuilding(getCurrentlyBuilding());</span>
    }

    /**
     * Check if the owner can buy the remaining hammers and tools for
     * the {@link Building} given.
     *
     * @param buildableType a &lt;code&gt;BuildableType&lt;/code&gt; value
     * @return True if the user can afford to pay.
     * @exception IllegalStateException If the owner of this
     *     &lt;code&gt;Colony&lt;/code&gt; has an insufficient amount of gold.
     * @see #getPriceForBuilding
     */
    public boolean canPayToFinishBuilding(BuildableType buildableType) {
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        return buildableType != null</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">            &amp;&amp; getOwner().checkGold(getPriceForBuilding(buildableType));</span>
    }


    // Liberty and the consequences

    /**
     * Adds to the liberty points by increasing the liberty goods present.
     * Used only by DebugMenu.
     *
     * @param amount The number of liberty to add.
     */
    public void addLiberty(int amount) {
<span class="nc" id="L1137">        List&lt;GoodsType&gt; libertyTypeList = getSpecification()</span>
<span class="nc" id="L1138">            .getLibertyGoodsTypeList();</span>
<span class="nc" id="L1139">        final int uc = getUnitCount();</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        if (calculateRebels(uc, sonsOfLiberty) &lt;= uc + 1</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            &amp;&amp; amount &gt; 0</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            &amp;&amp; !libertyTypeList.isEmpty()) {</span>
<span class="nc" id="L1143">            addGoods(libertyTypeList.get(0), amount);</span>
        }
<span class="nc" id="L1145">        updateSoL();</span>
<span class="nc" id="L1146">        updateProductionBonus();</span>
<span class="nc" id="L1147">    }</span>

    /**
     * Modify the liberty points by amount given.
     *
     * @param amount An amount of liberty.
     */
    public void modifyLiberty(int amount) {
        // Produced liberty always applies to the player (for FFs etc)
<span class="nc" id="L1156">        getOwner().modifyLiberty(amount);</span>

<span class="nc" id="L1158">        liberty += amount;</span>
        // Liberty can not meaningfully go negative.
<span class="nc" id="L1160">        liberty = Math.max(0, liberty);</span>

<span class="nc" id="L1162">        updateSoL();</span>
<span class="nc" id="L1163">        updateProductionBonus();</span>

        // If the bell accumulation cap option is set, and the colony
        // has reached 100%, liberty can not rise higher.
<span class="nc" id="L1167">        boolean capped = getSpecification()</span>
<span class="nc" id="L1168">            .getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);</span>
<span class="nc bnc" id="L1169" title="All 4 branches missed.">        if (capped &amp;&amp; sonsOfLiberty &gt;= 100) {</span>
<span class="nc" id="L1170">            liberty = LIBERTY_PER_REBEL * getUnitCount();</span>
        }
<span class="nc" id="L1172">    }</span>

    /**
     * Calculates the current SoL membership of the colony based on
     * the liberty value and colonists.
     */
    public void updateSoL() {
<span class="nc" id="L1179">        int uc = getUnitCount();</span>
<span class="nc" id="L1180">        oldSonsOfLiberty = sonsOfLiberty;</span>
<span class="nc" id="L1181">        oldTories = tories;</span>
<span class="nc" id="L1182">        sonsOfLiberty = calculateSoLPercentage(uc, getLiberty());</span>
<span class="nc" id="L1183">        tories = uc - calculateRebels(uc, sonsOfLiberty);</span>
<span class="nc" id="L1184">    }</span>

    /**
     * Calculate the SoL membership percentage of the colony based on the
     * number of colonists and liberty.
     *
     * @param uc The proposed number of units in the colony.
     * @param liberty The amount of liberty.
     * @return The percentage of SoLs, negative if not calculable.
     */
    private int calculateSoLPercentage(int uc, int liberty) {
<span class="nc bnc" id="L1195" title="All 2 branches missed.">        if (uc &lt;= 0) return -1;</span>

<span class="nc" id="L1197">        float membership = (liberty * 100.0f) / (LIBERTY_PER_REBEL * uc);</span>
<span class="nc" id="L1198">        membership = applyModifiers(membership, getGame().getTurn(),</span>
<span class="nc" id="L1199">                                    getOwner().getModifiers(Modifier.SOL));</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">        if (membership &lt; 0.0f) {</span>
<span class="nc" id="L1201">            membership = 0.0f;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        } else if (membership &gt; 100.0f) {</span>
<span class="nc" id="L1203">            membership = 100.0f;</span>
        }
<span class="nc" id="L1205">        return (int)membership;</span>
    }

    /**
     * Calculate the SoL membership percentage of a colony.
     *
     * @return The percentage of SoLs, negative if not calculable.
     */
    public int getSoLPercentage() {
<span class="nc" id="L1214">        return calculateSoLPercentage(getUnitCount(), getLiberty());</span>
    }

    /**
     * Calculate the number of rebels given a SoL percentage and unit count.
     *
     * @param uc The number of units in the colony.
     * @param solPercent The percentage of SoLs.
     * @return The number of rebels.
     */
    public static int calculateRebels(int uc, int solPercent) {
<span class="nc" id="L1225">        return (int)Math.floor(0.01 * solPercent * uc);</span>
    }

    /**
     * Gets the Tory membership percentage of the colony.
     *
     * @return The current Tory membership of the colony.
     */
    public int getTory() {
<span class="nc" id="L1234">        return 100 - getSoL();</span>
    }

    /**
     * Update the colony's production bonus.
     *
     * @return True if the bonus changed.
     */
    protected boolean updateProductionBonus() {
<span class="nc" id="L1243">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1244">        final int veryBadGovernment</span>
<span class="nc" id="L1245">            = spec.getInteger(&quot;model.option.veryBadGovernmentLimit&quot;);</span>
<span class="nc" id="L1246">        final int badGovernment</span>
<span class="nc" id="L1247">            = spec.getInteger(&quot;model.option.badGovernmentLimit&quot;);</span>
<span class="nc" id="L1248">        final int veryGoodGovernment</span>
<span class="nc" id="L1249">            = spec.getInteger(&quot;model.option.veryGoodGovernmentLimit&quot;);</span>
<span class="nc" id="L1250">        final int goodGovernment</span>
<span class="nc" id="L1251">            = spec.getInteger(&quot;model.option.goodGovernmentLimit&quot;);</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        int newBonus = (sonsOfLiberty &gt;= veryGoodGovernment) ? 2</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">            : (sonsOfLiberty &gt;= goodGovernment) ? 1</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">            : (tories &gt; veryBadGovernment) ? -2</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">            : (tories &gt; badGovernment) ? -1</span>
<span class="nc" id="L1256">            : 0;</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">        if (productionBonus != newBonus) {</span>
<span class="nc" id="L1258">            invalidateCache();</span>
<span class="nc" id="L1259">            productionBonus = newBonus;</span>
<span class="nc" id="L1260">            return true;</span>
        }
<span class="nc" id="L1262">        return false;</span>
    }

    /**
     * Gets the number of units that would be good to add/remove from this
     * colony.  That is the number of extra units that can be added without
     * damaging the production bonus, or the number of units to remove to
     * improve it.
     *
     * @return The number of units to add to the colony, or if negative
     *      the negation of the number of units to remove.
     */
    public int getPreferredSizeChange() {
<span class="nc" id="L1275">        int i, limit, pop = getUnitCount();</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (productionBonus &lt; 0) {</span>
<span class="nc" id="L1277">            limit = pop;</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            for (i = 1; i &lt; limit; i++) {</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                if (governmentChange(pop - i) == 1) break;</span>
            }
<span class="nc" id="L1281">            return -i;</span>
        } else {
<span class="nc" id="L1283">            final Specification spec = getSpecification();</span>
<span class="nc" id="L1284">            limit = spec.getInteger(&quot;model.option.badGovernmentLimit&quot;);</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">            for (i = 1; i &lt; limit; i++) {</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                if (governmentChange(pop + i) == -1) break;</span>
            }
<span class="nc" id="L1288">            return i - 1;</span>
        }
    }


    // Unit manipulation and population

    /**
     * Special routine to handle non-specific add of unit to colony.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to add.
     * @return True if the add succeeds.
     */
    public boolean joinColony(Unit unit) {
        boolean ret;
<span class="nc" id="L1303">        Occupation occupation = getOccupationFor(unit, false);</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (occupation == null) {</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">            if (!traceOccupation) {</span>
<span class="nc" id="L1306">                LogBuilder lb = new LogBuilder(64);</span>
<span class="nc" id="L1307">                getOccupationFor(unit, false, lb);</span>
<span class="nc" id="L1308">                lb.log(logger, Level.WARNING);</span>
            }
<span class="nc" id="L1310">            ret = false;</span>
<span class="nc" id="L1311">        } else {</span>
<span class="nc" id="L1312">            ret = occupation.install(unit);</span>
        }
<span class="nc bnc" id="L1314" title="All 2 branches missed.">        if (!ret) {</span>
<span class="nc" id="L1315">            unit.setLocation(getTile()); // Fall back to safe value</span>
<span class="nc" id="L1316">            logger.warning(&quot;Failed to join &quot; + getName() + &quot;: &quot; + unit);</span>
        }
<span class="nc" id="L1318">        return ret;</span>
    }

    /**
     * Can this colony reduce its population voluntarily?
     *
     * This is generally the case, but can be prevented by buildings
     * such as the stockade in classic mode.
     *
     * @return True if the population can be reduced.
     */
    public boolean canReducePopulation() {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        return getUnitCount() &gt; applyModifiers(0f, getGame().getTurn(),</span>
<span class="nc" id="L1331">                                               Modifier.MINIMUM_COLONY_SIZE);</span>
    }

    /**
     * Gets the message to display if the colony can not reduce its
     * population.
     *
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing why a colony
     *     can not reduce its population, or null if it can.
     */
    public StringTemplate getReducePopulationMessage() {
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (canReducePopulation()) return null;</span>
<span class="nc" id="L1343">        Set&lt;Modifier&gt; modifierSet = getModifiers(Modifier.MINIMUM_COLONY_SIZE);</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (modifierSet.isEmpty()) return null;</span>
<span class="nc" id="L1345">        Modifier modifier = modifierSet.iterator().next();</span>
<span class="nc" id="L1346">        FreeColObject source = modifier.getSource();</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (source instanceof BuildingType) {</span>
            // If the modifier source is a building type, use the
            // building in the colony, which may be of a different
            // level to the modifier source.
            // This prevents the stockade modifier from matching a
            // colony-fort, and thus the message attributing the
            // failure to reduce population to a non-existing
            // stockade, BR#3522055.
<span class="nc" id="L1355">            source = getBuilding((BuildingType)source).getType();</span>
        }
<span class="nc" id="L1357">        return StringTemplate.template(&quot;model.colony.minimumColonySize&quot;)</span>
<span class="nc" id="L1358">            .addName(&quot;%object%&quot;, source);</span>
    }

    /**
     * Gets the message to display if a colony can not build something.
     *
     * @param buildable The &lt;code&gt;BuildableType&lt;/code&gt; that can not be built.
     * @return A &lt;code&gt;ModelMessage&lt;/code&gt; describing the build failure.
     */
    public ModelMessage getUnbuildableMessage(BuildableType buildable) {
<span class="nc" id="L1368">        return new ModelMessage(ModelMessage.MessageType.WARNING,</span>
<span class="nc" id="L1369">                                &quot;model.colony.unbuildable&quot;, this, buildable)</span>
<span class="nc" id="L1370">            .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L1371">            .addNamed(&quot;%object%&quot;, buildable);</span>
    }

    /**
     * Returns 1, 0, or -1 to indicate that government would improve,
     * remain the same, or deteriorate if the colony had the given
     * population.
     *
     * @param unitCount The proposed population for the colony.
     * @return 1, 0 or -1.
     */
    public int governmentChange(int unitCount) {
<span class="nc" id="L1383">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1384">        final int veryBadGovernment</span>
<span class="nc" id="L1385">            = spec.getInteger(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1386">        final int badGovernment</span>
<span class="nc" id="L1387">            = spec.getInteger(GameOptions.BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1388">        final int veryGoodGovernment</span>
<span class="nc" id="L1389">            = spec.getInteger(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1390">        final int goodGovernment</span>
<span class="nc" id="L1391">            = spec.getInteger(GameOptions.GOOD_GOVERNMENT_LIMIT);</span>

<span class="nc" id="L1393">        int rebelPercent = calculateSoLPercentage(unitCount, getLiberty());</span>
<span class="nc" id="L1394">        int rebelCount = calculateRebels(unitCount, rebelPercent);</span>
<span class="nc" id="L1395">        int loyalistCount = unitCount - rebelCount;</span>

<span class="nc" id="L1397">        int result = 0;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">        if (rebelPercent &gt;= veryGoodGovernment) { // There are no tories left.</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">            if (sonsOfLiberty &lt; veryGoodGovernment) {</span>
<span class="nc" id="L1400">                result = 1;</span>
            }
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        } else if (rebelPercent &gt;= goodGovernment) {</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">            if (sonsOfLiberty &gt;= veryGoodGovernment) {</span>
<span class="nc" id="L1404">                result = -1;</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">            } else if (sonsOfLiberty &lt; goodGovernment) {</span>
<span class="nc" id="L1406">                result = 1;</span>
            }
<span class="nc" id="L1408">        } else {</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (sonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc" id="L1410">                result = -1;</span>
<span class="nc" id="L1411">            } else { // Now that no bonus is applied, penalties may.</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">                if (loyalistCount &gt; veryBadGovernment) {</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">                    if (tories &lt;= veryBadGovernment) {</span>
<span class="nc" id="L1414">                        result = -1;</span>
                    }
<span class="nc bnc" id="L1416" title="All 2 branches missed.">                } else if (loyalistCount &gt; badGovernment) {</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                    if (tories &lt;= badGovernment) {</span>
<span class="nc" id="L1418">                        result = -1;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                    } else if (tories &gt; veryBadGovernment) {</span>
<span class="nc" id="L1420">                        result = 1;</span>
                    }
<span class="nc" id="L1422">                } else {</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                    if (tories &gt; badGovernment) {</span>
<span class="nc" id="L1424">                        result = 1;</span>
                    }
                }
            }
        }
<span class="nc" id="L1429">        return result;</span>
    }

    public ModelMessage checkForGovMgtChangeMessage() {
<span class="nc" id="L1433">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1434">        final int veryBadGovernment</span>
<span class="nc" id="L1435">            = spec.getInteger(GameOptions.VERY_BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1436">        final int badGovernment</span>
<span class="nc" id="L1437">            = spec.getInteger(GameOptions.BAD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1438">        final int veryGoodGovernment</span>
<span class="nc" id="L1439">            = spec.getInteger(GameOptions.VERY_GOOD_GOVERNMENT_LIMIT);</span>
<span class="nc" id="L1440">        final int goodGovernment</span>
<span class="nc" id="L1441">            = spec.getInteger(GameOptions.GOOD_GOVERNMENT_LIMIT);</span>

<span class="nc" id="L1443">        String msgId = null;</span>
<span class="nc" id="L1444">        int number = 0;</span>
<span class="nc" id="L1445">        ModelMessage.MessageType msgType = ModelMessage.MessageType.GOVERNMENT_EFFICIENCY;</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        if (sonsOfLiberty &gt;= veryGoodGovernment) {</span>
            // there are no tories left
<span class="nc bnc" id="L1448" title="All 2 branches missed.">            if (oldSonsOfLiberty &lt; veryGoodGovernment) {</span>
<span class="nc" id="L1449">                msgId = &quot;model.colony.veryGoodGovernment&quot;;</span>
<span class="nc" id="L1450">                msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1451">                number = veryGoodGovernment;</span>
            }
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        } else if (sonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            if (oldSonsOfLiberty == veryGoodGovernment) {</span>
<span class="nc" id="L1455">                msgId = &quot;model.colony.lostVeryGoodGovernment&quot;;</span>
<span class="nc" id="L1456">                msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1457">                number = veryGoodGovernment;</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">            } else if (oldSonsOfLiberty &lt; goodGovernment) {</span>
<span class="nc" id="L1459">                msgId = &quot;model.colony.goodGovernment&quot;;</span>
<span class="nc" id="L1460">                msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1461">                number = goodGovernment;</span>
            }
<span class="nc" id="L1463">        } else {</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">            if (oldSonsOfLiberty &gt;= goodGovernment) {</span>
<span class="nc" id="L1465">                msgId = &quot;model.colony.lostGoodGovernment&quot;;</span>
<span class="nc" id="L1466">                msgType = ModelMessage.MessageType.SONS_OF_LIBERTY;</span>
<span class="nc" id="L1467">                number = goodGovernment;</span>
            }

            // Now that no bonus is applied, penalties may.
<span class="nc bnc" id="L1471" title="All 2 branches missed.">            if (tories &gt; veryBadGovernment) {</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                if (oldTories &lt;= veryBadGovernment) {</span>
                    // government has become very bad
<span class="nc" id="L1474">                    msgId = &quot;model.colony.veryBadGovernment&quot;;</span>
                }
<span class="nc bnc" id="L1476" title="All 2 branches missed.">            } else if (tories &gt; badGovernment) {</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">                if (oldTories &lt;= badGovernment) {</span>
                    // government has become bad
<span class="nc" id="L1479">                    msgId = &quot;model.colony.badGovernment&quot;;</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">                } else if (oldTories &gt; veryBadGovernment) {</span>
                    // government has improved, but is still bad
<span class="nc" id="L1482">                    msgId = &quot;model.colony.governmentImproved1&quot;;</span>
                }
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            } else if (oldTories &gt; badGovernment) {</span>
                // government was bad, but has improved
<span class="nc" id="L1486">                msgId = &quot;model.colony.governmentImproved2&quot;;</span>
            }
        }

<span class="nc" id="L1490">        GoodsType bells = getSpecification().getGoodsType(&quot;model.goods.bells&quot;);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        return (msgId == null) ? null</span>
<span class="nc" id="L1492">            : new ModelMessage(msgType, msgId, this, bells)</span>
<span class="nc" id="L1493">                .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L1494">                .addAmount(&quot;%number%&quot;, number);</span>
    }

    /**
     * Signal to the colony that its population is changing.
     * Called from Unit.setLocation when a unit moves into or out of this
     * colony, but *not* if it is moving within the colony.
     */
    public void updatePopulation() {
<span class="nc" id="L1503">        updateSoL();</span>
<span class="nc" id="L1504">        updateProductionBonus();</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">        if (getOwner().isAI()) {</span>
<span class="nc" id="L1506">            firePropertyChange(Colony.REARRANGE_WORKERS, true, false);</span>
        }
<span class="nc" id="L1508">    }</span>

    /**
     * Signal to the colony that a unit is moving in or out or
     * changing its internal work location to one with a different
     * teaching ability.  This requires either checking for a new
     * teacher or student, or clearing any existing education
     * relationships.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is changing its education state.
     * @param enable If true, check for new education opportunities, otherwise
     *     clear existing ones.
     */
    public void updateEducation(Unit unit, boolean enable) {
<span class="nc" id="L1522">        WorkLocation wl = unit.getWorkLocation();</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">        if (wl == null) {</span>
<span class="nc" id="L1524">            throw new RuntimeException(&quot;updateEducation(&quot; + unit</span>
<span class="nc" id="L1525">                + &quot;) unit not at work location.&quot;);</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">        } else if (wl.getColony() != this) {</span>
<span class="nc" id="L1527">            throw new RuntimeException(&quot;updateEducation(&quot; + unit</span>
<span class="nc" id="L1528">                + &quot;) unit not at work location in this colony.&quot;);</span>
        }
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        if (enable) {</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">            if (wl.canTeach()) {</span>
<span class="nc" id="L1532">                Unit student = unit.getStudent();</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (student == null</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                    &amp;&amp; (student = findStudent(unit)) != null) {</span>
<span class="nc" id="L1535">                    unit.setStudent(student);</span>
<span class="nc" id="L1536">                    student.setTeacher(unit);</span>
<span class="nc" id="L1537">                    unit.setTurnsOfTraining(0);// Teacher starts teaching</span>
<span class="nc" id="L1538">                    unit.changeWorkType(null);</span>
                }
<span class="nc" id="L1540">            } else {</span>
<span class="nc" id="L1541">                Unit teacher = unit.getTeacher();</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">                if (teacher == null</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                    &amp;&amp; (teacher = findTeacher(unit)) != null) {</span>
<span class="nc" id="L1544">                    unit.setTeacher(teacher);</span>
<span class="nc" id="L1545">                    teacher.setStudent(unit);</span>
                }
            }
<span class="nc" id="L1548">        } else {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            if (wl.canTeach()) {</span>
<span class="nc" id="L1550">                Unit student = unit.getStudent();</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if (student != null) {</span>
<span class="nc" id="L1552">                    student.setTeacher(null);</span>
<span class="nc" id="L1553">                    unit.setStudent(null);</span>
<span class="nc" id="L1554">                    unit.setTurnsOfTraining(0);// Teacher stops teaching</span>
                }
<span class="nc" id="L1556">            } else {</span>
<span class="nc" id="L1557">                Unit teacher = unit.getTeacher();</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if (teacher != null) {</span>
<span class="nc" id="L1559">                    teacher.setStudent(null);</span>
<span class="nc" id="L1560">                    unit.setTeacher(null);</span>
                }
            }
        }
<span class="nc" id="L1564">    }</span>

    /**
     * Does this colony have undead units?
     *
     * @return True if this colony has undead units.
     */
    public boolean isUndead() {
<span class="nc" id="L1572">        Unit u = getFirstUnit();</span>
<span class="nc bnc" id="L1573" title="All 4 branches missed.">        return u != null &amp;&amp; u.isUndead();</span>
    }

    /**
     * Gets the apparent number of units at this colony.
     * Used in client enemy colonies
     *
     * @return The apparent number of &lt;code&gt;Unit&lt;/code&gt;s at this colony.
     */
    public int getDisplayUnitCount() {
<span class="nc bnc" id="L1583" title="All 2 branches missed.">        return (displayUnitCount &gt; 0) ? displayUnitCount : getUnitCount();</span>
    }

    /**
     * Sets the apparent number of units at this colony.
     * Used in client enemy colonies
     *
     * @param count The new apparent number of &lt;code&gt;Unit&lt;/code&gt;s at
     *     this colony.
     */
    public void setDisplayUnitCount(int count) {
<span class="nc" id="L1594">        this.displayUnitCount = count;</span>
<span class="nc" id="L1595">    }</span>


    // Defence, offense and trade response

    /**
     * Gets the best defender type available to this colony.
     *
     * @return The best available defender type.
     */
    public UnitType getBestDefenderType() {
<span class="nc" id="L1606">        final Predicate&lt;UnitType&gt; pred = ut -&gt;</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">            ut.getDefence() &gt; 0</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">            &amp;&amp; !ut.isNaval()</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">            &amp;&amp; ut.isAvailableTo(getOwner());</span>
<span class="nc" id="L1610">        return maximize(getSpecification().getUnitTypeList(), pred,</span>
<span class="nc" id="L1611">                        UnitType.defenceComparator);</span>
    }

    /**
     * Gets the total defence power.
     *
     * @return The total defence power.
     */
    public double getTotalDefencePower() {
<span class="nc" id="L1620">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L1621">        return sumDouble(getTile().getUnitList(), Unit::isDefensiveUnit,</span>
<span class="nc" id="L1622">                         u -&gt; cm.getDefencePower(null, u));</span>
    }

    /**
     * Determines whether this colony is sufficiently unprotected and
     * contains something worth pillaging.  To be called by CombatModels
     * when the attacker has defeated an unarmed colony defender.
     *
     * @param attacker The &lt;code&gt;Unit&lt;/code&gt; that has defeated the defender.
     * @return True if the attacker can pillage this colony.
     */
    public boolean canBePillaged(Unit attacker) {
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        return !hasStockade()</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">            &amp;&amp; attacker.hasAbility(Ability.PILLAGE_UNPROTECTED_COLONY)</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">            &amp;&amp; !(getBurnableBuildings().isEmpty()</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">                &amp;&amp; getTile().getNavalUnits().isEmpty()</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">                &amp;&amp; (getLootableGoodsList().isEmpty()</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">                    || !attacker.getType().canCarryGoods()</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                    || !attacker.hasSpaceLeft())</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                &amp;&amp; !canBePlundered());</span>
    }

    /**
     * Checks if this colony can be plundered.  That is, can it yield
     * non-zero gold.
     *
     * @return True if at least one piece of gold can be plundered from this
     *     colony.
     */
    public boolean canBePlundered() {
<span class="nc" id="L1652">        return owner.checkGold(1);</span>
    }

    /**
     * Gets the buildings in this colony that could be burned by a raid.
     *
     * @return A list of burnable buildings.
     */
    public List&lt;Building&gt; getBurnableBuildings() {
<span class="nc" id="L1661">        return transform(getBuildings(), Building::canBeDamaged,</span>
<span class="nc" id="L1662">                         Collectors.toList());</span>
    }

    /**
     * Gets a list of all stored goods in this colony, suitable for
     * being looted.
     *
     * @return A list of lootable goods in this colony.
     */
    public List&lt;Goods&gt; getLootableGoodsList() {
<span class="nc" id="L1672">        return transform(getGoodsContainer().getGoods(),</span>
<span class="nc" id="L1673">            g -&gt; g.getType().isStorable(), Collectors.toList());</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the number of enemy combat units
     * on all tiles that belong to the colony exceeds the number of
     * friendly combat units. At the moment, only the colony owner's
     * own units are considered friendly, but that could be extended
     * to include the units of allied players.
     *
     * FIXME: if a colony is under siege, it should not be possible to
     * put units outside the colony, unless those units are armed.
     *
     * @return a &lt;code&gt;boolean&lt;/code&gt; value
     */
    public boolean isUnderSiege() {
<span class="nc" id="L1689">        int friendlyUnits = 0;</span>
<span class="nc" id="L1690">        int enemyUnits = 0;</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">        for (ColonyTile colonyTile : getColonyTiles()) {</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">            for (Unit unit : colonyTile.getWorkTile().getUnitList()) {</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">                if (unit.getOwner() == getOwner()) {</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">                    if (unit.isDefensiveUnit()) {</span>
<span class="nc" id="L1695">                        friendlyUnits++;</span>
                    }
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                } else if (getOwner().atWarWith(unit.getOwner())) {</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                    if (unit.isOffensiveUnit()) {</span>
<span class="nc" id="L1699">                        enemyUnits++;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L1704" title="All 2 branches missed.">        return enemyUnits &gt; friendlyUnits;</span>
    }

    /**
     * Evaluate this colony for a given player.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
     * @return A value for the player.
     */
    public int evaluateFor(Player player) {
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        if (player.isAI()</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">            &amp;&amp; player.getSettlements().size() &lt; 5) {// FIXME: magic#</span>
<span class="nc" id="L1716">            return Integer.MIN_VALUE;</span>
        }
        int result, v;
<span class="nc bnc" id="L1719" title="All 2 branches missed.">        if (player.owns(this)) {</span>
<span class="nc" id="L1720">            result = 0;</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">            for (WorkLocation wl : getAvailableWorkLocations()) {</span>
<span class="nc" id="L1722">                v = wl.evaluateFor(player);</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">                if (v == Integer.MIN_VALUE) return Integer.MIN_VALUE;</span>
<span class="nc" id="L1724">                result += v;</span>
            }
<span class="nc bnc" id="L1726" title="All 2 branches missed.">            for (Unit u : getTile().getUnitList()) {</span>
<span class="nc" id="L1727">                v = u.evaluateFor(player);</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                if (v == Integer.MIN_VALUE) return Integer.MIN_VALUE;</span>
<span class="nc" id="L1729">                result += v;</span>
            }
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            for (Goods g : getCompactGoods()) {</span>
<span class="nc" id="L1732">                v = g.evaluateFor(player);</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                if (v == Integer.MIN_VALUE) return Integer.MIN_VALUE;</span>
<span class="nc" id="L1734">                result += v;</span>
            }
<span class="nc" id="L1736">        } else { // Much guesswork</span>
<span class="nc" id="L1737">            result = getDisplayUnitCount() * 1000</span>
<span class="nc" id="L1738">                + 500 // Some useful goods?</span>
<span class="nc" id="L1739">                + 200 * count(getTile().getSurroundingTiles(0, 1),</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">                              t -&gt; t.getOwningSettlement() == this);</span>
<span class="nc" id="L1741">            Building stockade = getStockade();</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">            if (stockade != null) result *= stockade.getLevel();</span>
        }
<span class="nc" id="L1744">        return result;</span>
    }


    // Education

    /**
     * Returns true if this colony has a schoolhouse and the unit type is a
     * skilled unit type with a skill level not exceeding the level of the
     * schoolhouse. @see Building#canAdd
     *
     * @param unit The unit to add as a teacher.
     * @return &lt;code&gt;true&lt;/code&gt; if this unit type could be added.
     */
    public boolean canTrain(Unit unit) {
<span class="nc" id="L1759">        return canTrain(unit.getType());</span>
    }

    /**
     * Returns true if this colony has a schoolhouse and the unit type is a
     * skilled unit type with a skill level not exceeding the level of the
     * schoolhouse. The number of units already in the schoolhouse and
     * the availability of pupils are not taken into account. @see
     * Building#canAdd
     *
     * @param unitType The unit type to add as a teacher.
     * @return &lt;code&gt;true&lt;/code&gt; if this unit type could be added.
     */
    public boolean canTrain(UnitType unitType) {
<span class="nc bnc" id="L1773" title="All 2 branches missed.">        return hasAbility(Ability.TEACH)</span>
<span class="nc" id="L1774">            &amp;&amp; any(getBuildings(),</span>
<span class="nc bnc" id="L1775" title="All 6 branches missed.">                b -&gt; b.canTeach() &amp;&amp; b.canAddType(unitType));</span>
    }

    /**
     * Gets a list of all teachers currently present in the school
     * building.
     *
     * @return A list of teacher &lt;code&gt;Unit&lt;/code&gt;s.
     */
    public List&lt;Unit&gt; getTeachers() {
<span class="nc" id="L1785">        List&lt;Unit&gt; teachers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">        for (Building building : getBuildings()) {</span>
<span class="nc bnc" id="L1787" title="All 2 branches missed.">            if (building.canTeach()) {</span>
<span class="nc" id="L1788">                teachers.addAll(building.getUnitList());</span>
            }
        }
<span class="nc" id="L1791">        return teachers;</span>
    }

    /**
     * Find a teacher for the specified student.
     * Do not search if ALLOW_STUDENT_SELECTION is true--- it is the
     * player's job then.
     *
     * @param student The student &lt;code&gt;Unit&lt;/code&gt; that needs a teacher.
     * @return A potential teacher, or null of none found.
     */
    public Unit findTeacher(Unit student) {
<span class="nc bnc" id="L1803" title="All 2 branches missed.">        if (getSpecification().getBoolean(GameOptions.ALLOW_STUDENT_SELECTION))</span>
<span class="nc" id="L1804">            return null; // No automatic assignment</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        for (Building building : getBuildings()) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            if (building.canTeach()) {</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">                for (Unit unit : building.getUnitList()) {</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                    if (unit.getStudent() == null</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                        &amp;&amp; student.canBeStudent(unit)) return unit;</span>
                }
            }
        }
<span class="nc" id="L1813">        return null;</span>
    }

    /**
     * Find a student for the specified teacher.
     * Do not search if ALLOW_STUDENT_SELECTION is true--- its the
     * player's job then.
     *
     * @param teacher The teacher &lt;code&gt;Unit&lt;/code&gt; that needs a student.
     * @return A potential student, or null of none found.
     */
    public Unit findStudent(final Unit teacher) {
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (getSpecification().getBoolean(GameOptions.ALLOW_STUDENT_SELECTION))</span>
<span class="nc" id="L1826">            return null; // No automatic assignment</span>
<span class="nc" id="L1827">        final GoodsType expertProduction</span>
<span class="nc" id="L1828">            = teacher.getType().getExpertProduction();</span>
<span class="nc" id="L1829">        final Predicate&lt;Unit&gt; pred = u -&gt;</span>
<span class="nc bnc" id="L1830" title="All 4 branches missed.">            u.getTeacher() == null &amp;&amp; u.canBeStudent(teacher);</span>
        // Always pick the student with the least skill first.
        // Break ties by favouring the one working in the teacher's trade,
        // otherwise first applicant wins.
<span class="nc" id="L1834">        final Comparator&lt;Unit&gt; skillComparator</span>
<span class="nc" id="L1835">            = Comparator.comparingInt(Unit::getSkillLevel);</span>
<span class="nc" id="L1836">        final Comparator&lt;Unit&gt; tradeComparator</span>
<span class="nc" id="L1837">            = Comparator.comparingInt(u -&gt;</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">                (u.getWorkType() == expertProduction) ? 0 : 1);</span>
<span class="nc" id="L1839">        final Comparator&lt;Unit&gt; fullComparator</span>
<span class="nc" id="L1840">            = skillComparator.thenComparing(tradeComparator);</span>
<span class="nc" id="L1841">        return minimize(getUnitList(), pred, fullComparator);</span>
    }


    // Production and consumption

    /**
     * Does this colony produce a goods type?
     *
     * This is more reliable than checking net or total production,
     * either of which might be cancelling to zero.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return True if goods type is produced.
     */
    public boolean isProducing(GoodsType goodsType) {
<span class="nc" id="L1857">        return productionCache.isProducing(goodsType);</span>
    }

    /**
     * Does this colony consume a goods type?
     *
     * This is more reliable than checking net or total consumption,
     * either of which might be cancelling to zero.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return True if goods type is consumed.
     */
    public boolean isConsuming(GoodsType goodsType) {
<span class="nc" id="L1870">        return productionCache.isConsuming(goodsType);</span>
    }

    /**
     * Get a list of all {@link Consumer}s in the colony sorted by
     * priority. Consumers include all object that consume goods,
     * e.g. Units, Buildings and BuildQueues.
     *
     * @return a list of consumers
     */
    public List&lt;Consumer&gt; getConsumers() {
<span class="nc" id="L1881">        List&lt;Consumer&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1882">        result.addAll(getUnitList());</span>
<span class="nc" id="L1883">        result.addAll(getBuildings());</span>
<span class="nc" id="L1884">        result.add(buildQueue);</span>
<span class="nc" id="L1885">        result.add(populationQueue);</span>

<span class="nc" id="L1887">        Collections.sort(result, Consumer.COMPARATOR);</span>
<span class="nc" id="L1888">        return result;</span>
    }

    /**
     * Returns the number of goods of a given type used by the settlement
     * each turn.
     *
     * @param goodsType &lt;code&gt;GoodsType&lt;/code&gt; values
     * @return an &lt;code&gt;int&lt;/code&gt; value
     */
    @Override
    public int getConsumptionOf(GoodsType goodsType) {
<span class="nc" id="L1900">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1901">        int result = super.getConsumptionOf(goodsType);</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">        if (spec.getGoodsType(&quot;model.goods.bells&quot;).equals(goodsType)) {</span>
<span class="nc" id="L1903">            result -= spec.getInteger(&quot;model.option.unitsThatUseNoBells&quot;);</span>
        }
<span class="nc" id="L1905">        return Math.max(0, result);</span>
    }

    /**
     * Gets the combined production of all food types.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; value
     */
    public int getFoodProduction() {
<span class="nc" id="L1914">        return sum(getSpecification().getFoodGoodsTypeList(),</span>
<span class="nc" id="L1915">                   ft -&gt; getTotalProductionOf(ft));</span>
    }

    /**
     * Get the number of turns before starvation occurs at this colony
     * with current production levels.
     *
     * @return The number of turns before starvation occurs, or negative
     *     if it will not.
     */
    public int getStarvationTurns() {
<span class="nc" id="L1926">        final GoodsType foodType = getSpecification().getPrimaryFoodType();</span>
<span class="nc" id="L1927">        final int food = getGoodsCount(foodType);</span>
<span class="nc" id="L1928">        final int newFood = getAdjustedNetProductionOf(foodType);</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">        return (newFood &gt;= 0) ? -1 : food / -newFood;</span>
    }

    /**
     * Get the number of turns before a new colonist will be born in
     * this colony with current production levels.
     *
     * @return A number of turns, or negative if no colonist will be born.
     */
    public int getNewColonistTurns() {
<span class="nc" id="L1939">        final GoodsType foodType = getSpecification().getPrimaryFoodType();</span>
<span class="nc" id="L1940">        final int food = getGoodsCount(foodType);</span>
<span class="nc" id="L1941">        final int newFood = getAdjustedNetProductionOf(foodType);</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">        return (food + newFood &gt;= Settlement.FOOD_PER_COLONIST) ? 1</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">            : (newFood &lt;= 0) ? -1</span>
<span class="nc" id="L1944">            : (Settlement.FOOD_PER_COLONIST - food) / newFood + 1;</span>
    }
        
        
    /**
     * Get the current production &lt;code&gt;Modifier&lt;/code&gt;, which is
     * generated from the current production bonus.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     * @return A list of suitable &lt;code&gt;Modifier&lt;/code&gt;s.
     */
    public List&lt;Modifier&gt; getProductionModifiers(GoodsType goodsType) {
<span class="nc bnc" id="L1956" title="All 2 branches missed.">        if (productionBonus == 0) return Collections.&lt;Modifier&gt;emptyList();</span>
<span class="nc" id="L1957">        Modifier mod = new Modifier(goodsType.getId(), productionBonus,</span>
<span class="nc" id="L1958">                                    Modifier.ModifierType.ADDITIVE,</span>
<span class="nc" id="L1959">                                    Specification.SOL_MODIFIER_SOURCE);</span>
<span class="nc" id="L1960">        mod.setModifierIndex(Modifier.COLONY_PRODUCTION_INDEX);</span>
<span class="nc" id="L1961">        List&lt;Modifier&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1962">        result.add(mod);</span>
<span class="nc" id="L1963">        return result;</span>
    }

    /**
     * Get the net production of the given goods type.
     *
     * (Also part of interface TradeLocation)
     *
     * @param goodsType a &lt;code&gt;GoodsType&lt;/code&gt; value
     * @return an &lt;code&gt;int&lt;/code&gt; value
     */
    public int getNetProductionOf(GoodsType goodsType) {
<span class="nc" id="L1975">        return productionCache.getNetProductionOf(goodsType);</span>
    }

    /**
     * Is a work location productive?
     *
     * @param workLocation The &lt;code&gt;WorkLocation&lt;/code&gt; to check.
     * @return True if something is being produced at the
     *     &lt;code&gt;WorkLocation&lt;/code&gt;.
     */
    public boolean isProductive(WorkLocation workLocation) {
<span class="nc" id="L1986">        ProductionInfo info = productionCache.getProductionInfo(workLocation);</span>
<span class="nc bnc" id="L1987" title="All 6 branches missed.">        return info != null &amp;&amp; info.getProduction() != null</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">            &amp;&amp; !info.getProduction().isEmpty()</span>
<span class="nc" id="L1989">            &amp;&amp; info.getProduction().get(0).getAmount() &gt; 0;</span>
    }

    /**
     * Returns the net production of the given GoodsType adjusted by
     * the possible consumption of BuildQueues.
     *
     * @param goodsType a &lt;code&gt;GoodsType&lt;/code&gt; value
     * @return an &lt;code&gt;int&lt;/code&gt; value
     */
    public int getAdjustedNetProductionOf(GoodsType goodsType) {
<span class="nc" id="L2000">        int result = productionCache.getNetProductionOf(goodsType);</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">        for (BuildQueue&lt;?&gt; queue : new BuildQueue&lt;?&gt;[] { buildQueue,</span>
<span class="nc" id="L2002">                                                         populationQueue }) {</span>
<span class="nc" id="L2003">            ProductionInfo info = productionCache.getProductionInfo(queue);</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">            if (info != null) {</span>
<span class="nc" id="L2005">                result += AbstractGoods.getCount(goodsType,</span>
<span class="nc" id="L2006">                    info.getConsumption());</span>
            }
        }
<span class="nc" id="L2009">        return result;</span>
    }

    /**
     * Gets a copy of the current production map.
     * Useful in the server at the point net production is applied to a colony.
     *
     * @return A copy of the current production map.
     */
    protected TypeCountMap&lt;GoodsType&gt; getProductionMap() {
<span class="nc" id="L2019">        return productionCache.getProductionMap();</span>
    }

    /**
     * Returns the ProductionInfo for the given Object.
     *
     * @param object an &lt;code&gt;Object&lt;/code&gt; value
     * @return a &lt;code&gt;ProductionInfo&lt;/code&gt; value
     */
    public ProductionInfo getProductionInfo(Object object) {
<span class="nc" id="L2029">        return productionCache.getProductionInfo(object);</span>
    }

    /**
     * Invalidates the production cache.
     */
    public void invalidateCache() {
<span class="nc" id="L2036">        productionCache.invalidate();</span>
<span class="nc" id="L2037">    }</span>

    /**
     * Update all the production types.
     *
     * Called at initialization, to default to something rational when
     * nothing was specified.  This can not be done until all the tiles are
     * present.
     */
    public void updateProductionTypes() {
<span class="nc bnc" id="L2047" title="All 2 branches missed.">        for (WorkLocation wl : getAvailableWorkLocations()) {</span>
<span class="nc" id="L2048">            wl.updateProductionType();</span>
        }
<span class="nc" id="L2050">    }</span>
            
    /**
     * Can this colony produce certain goods?
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check production of.
     * @return True if the goods can be produced.
     */
    public boolean canProduce(GoodsType goodsType) {
<span class="nc bnc" id="L2059" title="All 2 branches missed.">        return (getNetProductionOf(goodsType) &gt; 0)</span>
<span class="nc" id="L2060">            ? true // Obviously:-)</span>

            // Breeding requires the breedable number to be present
<span class="nc bnc" id="L2063" title="All 2 branches missed.">            : (goodsType.isBreedable())</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">            ? getGoodsCount(goodsType) &gt;= goodsType.getBreedingNumber()</span>

            // Is there a work location that can produce the goods, with
            // positive generic production potential and all inputs satisfied?
<span class="nc" id="L2068">            : any(getWorkLocationsForProducing(goodsType),</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">                wl -&gt; wl.getGenericPotential(goodsType) &gt; 0</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                    &amp;&amp; all(wl.getInputs(),ag -&gt; canProduce(ag.getType())));</span>
    }

  
    // Planning support

    /** Container class for tile exploration or improvement suggestions. */
    public static class TileImprovementSuggestion {

        /**
         * Comparator to order suggestions by descending improvement
         * amount.
         */
<span class="nc" id="L2083">        public static final Comparator&lt;TileImprovementSuggestion&gt; descendingAmountComparator</span>
<span class="nc" id="L2084">            = Comparator.comparingInt(TileImprovementSuggestion::getAmount)</span>
<span class="nc" id="L2085">                .reversed()</span>
<span class="nc" id="L2086">                .thenComparing(tis -&gt; (FreeColObject)tis.tile);</span>

        /** The tile to explore or improve. */
        public Tile tile;
        /** The tile improvement to make, or if null to explore an LCR. */
        public TileImprovementType tileImprovementType;
        /** The expected improvement.  INFINITY for LCRs. */
        public int amount;
        
<span class="nc" id="L2095">        public TileImprovementSuggestion(Tile tile, TileImprovementType t,</span>
                                         int amount) {
<span class="nc" id="L2097">            this.tile = tile;</span>
<span class="nc" id="L2098">            this.tileImprovementType = t;</span>
<span class="nc" id="L2099">            this.amount = amount;</span>
<span class="nc" id="L2100">        }</span>

        public boolean isExploration() {
<span class="nc bnc" id="L2103" title="All 2 branches missed.">            return this.tileImprovementType == null;</span>
        }

        public int getAmount() {
<span class="nc" id="L2107">            return this.amount;</span>
        }
    };
    
    /**
     * Collect suggestions for tiles that need exploration or
     * improvement (which may depend on current use within the colony).
     *
     * @return A list of &lt;code&gt;TileImprovementSuggestion&lt;/code&gt;s.
     */
    public List&lt;TileImprovementSuggestion&gt; getTileImprovementSuggestions() {
<span class="nc" id="L2118">        final Specification spec = getSpecification();</span>
<span class="nc" id="L2119">        List&lt;TileImprovementSuggestion&gt; result = new ArrayList&lt;&gt;();</span>

        // Encourage exploration of neighbouring rumours.
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        for (Tile tile : getTile().getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">            if (tile.hasLostCityRumour()) {</span>
<span class="nc" id="L2124">                result.add(new TileImprovementSuggestion(tile, null, INFINITY));</span>
            }
        }

        // Consider improvements for all colony tiles
<span class="nc bnc" id="L2129" title="All 2 branches missed.">        for (ColonyTile ct : getColonyTiles()) {</span>
<span class="nc" id="L2130">            final Tile tile = ct.getWorkTile();</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">            if (tile == null</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">                || tile.getOwningSettlement() != this) continue;</span>
            
<span class="nc bnc" id="L2134" title="All 2 branches missed.">            for (TileImprovementType t : spec.getTileImprovementTypeList()) {</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">                if (t.isNatural()) continue; </span>
<span class="nc" id="L2136">                int improvement = ct.improvedBy(t);</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">                if (improvement &gt; 0) {</span>
<span class="nc" id="L2138">                    result.add(new TileImprovementSuggestion(tile, t,</span>
<span class="nc" id="L2139">                                                             improvement));</span>
                }
            }
        }
<span class="nc" id="L2143">        Collections.sort(result,</span>
<span class="nc" id="L2144">            TileImprovementSuggestion.descendingAmountComparator);</span>
<span class="nc" id="L2145">        return result;</span>
    }

    /**
     * Finds another unit in this colony that would be better at doing the
     * job of the specified unit.
     *
     * @param expert The &lt;code&gt;Unit&lt;/code&gt; to consider.
     * @return A better expert, or null if none available.
     */
    public Unit getBetterExpert(Unit expert) {
<span class="nc" id="L2156">        GoodsType production = expert.getWorkType();</span>
<span class="nc" id="L2157">        UnitType expertType = expert.getType();</span>
<span class="nc" id="L2158">        GoodsType expertise = expertType.getExpertProduction();</span>
<span class="nc" id="L2159">        Unit bestExpert = null;</span>
<span class="nc" id="L2160">        int bestImprovement = 0;</span>

<span class="nc bnc" id="L2162" title="All 4 branches missed.">        if (production == null || expertise == null</span>
<span class="nc bnc" id="L2163" title="All 2 branches missed.">            || production == expertise) return null;</span>

        // We have an expert not doing the job of their expertise.
        // Check if there is a non-expert doing the job instead.
<span class="nc bnc" id="L2167" title="All 2 branches missed.">        for (Unit nonExpert : getUnitList()) {</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            if (nonExpert.getWorkType() != expertise</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">                || nonExpert.getType() == expertType) continue;</span>

            // We have found a unit of a different type doing the
            // job of this expert's expertise now check if the
            // production would be better if the units swapped
            // positions.
<span class="nc" id="L2175">            int expertProductionNow = 0;</span>
<span class="nc" id="L2176">            int nonExpertProductionNow = 0;</span>
<span class="nc" id="L2177">            int expertProductionPotential = 0;</span>
<span class="nc" id="L2178">            int nonExpertProductionPotential = 0;</span>

            // Get the current and potential productions for the
            // work location of the expert.
<span class="nc" id="L2182">            WorkLocation ewl = expert.getWorkLocation();</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">            if (ewl != null) {</span>
<span class="nc" id="L2184">                expertProductionNow = ewl.getPotentialProduction(expertise,</span>
<span class="nc" id="L2185">                    expert.getType());</span>
<span class="nc" id="L2186">                nonExpertProductionPotential</span>
<span class="nc" id="L2187">                    = ewl.getPotentialProduction(expertise,</span>
<span class="nc" id="L2188">                        nonExpert.getType());</span>
            }

            // Get the current and potential productions for the
            // work location of the non-expert.
<span class="nc" id="L2193">            WorkLocation nwl = nonExpert.getWorkTile();</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">            if (nwl != null) {</span>
<span class="nc" id="L2195">                nonExpertProductionNow = nwl.getPotentialProduction(expertise,</span>
<span class="nc" id="L2196">                    nonExpert.getType());</span>
<span class="nc" id="L2197">                expertProductionPotential</span>
<span class="nc" id="L2198">                    = nwl.getPotentialProduction(expertise, expertType);</span>
            }

            // Find the unit that achieves the best improvement.
<span class="nc" id="L2202">            int improvement = expertProductionPotential</span>
<span class="nc" id="L2203">                + nonExpertProductionPotential</span>
<span class="nc" id="L2204">                - expertProductionNow</span>
<span class="nc" id="L2205">                - nonExpertProductionNow;</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">            if (improvement &gt; bestImprovement) {</span>
<span class="nc" id="L2207">                bestImprovement = improvement;</span>
<span class="nc" id="L2208">                bestExpert = nonExpert;</span>
            }
        }
<span class="nc" id="L2211">        return bestExpert;</span>
    }

    /**
     * Determine if there is a problem with the production of a given
     * goods type.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return A collection of warning messages.
     */
    public Collection&lt;StringTemplate&gt; getProductionWarnings(GoodsType goodsType) {
<span class="nc" id="L2222">        List&lt;StringTemplate&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2223">        final int amount = getGoodsCount(goodsType);</span>
<span class="nc" id="L2224">        final int production = getNetProductionOf(goodsType);</span>
        int waste;
        
<span class="nc bnc" id="L2227" title="All 2 branches missed.">        if (goodsType.isStorable()) {</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">            if (goodsType.limitIgnored()) {</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">                if (goodsType.isFoodType()) {</span>
<span class="nc" id="L2230">                    int starve = getStarvationTurns();</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">                    if (starve == 0) {</span>
<span class="nc" id="L2232">                        result.add(StringTemplate</span>
<span class="nc" id="L2233">                            .template(&quot;model.colony.starving&quot;)</span>
<span class="nc" id="L2234">                            .addName(&quot;%colony%&quot;, getName()));</span>
<span class="nc bnc" id="L2235" title="All 2 branches missed.">                    } else if (starve &lt;= Colony.FAMINE_TURNS) {</span>
<span class="nc" id="L2236">                        result.add(StringTemplate</span>
<span class="nc" id="L2237">                            .template(&quot;model.colony.famineFeared&quot;)</span>
<span class="nc" id="L2238">                            .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2239">                            .addAmount(&quot;%number%&quot;, starve));</span>
                    }
                }
<span class="nc bnc" id="L2242" title="All 2 branches missed.">            } else if (!getExportData(goodsType).getExported()</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">                &amp;&amp; (waste = amount + production - getWarehouseCapacity()) &gt; 0) {</span>
<span class="nc" id="L2244">                result.add(StringTemplate</span>
<span class="nc" id="L2245">                    .template(&quot;model.building.warehouseSoonFull&quot;)</span>
<span class="nc" id="L2246">                    .addNamed(&quot;%goods%&quot;, goodsType)</span>
<span class="nc" id="L2247">                    .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2248">                    .addAmount(&quot;%amount%&quot;, waste));</span>
            }
        }

<span class="nc" id="L2252">        BuildableType currentlyBuilding = getCurrentlyBuilding();</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">        if (currentlyBuilding != null) {</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">            for (AbstractGoods goods : currentlyBuilding.getRequiredGoods()) {</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">                if (goods.getType().equals(goodsType)</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                    &amp;&amp; amount &lt; goods.getAmount()) {</span>
<span class="nc" id="L2257">                    int needsAmount = goods.getAmount() - amount;</span>
<span class="nc" id="L2258">                    result.add(StringTemplate</span>
<span class="nc" id="L2259">                        .template(&quot;model.colony.buildableNeedsGoods&quot;)</span>
<span class="nc" id="L2260">                        .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2261">                        .addNamed(&quot;%buildable%&quot;, currentlyBuilding)</span>
<span class="nc" id="L2262">                        .addAmount(&quot;%amount%&quot;, needsAmount)</span>
<span class="nc" id="L2263">                        .addNamed(&quot;%goodsType%&quot;, goodsType));</span>
                }
            }
        }

<span class="nc bnc" id="L2268" title="All 2 branches missed.">        for (WorkLocation wl : getWorkLocationsForProducing(goodsType)) {</span>
<span class="nc" id="L2269">            ProductionInfo info = getProductionInfo(wl);</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">            if (info == null) continue;</span>
<span class="nc" id="L2271">            StringTemplate t = getInsufficientProductionMessage(info,</span>
<span class="nc" id="L2272">                AbstractGoods.findByType(goodsType,</span>
<span class="nc" id="L2273">                    info.getProductionDeficit()));</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">            if (t != null) result.add(t);</span>
        }
<span class="nc bnc" id="L2276" title="All 2 branches missed.">        for (WorkLocation wl : getWorkLocationsForConsuming(goodsType)) {</span>
<span class="nc" id="L2277">            ProductionInfo info = getProductionInfo(wl);</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">            if (info == null) continue;</span>
<span class="nc" id="L2279">            List&lt;AbstractGoods&gt; deficit = info.getProductionDeficit();</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">            if (deficit.isEmpty()) continue;</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">            for (AbstractGoods ag : wl.getOutputs()) {</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">                if (ag.getType().isStorable()) continue;</span>
<span class="nc" id="L2283">                StringTemplate t = getInsufficientProductionMessage(info,</span>
<span class="nc" id="L2284">                    AbstractGoods.findByType(ag.getType(), deficit));</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">                if (t != null) result.add(t);</span>
            }
        }

<span class="nc" id="L2289">        return result;</span>
    }

    /**
     * Get a message about insufficient production for a building
     *
     * @param info The &lt;code&gt;ProductionInfo&lt;/code&gt; for the work location.
     * @param deficit The &lt;code&gt;AbstractGoods&lt;/code&gt; in deficit.
     * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt; or null if none required.
     */
    private StringTemplate getInsufficientProductionMessage(ProductionInfo info,
        AbstractGoods deficit) {
<span class="nc bnc" id="L2301" title="All 4 branches missed.">        if (info == null || deficit == null) return null;</span>

<span class="nc" id="L2303">        List&lt;AbstractGoods&gt; input = info.getConsumptionDeficit();</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">        if (input.isEmpty()) return null;</span>
<span class="nc" id="L2305">        StringTemplate label = StringTemplate.label(&quot;, &quot;);</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">        for (AbstractGoods ag : input) label.addStringTemplate(ag.getLabel());</span>
        
<span class="nc" id="L2308">        return StringTemplate.template(&quot;model.colony.insufficientProduction&quot;)</span>
<span class="nc" id="L2309">            .addName(&quot;%colony%&quot;, getName())</span>
<span class="nc" id="L2310">            .addNamed(&quot;%outputType%&quot;, deficit.getType())</span>
<span class="nc" id="L2311">            .addAmount(&quot;%outputAmount%&quot;, deficit.getAmount())</span>
<span class="nc" id="L2312">            .addStringTemplate(&quot;%consumptionDeficit%&quot;, label);</span>
    }

    /**
     * Check if a goods type is still useful to this colony.
     *
     * In general, all goods are useful.  However post-independence there is
     * no need for more liberty once Sol% reaches 100, nor immigration.
     * Note the latter may change when we implement sailing to other European
     * ports.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return True if these goods are still useful here.
     */
    public boolean goodsUseful(GoodsType goodsType) {
<span class="nc bnc" id="L2327" title="All 2 branches missed.">        if (getOwner().getPlayerType() == Player.PlayerType.INDEPENDENT) {</span>
<span class="nc bnc" id="L2328" title="All 4 branches missed.">            if ((goodsType.isLibertyType() &amp;&amp; getSoLPercentage() &gt;= 100)</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">                || goodsType.isImmigrationType()) return false;</span>
        }
<span class="nc" id="L2331">        return true;</span>
    }

    /**
     * Special goods need modifiers applied when changed, and immigration
     * accumulates to the owner.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
     * @param amount The amount of modification.
     */
    private void modifySpecialGoods(GoodsType goodsType, int amount) {
<span class="nc" id="L2342">        final Turn turn = getGame().getTurn();</span>
        Set&lt;Modifier&gt; mods;

<span class="nc" id="L2345">        mods = goodsType.getModifiers(Modifier.LIBERTY);</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">        if (!mods.isEmpty()) {</span>
<span class="nc" id="L2347">            int liberty = (int)applyModifiers(amount, turn, mods);</span>
<span class="nc" id="L2348">            modifyLiberty(liberty);</span>
        }

<span class="nc" id="L2351">        mods = goodsType.getModifiers(Modifier.IMMIGRATION);</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">        if (!mods.isEmpty()) {</span>
<span class="nc" id="L2353">            int migration = (int)applyModifiers(amount, turn, mods);</span>
<span class="nc" id="L2354">            modifyImmigration(migration);</span>
<span class="nc" id="L2355">            getOwner().modifyImmigration(migration);</span>
        }
<span class="nc" id="L2357">    }</span>
    
    /**
     * Creates a temporary copy of this colony for planning purposes.
     *
     * A simple colony.copy() can not work because all the colony
     * tiles will be left referring to uncopied work tiles which the
     * colony-copy does not own, which prevents them being used as
     * valid work locations.  We have to copy the colony tile (which
     * includes the colony), and fix up all the colony tile work tiles
     * to point to copies of the original tile, and fix the ownership
     * of those tiles.
     *
     * @return A scratch version of this colony.
     */
    public Colony copyColony() {
<span class="nc" id="L2373">        final Game game = getGame();</span>
<span class="nc" id="L2374">        Tile tile = getTile();</span>
<span class="nc" id="L2375">        Tile tileCopy = tile.copy(game, tile.getClass());</span>
<span class="nc" id="L2376">        Colony colony = tileCopy.getColony();</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        for (ColonyTile ct : colony.getColonyTiles()) {</span>
            Tile wt;
<span class="nc bnc" id="L2379" title="All 2 branches missed.">            if (ct.isColonyCenterTile()) {</span>
<span class="nc" id="L2380">                wt = tileCopy;</span>
<span class="nc" id="L2381">            } else {</span>
<span class="nc" id="L2382">                wt = ct.getWorkTile();</span>
<span class="nc" id="L2383">                wt = wt.copy(game, wt.getClass());</span>
<span class="nc bnc" id="L2384" title="All 2 branches missed.">                if (wt.getOwningSettlement() == this) {</span>
<span class="nc" id="L2385">                    wt.setOwningSettlement(colony);</span>
                }
            }
<span class="nc" id="L2388">            ct.setWorkTile(wt);</span>
        }
<span class="nc" id="L2390">        return colony;</span>
    }

    /**
     * Finds the corresponding FreeColObject from another copy of this colony.
     *
     * @param &lt;T&gt; The actual return type.
     * @param fco The &lt;code&gt;FreeColObject&lt;/code&gt; in the other colony.
     * @return The corresponding &lt;code&gt;FreeColObject&lt;/code&gt; in this
     *     colony, or null if not found.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T extends FreeColObject&gt; T getCorresponding(T fco) {
<span class="nc" id="L2403">        final String id = fco.getId();</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">        if (fco instanceof WorkLocation) {</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">            for (WorkLocation t : getAllWorkLocations()) {</span>
<span class="nc bnc" id="L2406" title="All 2 branches missed.">                if (t.getId().equals(id)) return (T)t;</span>
            }
<span class="nc bnc" id="L2408" title="All 2 branches missed.">        } else if (fco instanceof Tile) {</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">            if (getTile().getId().equals(id)) return (T)getTile();</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">            for (ColonyTile ct : getColonyTiles()) {</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">                if (ct.getWorkTile().getId().equals(id)) return (T)ct.getWorkTile();</span>
            }
<span class="nc bnc" id="L2413" title="All 2 branches missed.">        } else if (fco instanceof Unit) {</span>
<span class="nc bnc" id="L2414" title="All 2 branches missed.">            for (Unit t : getUnitList()) {</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">                if (t.getId().equals(id)) return (T)t;</span>
            }
<span class="nc bnc" id="L2417" title="All 2 branches missed.">            for (Unit t : getTile().getUnitList()) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">                if (t.getId().equals(id)) return (T)t;</span>
            }
        }
<span class="nc" id="L2421">        return null;</span>
    }


    // Override FreeColObject

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Ability&gt; getAbilities(String id, FreeColSpecObjectType type,
                                     Turn turn) {
<span class="nc bnc" id="L2433" title="All 2 branches missed.">        if (turn == null) turn = getGame().getTurn();</span>
<span class="nc" id="L2434">        Set&lt;Ability&gt; result = super.getAbilities(id, type, turn);</span>
        // Owner abilities also apply to colonies
<span class="nc bnc" id="L2436" title="All 2 branches missed.">        if (owner != null) result.addAll(owner.getAbilities(id, type, turn));</span>
<span class="nc" id="L2437">        return result;</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;FreeColGameObject&gt; getDisposeList() {
<span class="nc" id="L2448">        List&lt;FreeColGameObject&gt; objects = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2449" title="All 2 branches missed.">        for (WorkLocation workLocation : getAllWorkLocations()) {</span>
<span class="nc" id="L2450">            objects.addAll(workLocation.getDisposeList());</span>
        }
<span class="nc" id="L2452">        objects.addAll(super.getDisposeList());</span>
<span class="nc" id="L2453">        return objects;</span>
    }


    // Interface Location (from Settlement via GoodsLocation via UnitLocation)
    //   UnitLocation.units is not used in Colony, but getUnitList is
    //   faked to return the union of the units in the work locations.
    //   This is a wart, and was probably a bad idea.
    // Inherits
    //   FreeColObject.getId
    //   Settlement.getTile
    //   Settlement.getLocationLabel
    //   GoodsLocation.canAdd
    //   GoodsLocation.getGoodsContainer
    //   Settlement.getSettlement

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabelFor(Player player) {
        // Everyone can always work out a colony name, but it can be invalid
<span class="nc" id="L2475">        final String name = getName();</span>
<span class="nc bnc" id="L2476" title="All 2 branches missed.">        return StringTemplate.name((name == null) ? &quot;?&quot; : name);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(Locatable locatable) {
<span class="nc bnc" id="L2484" title="All 2 branches missed.">        if (locatable instanceof Unit) {</span>
<span class="nc" id="L2485">            return joinColony((Unit)locatable);</span>
        }
<span class="nc" id="L2487">        return super.add(locatable);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Locatable locatable) {
<span class="nc bnc" id="L2495" title="All 2 branches missed.">        if (locatable instanceof Unit) {</span>
<span class="nc" id="L2496">            Location loc = locatable.getLocation();</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">            if (loc instanceof WorkLocation) {</span>
<span class="nc" id="L2498">                WorkLocation wl = (WorkLocation)loc;</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                if (wl.getColony() == this) {</span>
<span class="nc" id="L2500">                    return wl.remove(locatable);</span>
                }
            }                
<span class="nc" id="L2503">            return false;</span>
        }
<span class="nc" id="L2505">        return super.remove(locatable);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean contains(Locatable locatable) {
<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (locatable instanceof Unit) {</span>
<span class="nc" id="L2514">            return any(getAvailableWorkLocations(),</span>
<span class="nc" id="L2515">                wl -&gt; wl.contains(locatable));</span>
        }
<span class="nc" id="L2517">        return super.contains(locatable);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getUnitCount() {
<span class="nc" id="L2525">        return sum(getCurrentWorkLocations(), UnitLocation::getUnitCount);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;Unit&gt; getUnitList() {
<span class="nc" id="L2533">        List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2534" title="All 2 branches missed.">        for (WorkLocation wl : getCurrentWorkLocations()) {</span>
<span class="nc" id="L2535">            units.addAll(wl.getUnitList());</span>
        }
<span class="nc" id="L2537">        return units;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Location up() {
<span class="nc" id="L2545">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toShortString() {
<span class="nc" id="L2553">        return getName();</span>
    }


    // Interface UnitLocation
    // Inherits
    //   UnitLocation.getSpaceTaken [Irrelevant!]
    //   UnitLocation.moveToFront [Irrelevant!]
    //   UnitLocation.clearUnitList [Irrelevant!]
    //   Settlement.equipForRole
    //   Settlement.getNoAddReason


    // Interface GoodsLocation

    /**
     * {@inheritDoc}
     */
    @Override
    public int getGoodsCapacity() {
<span class="nc" id="L2573">        return (int)applyModifiers(0f, getGame().getTurn(),</span>
<span class="nc" id="L2574">                                   Modifier.WAREHOUSE_STORAGE);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean addGoods(GoodsType type, int amount) {
<span class="nc" id="L2582">        super.addGoods(type, amount);</span>
<span class="nc" id="L2583">        productionCache.invalidate(type);</span>
<span class="nc" id="L2584">        modifySpecialGoods(type, amount);</span>
<span class="nc" id="L2585">        return true;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Goods removeGoods(GoodsType type, int amount) {
<span class="nc" id="L2593">        Goods removed = super.removeGoods(type, amount);</span>
<span class="nc" id="L2594">        productionCache.invalidate(type);</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">        if (removed != null) modifySpecialGoods(type, -removed.getAmount());</span>
<span class="nc" id="L2596">        return removed;</span>
    }


    // Settlement

    /**
     * {@inheritDoc}
     */
    @Override
    public String getImageKey() {
        String key;
<span class="nc bnc" id="L2608" title="All 2 branches missed.">        if (isUndead()) {</span>
<span class="nc" id="L2609">            key = &quot;.undead&quot;;</span>
<span class="nc" id="L2610">        } else {</span>
<span class="nc" id="L2611">            int count = getDisplayUnitCount();</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">            key = (count &lt;= 3) ? &quot;.small&quot;</span>
<span class="nc bnc" id="L2613" title="All 2 branches missed.">                : (count &lt;= 7) ? &quot;.medium&quot;</span>
<span class="nc" id="L2614">                : &quot;.large&quot;;</span>
<span class="nc" id="L2615">            String stockade = getStockadeKey();</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">            if (stockade != null) key += &quot;.&quot; + stockade;</span>
        }
<span class="nc" id="L2618">        return &quot;image.tileitem.&quot; + getType().getId() + key;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Unit getDefendingUnit(Unit attacker) {
<span class="nc bnc" id="L2626" title="All 2 branches missed.">        if (displayUnitCount &gt; 0) {</span>
            // There are units, but we don't see them
<span class="nc" id="L2628">            return null;</span>
        }

        // Note that this function will only return a unit working
        // inside the colony.  Typically, colonies are also defended
        // by units outside the colony on the same tile.  To consider
        // units outside the colony as well, use
        // @see Tile#getDefendingUnit instead.
<span class="nc" id="L2636">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L2637">        final Comparator&lt;Unit&gt; comp</span>
<span class="nc" id="L2638">            = cachingDoubleComparator(u -&gt; cm.getDefencePower(attacker, u));</span>
<span class="nc" id="L2639">        return maximize(getUnitList(), comp);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public double getDefenceRatio() {
<span class="nc" id="L2647">        return getTotalDefencePower() / (1 + getUnitCount());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isBadlyDefended() {
<span class="nc bnc" id="L2655" title="All 2 branches missed.">        return getTotalDefencePower() &lt; 0.95 * getUnitCount() - 2.5;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public RandomRange getPlunderRange(Unit attacker) {
<span class="nc bnc" id="L2663" title="All 2 branches missed.">        if (canBePlundered()) {</span>
<span class="nc" id="L2664">            int upper = (owner.getGold() * (getUnitCount() + 1))</span>
<span class="nc" id="L2665">                / (owner.getColoniesPopulation() + 1);</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">            if (upper &gt; 0) return new RandomRange(100, 1, upper+1, 1);</span>
        }
<span class="nc" id="L2668">        return null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getSoL() {
<span class="nc" id="L2676">        return sonsOfLiberty;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getUpkeep() {
<span class="nc" id="L2684">        return sum(getBuildings(), b -&gt; b.getType().getUpkeep());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getTotalProductionOf(GoodsType goodsType) {
<span class="nc" id="L2692">        return sum(getCurrentWorkLocations(),</span>
<span class="nc" id="L2693">                   wl -&gt; wl.getTotalProductionOf(goodsType));</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean canProvideGoods(List&lt;AbstractGoods&gt; requiredGoods) {
        // Unlike priceGoods, this takes goods &quot;reserved&quot; for other
        // purposes into account.
<span class="nc" id="L2703">        BuildableType buildable = getCurrentlyBuilding();</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">        for (AbstractGoods goods : requiredGoods) {</span>
<span class="nc" id="L2705">            int available = getGoodsCount(goods.getType());</span>

<span class="nc" id="L2707">            int breedingNumber = goods.getType().getBreedingNumber();</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">            if (breedingNumber != GoodsType.INFINITY) {</span>
<span class="nc" id="L2709">                available -= breedingNumber;</span>
            }

<span class="nc bnc" id="L2712" title="All 2 branches missed.">            if (buildable != null) {</span>
<span class="nc" id="L2713">                available -= AbstractGoods.getCount(goods.getType(),</span>
<span class="nc" id="L2714">                    buildable.getRequiredGoods());</span>
            }

<span class="nc bnc" id="L2717" title="All 2 branches missed.">            if (available &lt; goods.getAmount()) return false;</span>
        }
<span class="nc" id="L2719">        return true;</span>
    }

    /**
     * {@inheritDoc}
     */
    public boolean hasContacted(Player player) {
<span class="nc bnc" id="L2726" title="All 2 branches missed.">        return player != null</span>
<span class="nc bnc" id="L2727" title="All 2 branches missed.">            &amp;&amp; (player.isEuropean()</span>
<span class="nc bnc" id="L2728" title="All 2 branches missed.">                || getOwner().getStance(player) != Stance.UNCONTACTED);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getAlarmLevelLabel(Player player) {
<span class="nc" id="L2736">        Stance stance = getOwner().getStance(player);</span>
<span class="nc" id="L2737">        return StringTemplate.template(&quot;model.colony.&quot; + stance.getKey())</span>
<span class="nc" id="L2738">            .addStringTemplate(&quot;%nation%&quot;, getOwner().getNationLabel());</span>
    }


    // Interface TradeLocation
    //   getGoodsCount provided in GoodsContainer

    /**
     * {@inheritDoc}
     */
    @Override
    public int getExportAmount(GoodsType goodsType, int turns) {
<span class="nc" id="L2750">        final int present = Math.max(0, getGoodsCount(goodsType)</span>
<span class="nc" id="L2751">            + turns * getNetProductionOf(goodsType));</span>
<span class="nc" id="L2752">        final ExportData ed = getExportData(goodsType);</span>
<span class="nc" id="L2753">        return Math.max(0, present - ed.getExportLevel());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getImportAmount(GoodsType goodsType, int turns) {
<span class="nc bnc" id="L2761" title="All 2 branches missed.">        if (goodsType.limitIgnored()) return GoodsContainer.HUGE_CARGO_SIZE;</span>

<span class="nc" id="L2763">        final int present = Math.max(0, getGoodsCount(goodsType)</span>
<span class="nc" id="L2764">            + turns * getNetProductionOf(goodsType));</span>
<span class="nc" id="L2765">        final ExportData ed = getExportData(goodsType);</span>
<span class="nc" id="L2766">        int capacity = ed.getEffectiveImportLevel(getWarehouseCapacity());</span>
<span class="nc" id="L2767">        return Math.max(0, capacity - present);</span>
    }


    //
    // Miscellaneous low level
    //

    /**
     * Add port ability to non-landlocked colonies.
     */
    protected void addPortAbility() {
<span class="nc" id="L2779">        addAbility(new Ability(Ability.HAS_PORT));</span>
<span class="nc" id="L2780">    }</span>
    
    /**
     * Check the integrity of the build queues.  Catches build fails
     * due to broken requirements.
     *
     * @param fix Fix problems if possible.
     * @return Negative if there are problems remaining, zero if
     *     problems were fixed, positive if no problems found at all.
     */
    public int checkBuildQueueIntegrity(boolean fix) {
<span class="nc" id="L2791">        int result = 1;</span>
<span class="nc" id="L2792">        List&lt;BuildableType&gt; buildables = buildQueue.getValues();</span>
<span class="nc" id="L2793">        List&lt;BuildableType&gt; assumeBuilt = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2794" title="All 2 branches missed.">        for (int i = 0; i &lt; buildables.size(); i++) {</span>
<span class="nc" id="L2795">            BuildableType bt = buildables.get(i);</span>
<span class="nc" id="L2796">            NoBuildReason reason = getNoBuildReason(bt, assumeBuilt);</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">            if (reason == NoBuildReason.NONE) {</span>
<span class="nc" id="L2798">                assumeBuilt.add(bt);</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            } else if (fix) {</span>
<span class="nc" id="L2800">                buildQueue.remove(i);</span>
<span class="nc" id="L2801">                result = Math.min(result, 0);</span>
<span class="nc" id="L2802">            } else {</span>
<span class="nc" id="L2803">                result = -1;</span>
            }
        }
<span class="nc" id="L2806">        List&lt;UnitType&gt; unitTypes = populationQueue.getValues();</span>
<span class="nc" id="L2807">        assumeBuilt.clear();</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">        for (int i = 0; i &lt; unitTypes.size(); i++) {</span>
<span class="nc" id="L2809">            UnitType ut = unitTypes.get(i);</span>
<span class="nc" id="L2810">            NoBuildReason reason = getNoBuildReason(ut, assumeBuilt);</span>
<span class="nc bnc" id="L2811" title="All 2 branches missed.">            if (reason == NoBuildReason.NONE) {</span>
<span class="nc" id="L2812">                assumeBuilt.add(ut);</span>
<span class="nc bnc" id="L2813" title="All 2 branches missed.">            } else if (fix) {                </span>
<span class="nc" id="L2814">                populationQueue.remove(i);</span>
<span class="nc" id="L2815">                result = Math.min(result, 0);</span>
<span class="nc" id="L2816">            } else {</span>
<span class="nc" id="L2817">                result = -1;</span>
            }
        }
<span class="nc" id="L2820">        return result;</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="nc" id="L2831">        int result = super.checkIntegrity(fix);</span>

        // @compat 0.10.x
<span class="nc bnc" id="L2834" title="All 4 branches missed.">        if (!isLandLocked() &amp;&amp; !hasAbility(Ability.HAS_PORT)) {</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">            if (fix) {</span>
<span class="nc" id="L2836">                addPortAbility();</span>
<span class="nc" id="L2837">                result = Math.min(result, 0);</span>
<span class="nc" id="L2838">            } else {</span>
<span class="nc" id="L2839">                result = -1;</span>
            }
        }
        // end @compat 0.10.x

<span class="nc" id="L2844">        return Math.min(result, checkBuildQueueIntegrity(fix));</span>
    }


    // Serialization

    private static final String BUILD_QUEUE_TAG = &quot;buildQueueItem&quot;;
    private static final String ESTABLISHED_TAG = &quot;established&quot;;
    private static final String IMMIGRATION_TAG = &quot;immigration&quot;;
    private static final String LIBERTY_TAG = &quot;liberty&quot;;
    private static final String PRODUCTION_BONUS_TAG = &quot;productionBonus&quot;;
    private static final String NAME_TAG = &quot;name&quot;;
    private static final String OLD_SONS_OF_LIBERTY_TAG = &quot;oldSonsOfLiberty&quot;;
    private static final String OLD_TORIES_TAG = &quot;oldTories&quot;;
    private static final String POPULATION_QUEUE_TAG = &quot;populationQueueItem&quot;;
    private static final String SONS_OF_LIBERTY_TAG = &quot;sonsOfLiberty&quot;;
    private static final String TORIES_TAG = &quot;tories&quot;;
<span class="nc" id="L2861">    private static final String UNIT_COUNT_TAG = &quot;unitCount&quot;;</span>


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L2869">        super.writeAttributes(xw);</span>

        // Delegated from Settlement
<span class="nc" id="L2872">        xw.writeAttribute(NAME_TAG, getName());</span>

<span class="nc" id="L2874">        xw.writeAttribute(ESTABLISHED_TAG, established.getNumber());</span>

        // SoL has to be visible for the popular support bonus to be
        // visible to an attacking rebel player.
<span class="nc" id="L2878">        xw.writeAttribute(SONS_OF_LIBERTY_TAG, sonsOfLiberty);</span>

<span class="nc bnc" id="L2880" title="All 2 branches missed.">        if (xw.validFor(getOwner())) {</span>

<span class="nc" id="L2882">            xw.writeAttribute(OLD_SONS_OF_LIBERTY_TAG, oldSonsOfLiberty);</span>

<span class="nc" id="L2884">            xw.writeAttribute(TORIES_TAG, tories);</span>

<span class="nc" id="L2886">            xw.writeAttribute(OLD_TORIES_TAG, oldTories);</span>

<span class="nc" id="L2888">            xw.writeAttribute(LIBERTY_TAG, liberty);</span>

<span class="nc" id="L2890">            xw.writeAttribute(IMMIGRATION_TAG, immigration);</span>

<span class="nc" id="L2892">            xw.writeAttribute(PRODUCTION_BONUS_TAG, productionBonus);</span>

<span class="nc" id="L2894">        } else {</span>

<span class="nc" id="L2896">            int uc = getDisplayUnitCount();</span>
<span class="nc bnc" id="L2897" title="All 2 branches missed.">            if (uc &lt;= 0) {</span>
<span class="nc" id="L2898">                logger.warning(&quot;Unit count fail: &quot; + uc + &quot; id=&quot; + getId()</span>
<span class="nc" id="L2899">                    + &quot; unitCount=&quot; + getUnitCount()</span>
<span class="nc" id="L2900">                    + &quot; scope=&quot; + xw.getWriteScope()</span>
<span class="nc" id="L2901">                    + &quot;/&quot; + xw.getWriteScope().getClient() + &quot;\n&quot;</span>
<span class="nc" id="L2902">                    + net.sf.freecol.common.debug.FreeColDebugger.stackTraceToString());</span>
            }
<span class="nc" id="L2904">            xw.writeAttribute(UNIT_COUNT_TAG, uc);</span>
        }
<span class="nc" id="L2906">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L2913">        super.writeChildren(xw);</span>

<span class="nc bnc" id="L2915" title="All 2 branches missed.">        if (xw.validFor(getOwner())) {</span>

<span class="nc bnc" id="L2917" title="All 2 branches missed.">            for (Entry&lt;String, ExportData&gt; e : mapEntriesByKey(exportData)) {</span>
<span class="nc" id="L2918">                e.getValue().toXML(xw);</span>
            }

<span class="nc bnc" id="L2921" title="All 2 branches missed.">            for (WorkLocation wl : toSortedList(getAllWorkLocations())) {</span>
<span class="nc" id="L2922">                wl.toXML(xw);</span>
            }

<span class="nc bnc" id="L2925" title="All 2 branches missed.">            for (BuildableType item : buildQueue.getValues()) { // In order!</span>
<span class="nc" id="L2926">                xw.writeStartElement(BUILD_QUEUE_TAG);</span>

<span class="nc" id="L2928">                xw.writeAttribute(ID_ATTRIBUTE_TAG, item);</span>

<span class="nc" id="L2930">                xw.writeEndElement();</span>
            }

<span class="nc bnc" id="L2933" title="All 2 branches missed.">            for (BuildableType item : populationQueue.getValues()) { // In order</span>
<span class="nc" id="L2934">                xw.writeStartElement(POPULATION_QUEUE_TAG);</span>

<span class="nc" id="L2936">                xw.writeAttribute(ID_ATTRIBUTE_TAG, item);</span>

<span class="nc" id="L2938">                xw.writeEndElement();</span>
            }

<span class="nc" id="L2941">        } else {</span>
            // Special case.  Serialize stockade-class buildings to
            // otherwise unprivileged clients as the stockade level is
            // visible to anyone who can see the colony.  This should
            // have no other information leaks because stockade
            // buildings have no production or units inside.
<span class="nc" id="L2947">            Building stockade = getStockade();</span>
<span class="nc bnc" id="L2948" title="All 2 branches missed.">            if (stockade != null) stockade.toXML(xw);</span>
        }
<span class="nc" id="L2950">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L2957">        super.readAttributes(xr);</span>

<span class="nc" id="L2959">        established = new Turn(xr.getAttribute(ESTABLISHED_TAG, 0));</span>

<span class="nc" id="L2961">        sonsOfLiberty = xr.getAttribute(SONS_OF_LIBERTY_TAG, 0);</span>

<span class="nc" id="L2963">        oldSonsOfLiberty = xr.getAttribute(OLD_SONS_OF_LIBERTY_TAG, 0);</span>

<span class="nc" id="L2965">        tories = xr.getAttribute(TORIES_TAG, 0);</span>

<span class="nc" id="L2967">        oldTories = xr.getAttribute(OLD_TORIES_TAG, 0);</span>

<span class="nc" id="L2969">        liberty = xr.getAttribute(LIBERTY_TAG, 0);</span>

<span class="nc" id="L2971">        immigration = xr.getAttribute(IMMIGRATION_TAG, 0);</span>

<span class="nc" id="L2973">        productionBonus = xr.getAttribute(PRODUCTION_BONUS_TAG, 0);</span>

<span class="nc" id="L2975">        displayUnitCount = xr.getAttribute(UNIT_COUNT_TAG, -1);</span>
<span class="nc" id="L2976">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // Clear containers.
<span class="nc" id="L2984">        synchronized (colonyTiles) { colonyTiles.clear(); }</span>
<span class="nc" id="L2985">        synchronized (buildingMap) { buildingMap.clear(); }</span>
<span class="nc" id="L2986">        exportData.clear();</span>
<span class="nc" id="L2987">        buildQueue.clear();</span>
<span class="nc" id="L2988">        populationQueue.clear();</span>

<span class="nc" id="L2990">        super.readChildren(xr);</span>

<span class="nc" id="L2992">        invalidateCache();</span>
<span class="nc" id="L2993">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L3000">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3001">        final Game game = getGame();</span>
<span class="nc" id="L3002">        final String tag = xr.getLocalName();</span>

<span class="nc bnc" id="L3004" title="All 2 branches missed.">        if (BUILD_QUEUE_TAG.equals(tag)) {</span>
<span class="nc" id="L3005">            BuildableType bt = xr.getType(spec, ID_ATTRIBUTE_TAG,</span>
<span class="nc" id="L3006">                BuildableType.class, (BuildableType)null);</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">            if (bt != null) buildQueue.add(bt);</span>
<span class="nc" id="L3008">            xr.closeTag(BUILD_QUEUE_TAG);</span>

<span class="nc bnc" id="L3010" title="All 2 branches missed.">        } else if (POPULATION_QUEUE_TAG.equals(xr.getLocalName())) {</span>
<span class="nc" id="L3011">            UnitType ut = xr.getType(spec, ID_ATTRIBUTE_TAG,</span>
<span class="nc" id="L3012">                                     UnitType.class, (UnitType)null);</span>
<span class="nc bnc" id="L3013" title="All 2 branches missed.">            if (ut != null) populationQueue.add(ut);</span>
<span class="nc" id="L3014">            xr.closeTag(POPULATION_QUEUE_TAG);</span>

<span class="nc bnc" id="L3016" title="All 2 branches missed.">        } else if (Building.getTagName().equals(tag)) {</span>
<span class="nc" id="L3017">            addBuilding(xr.readFreeColGameObject(game, Building.class));</span>

<span class="nc bnc" id="L3019" title="All 2 branches missed.">        } else if (ColonyTile.getTagName().equals(tag)) {</span>
<span class="nc" id="L3020">            addColonyTile(xr.readFreeColGameObject(game, ColonyTile.class));</span>

<span class="nc bnc" id="L3022" title="All 2 branches missed.">        } else if (ExportData.getTagName().equals(tag)) {</span>
<span class="nc" id="L3023">            ExportData data = new ExportData(xr);</span>
<span class="nc" id="L3024">            setExportData(data);</span>
        
<span class="nc" id="L3026">        } else {</span>
<span class="nc" id="L3027">            super.readChild(xr);</span>
        }
<span class="nc" id="L3029">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L3036">        return getName();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
<span class="nc" id="L3043">    public String getXMLTagName() { return getTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;colony&quot;.
     */
    public static String getTagName() {
<span class="nc" id="L3051">        return &quot;colony&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</div></body></html>