<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.awt.Color;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Locale;
import java.util.Random;
import java.util.Set;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.function.ToIntFunction;
import java.util.stream.Collectors;

import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.i18n.NameCache;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.NationOptions.NationState;
import net.sf.freecol.common.networking.DOMMessage;
import net.sf.freecol.common.option.OptionGroup;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;
import net.sf.freecol.common.util.Utils;

import org.w3c.dom.Element;


/**
 * Represents a player.  The player can be either a human player or an
 * AI-player, which is further subdivided by PlayerType.
 *
 * In addition to storing the name, nation etc of the player, it also
 * stores various defaults for the player.  One example of this is the
 * {@link #getEntryLocation entry location}.
 */
public class Player extends FreeColGameObject implements Nameable {

<span class="nc" id="L67">    private static final Logger logger = Logger.getLogger(Player.class.getName());</span>
    //
    // Types
    //

    /** Types of players. */
<span class="nc" id="L73">    public static enum PlayerType {</span>
<span class="nc" id="L74">        NATIVE, COLONIAL, REBEL, INDEPENDENT, ROYAL, UNDEAD, RETIRED</span>
    }

    /** Colony value categories. */
<span class="nc" id="L78">    public static enum ColonyValueCategory {</span>
<span class="nc" id="L79">        A_OVERRIDE, // override slot containing showstopper NoValueType values</span>
<span class="nc" id="L80">        A_PROD,     // general production level</span>
<span class="nc" id="L81">        A_TILE,     // strangeness with the tile</span>
<span class="nc" id="L82">        A_EUROPE,   // proximity to Europe</span>
<span class="nc" id="L83">        A_RESOURCE, // penalize building on top of a resource</span>
<span class="nc" id="L84">        A_ADJACENT, // penalize adjacent units and settlement-owned-tiles</span>
<span class="nc" id="L85">        A_FOOD,     // penalize food shortage</span>
<span class="nc" id="L86">        A_LEVEL,    // reward high production potential</span>
<span class="nc" id="L87">        A_NEARBY,   // penalize nearby units and settlements</span>
<span class="nc" id="L88">        A_GOODS;    // check sufficient critical goods available (e.g. lumber)</span>
        // A_GOODS must be last, the spec is entitled to require checks on
        // as many goods types as it likes

        @Override
        public String toString() {
<span class="nc" id="L94">            return super.toString().substring(2);</span>
        }
    }

    /** Special return values for showstopper getColonyValue fail. */
    public static enum NoValueType {
<span class="nc" id="L100">        BOGUS(-1), TERRAIN(-2), RUMOUR(-3), SETTLED(-4), FOOD(-5), INLAND(-6), POLAR(-7);</span>
     
<span class="nc" id="L102">        private static final int MAX = values().length;</span>

        private final int value;


<span class="nc" id="L107">        NoValueType(int value) { this.value = value; }</span>

<span class="nc" id="L109">        public int getValue() { return value; }</span>

<span class="nc" id="L111">        public double getDouble() { return (double)value; }</span>

        public static NoValueType fromValue(int i) {
<span class="nc" id="L114">            int n = -i - 1;</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">            return (n &gt;= 0 &amp;&amp; n &lt; MAX) ? NoValueType.values()[n] : BOGUS;</span>
        }
    }

    
    /**
     * An &lt;code&gt;Iterator&lt;/code&gt; of {@link Unit}s that can be made active.
     */
    public static class UnitIterator implements Iterator&lt;Unit&gt; {

        private final Player owner;

        private final Predicate&lt;Unit&gt; predicate;

<span class="nc" id="L129">        private final List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>


        /**
         * Creates a new &lt;code&gt;UnitIterator&lt;/code&gt;.
         *
         * @param owner The &lt;code&gt;Player&lt;/code&gt; that needs an iterator
         *     of it's units.
         * @param predicate A &lt;code&gt;Predicate&lt;/code&gt; for deciding
         *     whether a &lt;code&gt;Unit&lt;/code&gt; should be included in the
         *     &lt;code&gt;Iterator&lt;/code&gt; or not.
         */
<span class="nc" id="L141">        public UnitIterator(Player owner, Predicate&lt;Unit&gt; predicate) {</span>
<span class="nc" id="L142">            this.owner = owner;</span>
<span class="nc" id="L143">            this.predicate = predicate;</span>
<span class="nc" id="L144">            update();</span>
<span class="nc" id="L145">        }</span>


        /**
         * Update the internal units list with units that satisfy the
         * predicate.
         */
        private final void update() {
<span class="nc" id="L153">            units.clear();</span>
<span class="nc" id="L154">            units.addAll(transformAndSort(owner.getUnits(),</span>
<span class="nc" id="L155">                                          u -&gt; predicate.test(u),</span>
<span class="nc" id="L156">                                          Unit.locComparator,</span>
<span class="nc" id="L157">                                          Collectors.toList()));</span>
<span class="nc" id="L158">        }</span>

        /**
         * Set the next valid unit.
         *
         * @param unit The &lt;code&gt;Unit&lt;/code&gt; to put at the front of the list.
         * @return True if the operation succeeds.
         */
        public boolean setNext(Unit unit) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (predicate.test(unit)) { // Of course, it has to be valid...</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                Unit first = (units.isEmpty()) ? null : units.get(0);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                while (!units.isEmpty()) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">                    if (units.get(0) == unit) return true;</span>
<span class="nc" id="L171">                    units.remove(0);</span>
                }
<span class="nc" id="L173">                update();</span>
<span class="nc bnc" id="L174" title="All 4 branches missed.">                while (!units.isEmpty() &amp;&amp; units.get(0) != first) {</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                    if (units.get(0) == unit) return true;</span>
<span class="nc" id="L176">                    units.remove(0);</span>
                }
            }
<span class="nc" id="L179">            return false;</span>
        }

        /**
         * Removes a specific unit from this unit iterator.
         *
         * @param u The &lt;code&gt;Unit&lt;/code&gt; to remove.
         * @return True if the unit was removed.
         */
        public boolean remove(Unit u) {
<span class="nc" id="L189">            return units.remove(u);</span>
        }

        /**
         * Reset the iterator.
         */
        public void reset() {
<span class="nc" id="L196">            update();</span>
<span class="nc" id="L197">        }</span>


        // Implement Iterator

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean hasNext() {
            // Try to find a unit that still satisfies the predicate.
<span class="nc bnc" id="L208" title="All 2 branches missed.">            while (!units.isEmpty()) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (predicate.test(units.get(0))) {</span>
<span class="nc" id="L210">                    return true; // Still valid</span>
                }
<span class="nc" id="L212">                units.remove(0);</span>
            }
            // Nothing left, so refill the units list.  If it is still
            // empty then there is definitely nothing left.
<span class="nc" id="L216">            update();</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            return !units.isEmpty();</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Unit next() {
<span class="nc bnc" id="L225" title="All 2 branches missed.">            return (hasNext()) ? units.remove(0) : null;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public void remove() {
<span class="nc" id="L233">            next(); // Ignore value</span>
<span class="nc" id="L234">        }</span>
    }


    //
    // Constants
    //

    /** A comparator for ordering players. */
<span class="nc" id="L243">    public static final Comparator&lt;Player&gt; playerComparator</span>
<span class="nc" id="L244">        = Comparator.comparingInt(Player::getRank);</span>

    /** A magic constant to denote that a players gold is not tracked. */
    public static final int GOLD_NOT_ACCOUNTED = Integer.MIN_VALUE;

    /**
     * A token to use for the settlement name in requests to the server
     * to ask the server to choose a settlement name.
     */
    public static final String ASSIGN_SETTLEMENT_NAME = &quot;&quot;;


    //
    // Class variables
    //

    /**
     * The name of this player.  This defaults to the user name in
     * case of a human player and the rulerName of the NationType in
     * case of an AI player.
     */
    protected String name;

    /** The name of this player as an independent nation. */
    protected String independentNationName;

    /** The type of player. */
    protected PlayerType playerType;

    /** The player nation type. */
    protected NationType nationType;

    /** The nation identifier of this player, e.g. &quot;model.nation.dutch&quot;. */
    protected String nationId;

    /** The name this player uses for the New World. */
<span class="nc" id="L280">    protected String newLandName = null;</span>

    /** Is this player an admin? */
    protected boolean admin;

    /** Is this player an AI? */
    protected boolean ai;

    /** Is this player ready to start? */
    protected boolean ready;

    /** Is this player dead? */
<span class="nc" id="L292">    protected boolean dead = false;</span>

    /** True if player has been attacked by privateers. */
<span class="nc" id="L295">    protected boolean attackedByPrivateers = false;</span>

    /**
     * Whether the player is bankrupt, i.e. unable to pay for the
     * maintenance of all buildings.
     */
    private boolean bankrupt;

    /** The current score of this player. */
    protected int score;

    /** The amount of gold this player owns. */
    protected int gold;

    /**
     * The number of immigration points.  Immigration points are an
     * abstract game concept.  They are generated by but are not
     * identical to crosses.
     */
    protected int immigration;

    /**
     * The amount of immigration needed until the next unit decides
     * to migrate.
     */
    protected int immigrationRequired;

    /**
     * The number of liberty points.  Liberty points are an
     * abstract game concept.  They are generated by but are not
     * identical to bells.
     */
    protected int liberty;

    /** SoL from last turn. */
<span class="nc" id="L330">    protected int oldSoL = 0;</span>

    /** The number of liberty bells produced towards the intervention force. */
    protected int interventionBells;

    /** The current tax rate for this player. */
<span class="nc" id="L336">    protected int tax = 0;</span>

    /** The player starting location on the map. */
    protected Location entryLocation;

    /** The market for Europe. */
    protected Market market;

    /** The European port/location for this player. */
    protected Europe europe;

    /** The monarch for this player. */
    protected Monarch monarch;

    /** The founding fathers in this Player's congress. */
<span class="nc" id="L351">    protected final Set&lt;FoundingFather&gt; foundingFathers</span>
<span class="nc" id="L352">        = new HashSet&lt;&gt;();</span>
    /** Current founding father being recruited. */
    protected FoundingFather currentFather;
    /** The offered founding fathers. */
<span class="nc" id="L356">    protected final List&lt;FoundingFather&gt; offeredFathers = new ArrayList&lt;&gt;();</span>

    /**
     * The tension levels, 0-1000, with 1000 being maximum hostility.
     *
     * Only used by AI, but resist the temptation to move it to AIPlayer, the
     * complexity is not worth it.
     */
<span class="nc" id="L364">    protected final java.util.Map&lt;Player, Tension&gt; tension = new HashMap&lt;&gt;();</span>

    /** A list of players who can not establish missions to this player. */
<span class="nc" id="L367">    protected Set&lt;Player&gt; bannedMissions = null;</span>

    /**
     * Stores the stance towards the other players. One of: WAR, CEASE_FIRE,
     * PEACE and ALLIANCE.
     */
<span class="nc" id="L373">    protected final java.util.Map&lt;String, Stance&gt; stance = new HashMap&lt;&gt;();</span>

    /** The trade routes defined by this player. */
<span class="nc" id="L376">    protected final List&lt;TradeRoute&gt; tradeRoutes = new ArrayList&lt;&gt;();</span>

    /** The current model messages for this player. */
<span class="nc" id="L379">    protected final List&lt;ModelMessage&gt; modelMessages = new ArrayList&lt;&gt;();</span>

    /** The history events occuring with this player. */
<span class="nc" id="L382">    protected final List&lt;HistoryEvent&gt; history = new ArrayList&lt;&gt;();</span>

    /** The last-sale data. */
<span class="nc" id="L385">    protected HashMap&lt;String, LastSale&gt; lastSales = null;</span>

    // Temporary/transient variables, do not serialize.

    /** The units this player owns. */
<span class="nc" id="L390">    private final List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>

    /** The settlements this player owns. */
<span class="nc" id="L393">    protected final List&lt;Settlement&gt; settlements = new ArrayList&lt;&gt;();</span>

    /** The tiles the player can see. */
<span class="nc" id="L396">    private boolean[][] canSeeTiles = null;</span>
    /** Are the canSeeTiles valid or do they need to be recalculated? */
<span class="nc" id="L398">    private boolean canSeeValid = false;</span>
    /** Do not access canSeeTiles without taking canSeeLock. */
<span class="nc" id="L400">    private final Object canSeeLock = new Object();</span>

    /** A container for the abilities and modifiers of this type. */
<span class="nc" id="L403">    protected final FeatureContainer featureContainer = new FeatureContainer();</span>

    /** The maximum food consumption of unit types available to this player. */
<span class="nc" id="L406">    private int maximumFoodConsumption = -1;</span>

    /** An iterator for the player units that are still active this turn. */
<span class="nc" id="L409">    private final UnitIterator nextActiveUnitIterator</span>
<span class="nc" id="L410">        = new UnitIterator(this, Unit::couldMove);</span>

    /** An iterator for the player units that have a destination to go to. */
<span class="nc" id="L413">    private final UnitIterator nextGoingToUnitIterator</span>
<span class="nc" id="L414">        = new UnitIterator(this, Unit::goingToDestination);</span>

    /**
     * The HighSeas is a Location that enables Units to travel between
     * the New World and one or several European Ports.
     */
<span class="nc" id="L420">    protected HighSeas highSeas = null;</span>

    /** A cached map of the current nation summary for all live nations. */
<span class="nc" id="L423">    private final java.util.Map&lt;Player, NationSummary&gt; nationCache</span>
<span class="nc" id="L424">        = new HashMap&lt;&gt;();</span>


    //
    // Constructors
    //

    /**
     * Constructor for ServerPlayer.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     */
    protected Player(Game game) {
<span class="nc" id="L437">        super(game);</span>
<span class="nc" id="L438">    }</span>

    /**
     * Initiates a new &lt;code&gt;Player&lt;/code&gt; from an &lt;code&gt;Element&lt;/code&gt; and
     * registers this &lt;code&gt;Player&lt;/code&gt; at the specified game.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param e An XML-element that will be used to initialize this object.
     */
    public Player(Game game, Element e) {
<span class="nc" id="L448">        super(game, null);</span>

<span class="nc" id="L450">        DOMMessage.readFromXMLElement(this, e);</span>
<span class="nc" id="L451">    }</span>

    /**
     * Creates a new &lt;code&gt;Player&lt;/code&gt; with the given id.
     *
     * The object should be initialized later.
     *
     * @param game The &lt;code&gt;Game&lt;/code&gt; this object belongs to.
     * @param id The object identifier.
     */
    public Player(Game game, String id) {
<span class="nc" id="L462">        super(game, id);</span>
<span class="nc" id="L463">    }</span>


    //
    // Names and naming
    //

    /**
     * Gets the name of this player.
     *
     * @return The name of this player.
     */
    @Override
    public String getName() {
<span class="nc" id="L477">        return name;</span>
    }

    /**
     * Set the player name.
     *
     * @param newName The new name value.
     */
    @Override
    public void setName(String newName) {
<span class="nc" id="L487">        this.name = newName;</span>
<span class="nc" id="L488">    }</span>

    /**
     * Get a label for this player.
     *
     * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
     */
    public StringTemplate getLabel() {
<span class="nc" id="L496">        return StringTemplate.label(&quot;&quot;)</span>
<span class="nc" id="L497">            .add(getRulerNameKey())</span>
<span class="nc" id="L498">            .addName(&quot; (&quot;)</span>
<span class="nc" id="L499">            .addStringTemplate(getNationLabel())</span>
<span class="nc" id="L500">            .addName(&quot;)&quot;);</span>
    }

    /**
     * Is this player the unknown enemy?
     *
     * @return True if this player is the unknown enemy.
     */
    public boolean isUnknownEnemy() {
<span class="nc" id="L509">        return Nation.UNKNOWN_NATION_ID.equals(nationId);</span>
    }

    /**
     * Get the new post-declaration player name.
     *
     * @return The post-declaration player name.
     */
    public final String getIndependentNationName() {
<span class="nc" id="L518">        return independentNationName;</span>
    }

    /**
     * Set the post-declaration player name.
     *
     * @param newIndependentNationName The new player name.
     */
    public final void setIndependentNationName(final String newIndependentNationName) {
<span class="nc" id="L527">        this.independentNationName = newIndependentNationName;</span>
<span class="nc" id="L528">    }</span>

    /**
     * Gets the name this player has chosen for the new world.
     *
     * @return The name of the new world as chosen by the &lt;code&gt;Player&lt;/code&gt;,
     *     or null if none chosen yet.
     */
    public String getNewLandName() {
<span class="nc" id="L537">        return newLandName;</span>
    }

    /**
     * Has the player already selected a name for the new world?
     *
     * @return True if the new world has been named by this player.
     */
    public boolean isNewLandNamed() {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        return newLandName != null;</span>
    }

    /**
     * Sets the name this player uses for the new world.
     *
     * @param newLandName This &lt;code&gt;Player&lt;/code&gt;'s name for the new world.
     */
    public void setNewLandName(String newLandName) {
<span class="nc" id="L555">        this.newLandName = newLandName;</span>
<span class="nc" id="L556">    }</span>

    /**
     * Get a name for the new land.
     *
     * @return A suitable name.
     */
    public String getNameForNewLand() {
<span class="nc" id="L564">        return NameCache.getNewLandName(this);</span>
    }

    /**
     * Get a name key for the player Europe.
     *
     * @return A name key, or null if Europe is null.
     */
    public String getEuropeNameKey() {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        return (europe == null) ? null : nationId + &quot;.europe&quot;;</span>
    }

    /**
     * Gets a resource key for the nation name.
     *
     * @return A nation resource key.
     */
    public String getNationResourceKey() {
<span class="nc" id="L582">        return lastPart(nationId, &quot;.&quot;);</span>
    }

    /**
     * Get a template for this players nation name.
     *
     * @return A template for this nation name.
     */
    public StringTemplate getNationLabel() {
<span class="nc bnc" id="L591" title="All 2 branches missed.">        return (playerType == PlayerType.REBEL</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                || playerType == PlayerType.INDEPENDENT)</span>
<span class="nc" id="L593">            ? StringTemplate.name(independentNationName)</span>
<span class="nc" id="L594">            : StringTemplate.key(Messages.nameKey(nationId));</span>
    }

    /**
     * Get a template for this players country.
     *
     * @return A template for this country.
     */
    public StringTemplate getCountryLabel() {
<span class="nc bnc" id="L603" title="All 2 branches missed.">        return (playerType == PlayerType.REBEL</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                || playerType == PlayerType.INDEPENDENT)</span>
<span class="nc" id="L605">            ? StringTemplate.name(independentNationName)</span>
<span class="nc" id="L606">            : StringTemplate.template(&quot;countryName&quot;)</span>
<span class="nc" id="L607">                .addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
    }

    /**
     * Get a label indicating for the national forces.
     *
     * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
     */
    public StringTemplate getForcesLabel() {
<span class="nc" id="L616">        return StringTemplate.template(&quot;model.player.forces&quot;)</span>
<span class="nc" id="L617">            .addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
    }

    /**
     * Get a label indicating that we are waiting for this player.
     *
     * @return A suitable &lt;code&gt;StringTemplate&lt;/code&gt;.
     */
    public StringTemplate getWaitingLabel() {
<span class="nc" id="L626">        return StringTemplate.template(&quot;model.player.waitingFor&quot;)</span>
<span class="nc" id="L627">            .addStringTemplate(&quot;%nation%&quot;, getNationLabel());</span>
    }

    /**
     * Get a short debug-suitable name for this player.
     *
     * @return A short name for this player.
     */
    public String getDebugName() {
<span class="nc" id="L636">        return getNation().getSuffix();</span>
    }

    /**
     * Get a name key for the player nation ruler.
     *
     * @return The ruler name key.
     */
    public final String getRulerNameKey() {
<span class="nc" id="L645">        return Messages.rulerKey(nationId);</span>
    }

    /**
     * Get a resource key for the player monarch image.
     *
     * @return The monarch image key.
     */
    public String getMonarchKey() {
<span class="nc" id="L654">        return &quot;image.flavor.monarch.&quot; + nationId;</span>
    }

    /**
     * What is the name of the player's market?
     * Following a declaration of independence we are assumed to trade
     * broadly with any European market rather than a specific port.
     *
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the player market.
     */
    public StringTemplate getMarketName() {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        return (getEurope() == null)</span>
<span class="nc" id="L666">            ? StringTemplate.key(&quot;model.player.independentMarket&quot;)</span>
<span class="nc" id="L667">            : StringTemplate.key(getEuropeNameKey());</span>
    }

    /**
     * Gets the name of this players capital.  Only meaningful to natives.
     *
     * @param random An optional pseudo-random number source.
     * @return The name of this players capital.
     */
    public String getCapitalName(Random random) {
<span class="nc" id="L677">        return NameCache.getCapitalName(this, random);</span>
    }

    /**
     * Gets a settlement name suitable for this player.
     *
     * @param random An optional pseudo-random number source.
     * @return A new settlement name.
     */
    public String getSettlementName(Random random) {
<span class="nc" id="L687">        return NameCache.getSettlementName(this, random);</span>
    }

    /**
     * Puts a suggested settlement name back into the pool.
     *
     * @param name A formerly suggested settlement name.
     */
    public void putSettlementName(String name) {
<span class="nc" id="L696">        NameCache.putSettlementName(this, name);</span>
<span class="nc" id="L697">    }</span>

    /**
     * Get a name for a region.
     *
     * @param region The &lt;code&gt;Region&lt;/code&gt; to name.
     * @return A suitable name.
     */
    public String getNameForRegion(Region region) {
<span class="nc" id="L706">        return NameCache.getRegionName(this, region);</span>
    }

    /**
     * Gets a new name for a unit.
     *
     * @param type The &lt;code&gt;UnitType&lt;/code&gt; to choose a name for.
     * @param random A pseudo-random number source.
     * @return A name for the unit, or null if not available.
     */
    public String getNameForUnit(UnitType type, Random random) {
<span class="nc" id="L717">        return NameCache.getUnitName(this, type, random);</span>
    }


    //
    // Player / nation types and the implications thereof
    //

    /**
     * Get the type of this player.
     *
     * @return The player type.
     */
    public PlayerType getPlayerType() {
<span class="nc" id="L731">        return playerType;</span>
    }

    /**
     * Sets the player type.
     *
     * @param type The new player type.
     * @see #getPlayerType
     */
    private void setPlayerType(PlayerType type) {
<span class="nc" id="L741">        playerType = type;</span>
<span class="nc" id="L742">    }</span>

    /**
     * Change the player type.
     *
     * Handle special abilities that are added following declaration
     * of independence.  Do not bother removing them ATM, only cases are
     * when going undead and retiring where they are moot.
     *
     * @param type The new player type.
     */
    public void changePlayerType(PlayerType type) {
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (playerType != PlayerType.REBEL</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            &amp;&amp; playerType != PlayerType.INDEPENDENT) {</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">            switch (type) {</span>
            case REBEL: case INDEPENDENT:
<span class="nc" id="L758">                addAbility(new Ability(Ability.INDEPENDENCE_DECLARED, true));</span>
<span class="nc" id="L759">                addAbility(new Ability(Ability.INDEPENDENT_NATION, true));</span>
<span class="nc" id="L760">                break;</span>
            default:
                break;
            }
        }

<span class="nc" id="L766">        setPlayerType(type);</span>
<span class="nc" id="L767">    }</span>

    /**
     * Checks if this player is colonial, and thus can recruit units
     * by producing immigration.
     *
     * @return True if this player is colonial.
     */
    public boolean isColonial() {
<span class="nc bnc" id="L776" title="All 2 branches missed.">        return playerType == PlayerType.COLONIAL;</span>
    }

    /**
     * Checks if this player is European, with does include the REF.
     *
     * @return True if this player is European.
     */
    public boolean isEuropean() {
<span class="nc bnc" id="L785" title="All 2 branches missed.">        return playerType == PlayerType.COLONIAL</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">            || playerType == PlayerType.REBEL</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">            || playerType == PlayerType.INDEPENDENT</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">            || playerType == PlayerType.ROYAL;</span>
    }

    /**
     * Is this a native player?
     *
     * @return True if this player is a native player.
     */
    public boolean isIndian() {
<span class="nc bnc" id="L797" title="All 2 branches missed.">        return playerType == PlayerType.NATIVE;</span>
    }

    /**
     * Is this a colonial rebel player?
     *
     * @return True if this player is a rebel player.
     */
    public boolean isRebel() {
<span class="nc bnc" id="L806" title="All 2 branches missed.">        return playerType == PlayerType.REBEL;</span>
    }

    /**
     * Is this an undead player?
     *
     * @return True if this player is undead.
     */
    public boolean isUndead() {
<span class="nc bnc" id="L815" title="All 2 branches missed.">        return playerType == PlayerType.UNDEAD;</span>
    }

    /**
     * Is this a REF player?
     *
     * @return True if this is a REF player.
     */
    public boolean isREF() {
<span class="nc bnc" id="L824" title="All 2 branches missed.">        return playerType == PlayerType.ROYAL;</span>
    }

    /**
     * Is this player currently on good terms with a given player, and thus
     * a suitable candidate for a random monarch war declaration?
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to possibly declare war on.
     * @return True if this player is a potential enemy.
     */
    public boolean isPotentialEnemy(Player player) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (!hasAbility(Ability.IGNORE_EUROPEAN_WARS)</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">            &amp;&amp; player.getREFPlayer() != this) {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            switch (getStance(player)) {</span>
<span class="nc" id="L838">            case PEACE: case CEASE_FIRE: return true;</span>
            default: break;
            }
        }
<span class="nc" id="L842">        return false;</span>
    }
    
    /**
     * Is this player currently on bad terms with a given player, and thus
     * a suitable candidate for a random monarch peace declaration?
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to possibly declare peace with.
     * @return True if this player is a potential friend.
     */
    public boolean isPotentialFriend(Player player) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (player.getREFPlayer() != this) {</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            switch (getStance(player)) {</span>
<span class="nc" id="L855">            case WAR: case CEASE_FIRE: return true;</span>
            default: break;
            }
        }
<span class="nc" id="L859">        return false;</span>
    }

    /**
     * Get the nation type of this player.
     *
     * @return The &lt;code&gt;NationType&lt;/code&gt; of this player.
     */
    public NationType getNationType() {
<span class="nc" id="L868">        return nationType;</span>
    }

    /**
     * Sets the nation type of this player.
     *
     * @param newNationType The new &lt;code&gt;NationType&lt;/code&gt;.
     */
    public void setNationType(NationType newNationType) {
<span class="nc" id="L877">        nationType = newNationType;</span>
<span class="nc" id="L878">    }</span>

    /**
     * Changes the nation type of this player, handling the features.
     *
     * @param newNationType The new &lt;code&gt;NationType&lt;/code&gt;.
     */
    public void changeNationType(NationType newNationType) {
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (nationType != null) removeFeatures(nationType);</span>
<span class="nc" id="L887">        setNationType(newNationType);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (newNationType != null) addFeatures(newNationType);</span>
<span class="nc" id="L889">    }</span>

    /**
     * Can this player build colonies?
     *
     * @return True if this player can found colonies.
     */
    public boolean canBuildColonies() {
<span class="nc" id="L897">        return nationType.hasAbility(Ability.FOUNDS_COLONIES);</span>
    }

    /**
     * Can this player recruit founding fathers?
     *
     * @return True if this player can recruit founding fathers.
     */
    public boolean canHaveFoundingFathers() {
<span class="nc" id="L906">        return nationType.hasAbility(Ability.ELECT_FOUNDING_FATHER);</span>
    }

    /**
     * Get the identifier for this Player's nation.
     *
     * @return The nation identifier.
     */
    public String getNationId() {
<span class="nc" id="L915">        return nationId;</span>
    }

    /**
     * Gets this Player's nation.
     *
     * @return The player &lt;code&gt;Nation&lt;/code&gt;.
     */
    public Nation getNation() {
<span class="nc" id="L924">        return getSpecification().getNation(nationId);</span>
    }

    /**
     * Sets the nation for this player.
     *
     * @param newNation The new &lt;code&gt;Nation&lt;/code&gt;.
     */
    public void setNation(Nation newNation) {
<span class="nc" id="L933">        Nation oldNation = getNation();</span>
<span class="nc" id="L934">        nationId = newNation.getId();</span>
<span class="nc" id="L935">        java.util.Map&lt;Nation, NationState&gt; nations</span>
<span class="nc" id="L936">            = getGame().getNationOptions().getNations();</span>
<span class="nc" id="L937">        nations.put(oldNation, NationState.AVAILABLE);</span>
<span class="nc" id="L938">        nations.put(newNation, NationState.NOT_AVAILABLE);</span>
<span class="nc" id="L939">    }</span>

    /**
     * Is this player an admin.
     *
     * @return True if the player is an admin.
     */
    public boolean isAdmin() {
<span class="nc" id="L947">        return admin;</span>
    }

    /**
     * Is this an AI player?
     *
     * @return True if this is an AI player.
     */
    public boolean isAI() {
<span class="nc" id="L956">        return ai;</span>
    }

    /**
     * Sets whether this player is an AI player.
     *
     * @param ai The AI player value.
     */
    public void setAI(boolean ai) {
<span class="nc" id="L965">        this.ai = ai;</span>
<span class="nc" id="L966">    }</span>

    /**
     * Is this player ready to start the game?
     *
     * @return True if this &lt;code&gt;Player&lt;/code&gt; is ready to start the game.
     */
    public boolean isReady() {
<span class="nc" id="L974">        return ready;</span>
    }

    /**
     * Sets this players readiness state.
     *
     * @param ready The new readiness state.
     */
    public void setReady(boolean ready) {
<span class="nc" id="L983">        this.ready = ready;</span>
<span class="nc" id="L984">    }</span>

    /**
     * Checks if this player is dead.  A &lt;code&gt;Player&lt;/code&gt; dies when it
     * loses the game.
     *
     * @return True if this &lt;code&gt;Player&lt;/code&gt; is dead.
     */
    public boolean isDead() {
<span class="nc" id="L993">        return dead;</span>
    }

    /**
     * Get the player death state.
     * This is indeed identical to isDead(), but is needed for partial
     * updates to complement the setDead() function.
     *
     * @return True if this &lt;code&gt;Player&lt;/code&gt; is dead.
     */
    public boolean getDead() {
<span class="nc" id="L1004">        return dead;</span>
    }

    /**
     * Sets this player to be dead or not.
     *
     * @param dead The new death state.
     * @see #getDead
     */
    public void setDead(boolean dead) {
<span class="nc" id="L1014">        this.dead = dead;</span>
<span class="nc" id="L1015">    }</span>

    /**
     * Has player has been attacked by privateers?
     *
     * @return True if this player has been attacked by privateers.
     */
    public boolean getAttackedByPrivateers() {
<span class="nc" id="L1023">        return attackedByPrivateers;</span>
    }

    /**
     * Sets whether this player has been attacked by privateers.
     *
     * @param attacked True if the player has been attacked by privateers.
     */
    public void setAttackedByPrivateers(boolean attacked) {
<span class="nc" id="L1032">        attackedByPrivateers = attacked;</span>
<span class="nc" id="L1033">    }</span>

    /**
     * Checks if this player has work to do if it is a REF-player.
     *
     * @return True if any of our units are located in the new
     *     world or a nation is in rebellion against us.
     */
    public boolean isWorkForREF() {
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        return (any(getUnits(), Unit::hasTile))</span>
<span class="nc" id="L1043">            ? true // Work to do still if there exists a unit in the new world</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            : !getRebels().isEmpty();</span>
    }

    /**
     * Gets a list of the players in rebellion against this (REF) player.
     *
     * @return A list of nations in rebellion against us.
     */
    public List&lt;Player&gt; getRebels() {
<span class="nc" id="L1053">        return transform(getGame().getLiveEuropeanPlayers(this),</span>
<span class="nc bnc" id="L1054" title="All 6 branches missed.">            p -&gt; p.getREFPlayer() == this &amp;&amp; (p.isRebel() || p.isUndead()),</span>
<span class="nc" id="L1055">            Collectors.toList());</span>
    }

    /**
     * Gets the &lt;code&gt;Player&lt;/code&gt; controlling the &quot;Royal Expeditionary
     * Force&quot; for this player.
     *
     * @return The player, or &lt;code&gt;null&lt;/code&gt; if this player does not have a
     *         royal expeditionary force.
     */
    public Player getREFPlayer() {
<span class="nc" id="L1066">        Nation ref = getNation().getREFNation();</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">        return (ref == null) ? null : getGame().getPlayerByNation(ref);</span>
    }

    /**
     * Gets the player nation color.
     *
     * @return The &lt;code&gt;Color&lt;/code&gt;.
     */
    public Color getNationColor() {
<span class="nc" id="L1076">        final Nation nation = getNation();</span>
<span class="nc" id="L1077">        Color color = nation.getColor();</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">        return (color != null) ? color : nation.forceDefaultColor();</span>
    }

    /**
     * Get an integer to broadly categorized the player for sorting.
     * AIs should always follow humans, and the administrator is special.
     *
     * @return An identifying integer.
     */
    public int getRank() {
<span class="nc bnc" id="L1088" title="All 2 branches missed.">        int ret = (isEuropean()) ? 1 : 0;</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (isAI()) ret |= 2;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if (isAdmin()) ret |= 4;</span>
<span class="nc" id="L1091">        return ret;</span>
    }


    //
    // Scoring and finance
    //

    /**
     * Gets the current score of the player.
     *
     * @return The score.
     */
    public int getScore() {
<span class="nc" id="L1105">        return score;</span>
    }

    /**
     * Set the current score of the player.
     *
     * @param score The new score.
     */
    public void setScore(int score) {
<span class="nc" id="L1114">        this.score = score;</span>
<span class="nc" id="L1115">    }</span>

    /**
     * Gets the score by which we decide the weakest and strongest AI
     * players for the Spanish Succession event.
     *
     * @return A strength score.
     */
    public int getSpanishSuccessionScore() {
<span class="nc" id="L1124">        return getScore();</span>
    }

    /**
     * Get the amount of gold that this player has.
     *
     * Some players do not account their gold.  These players return
     * GOLD_NOT_ACCOUNTED.
     *
     * @return The amount of gold that this player has.
     */
    public int getGold() {
<span class="nc" id="L1136">        return gold;</span>
    }

    /**
     * Set the amount of gold that this player has.
     *
     * @param newGold The new player gold value.
     */
    public void setGold(int newGold) {
<span class="nc" id="L1145">        gold = newGold;</span>
<span class="nc" id="L1146">    }</span>

    /**
     * Checks if the player has enough gold to make a purchase.
     * Use this rather than comparing with getGold(), as this handles
     * players that do not account for gold.
     *
     * @param amount The purchase price to check.
     * @return True if the player can afford the purchase.
     */
    public boolean checkGold(int amount) {
<span class="nc bnc" id="L1157" title="All 4 branches missed.">        return this.gold == GOLD_NOT_ACCOUNTED || this.gold &gt;= amount;</span>
    }

    /**
     * Modifies the amount of gold that this player has.  The argument can be
     * both positive and negative.
     *
     * @param amount The amount of gold to be added to this player.
     * @return The amount of gold post-modification.
     */
    public int modifyGold(int amount) {
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (this.gold != Player.GOLD_NOT_ACCOUNTED) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            if ((gold + amount) &gt;= 0) {</span>
<span class="nc" id="L1170">                gold += amount;</span>
<span class="nc" id="L1171">            } else {</span>
                // This can happen if the server and the client get
                // out of sync.  Perhaps it can also happen if the
                // client tries to adjust gold for another player,
                // where the balance is unknown. Just keep going and
                // do the best thing possible, we don't want to crash
                // the game here.
<span class="nc" id="L1178">                logger.warning(&quot;Cannot add &quot; + amount + &quot; gold for &quot;</span>
<span class="nc" id="L1179">                    + this + &quot;: would be negative!&quot;);</span>
<span class="nc" id="L1180">                gold = 0;</span>
            }
        }
<span class="nc" id="L1183">        return gold;</span>
    }

    /**
     * Get the bankruptcy state.
     *
     * isBankrupt would be nicer, but the introspector expects getBankrupt.
     *
     * @return True if this player is bankrupt.
     */
    public final boolean getBankrupt() {
<span class="nc" id="L1194">        return bankrupt;</span>
    }

    /**
     * Set the bankruptcy state.
     *
     * @param newBankrupt The new bankruptcy value.
     */
    public final void setBankrupt(final boolean newBankrupt) {
<span class="nc" id="L1203">        this.bankrupt = newBankrupt;</span>
<span class="nc" id="L1204">    }</span>


    //
    // Migration
    //

    /**
     * Gets the amount of immigration this player possess.
     *
     * @return The immigration value.
     * @see #reduceImmigration
     */
    public int getImmigration() {
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        return (isColonial()) ? immigration : 0;</span>
    }

    /**
     * Sets the amount of immigration this player possess.
     *
     * @param immigration The immigration value for this player.
     */
    public void setImmigration(int immigration) {
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (!isColonial()) return;</span>
<span class="nc" id="L1228">        this.immigration = immigration;</span>
<span class="nc" id="L1229">    }</span>

    /**
     * Sets the number of immigration this player possess.
     */
    public void reduceImmigration() {
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (!isColonial()) return;</span>

<span class="nc" id="L1237">        int cost = getSpecification()</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            .getBoolean(GameOptions.SAVE_PRODUCTION_OVERFLOW)</span>
<span class="nc" id="L1239">            ? immigrationRequired : immigration;</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">        if (cost &gt; immigration) {</span>
<span class="nc" id="L1241">            immigration = 0;</span>
<span class="nc" id="L1242">        } else {</span>
<span class="nc" id="L1243">            immigration -= cost;</span>
        }
<span class="nc" id="L1245">    }</span>

    /**
     * Modify the player immigration.
     *
     * @param amount The amount to modify the immigration by.
     */
    public void modifyImmigration(int amount) {
<span class="nc" id="L1253">        immigration = Math.max(0, immigration + amount);</span>
<span class="nc" id="L1254">    }</span>

    /**
     * Gets the amount of immigration required to cause a new colonist
     * to emigrate.
     *
     * @return The immigration points required to trigger emigration.
     */
    public int getImmigrationRequired() {
<span class="nc" id="L1263">        return immigrationRequired;</span>
    }

    /**
     * Sets the number of immigration required to cause a new colonist
     * to emigrate.
     *
     * @param immigrationRequired The new number of immigration points.
     */
    public void setImmigrationRequired(int immigrationRequired) {
<span class="nc" id="L1273">        this.immigrationRequired = immigrationRequired;</span>
<span class="nc" id="L1274">    }</span>

    /**
     * Updates the amount of immigration needed to emigrate a &lt;code&gt;Unit&lt;/code&gt;
     * from &lt;code&gt;Europe&lt;/code&gt;.
     */
    public void updateImmigrationRequired() {
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (!isColonial()) return;</span>

<span class="nc" id="L1283">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1284">        final Turn turn = getGame().getTurn();</span>
<span class="nc" id="L1285">        final int current = immigrationRequired;</span>
<span class="nc" id="L1286">        int base = spec.getInteger(GameOptions.CROSSES_INCREMENT);</span>
        // If the religious unrest bonus is present, immigrationRequired
        // has already been reduced.  We want to apply the bonus to the
        // sum of the *unreduced* immigration target and the increment.
<span class="nc" id="L1290">        int unreduced = Math.round(current</span>
<span class="nc" id="L1291">            / applyModifiers(1f, turn, Modifier.RELIGIOUS_UNREST_BONUS));</span>
<span class="nc" id="L1292">        immigrationRequired = (int)applyModifiers(unreduced + base, turn,</span>
<span class="nc" id="L1293">            Modifier.RELIGIOUS_UNREST_BONUS);;</span>
<span class="nc" id="L1294">        logger.finest(&quot;Immigration for &quot; + getId() + &quot; updated &quot; + current</span>
<span class="nc" id="L1295">            + &quot; -&gt; &quot; + immigrationRequired);</span>
<span class="nc" id="L1296">    }</span>

    /**
     * Should a new colonist emigrate?
     *
     * @return Whether a new colonist should emigrate.
     */
    public boolean checkEmigrate() {
<span class="nc bnc" id="L1304" title="All 4 branches missed.">        return (isColonial()) ? getImmigrationRequired() &lt;= immigration</span>
<span class="nc" id="L1305">            : false;</span>
    }

    /**
     * Get the total immigration production for this player.
     *
     * @return The total immigration production.
     */
    public int getTotalImmigrationProduction() {
<span class="nc bnc" id="L1314" title="All 2 branches missed.">        if (!isColonial()) return 0;</span>
        
<span class="nc" id="L1316">        final List&lt;GoodsType&gt; immigrationGoodsTypes = getSpecification()</span>
<span class="nc" id="L1317">            .getImmigrationGoodsTypeList();</span>
<span class="nc" id="L1318">        int production = sum(getColonies(),</span>
<span class="nc" id="L1319">            c -&gt; sum(immigrationGoodsTypes, gt -&gt; c.getTotalProductionOf(gt)));</span>
<span class="nc" id="L1320">        final Europe europe = getEurope();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">        if (europe != null) production += europe.getImmigration(production);</span>
<span class="nc" id="L1322">        return production;</span>
    }

    /**
     * Get a message for a newly migrating unit.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is migrating.
     * @return A suitable &lt;code&gt;ModelMessage&lt;/code&gt;.
     */
    public ModelMessage getEmigrationMessage(Unit unit) {
<span class="nc" id="L1332">        return new ModelMessage(ModelMessage.MessageType.UNIT_ADDED,</span>
<span class="nc" id="L1333">                                &quot;model.player.emigrate&quot;,</span>
<span class="nc" id="L1334">                                this, unit)</span>
<span class="nc" id="L1335">            .addNamed(&quot;%europe%&quot;, getEurope())</span>
<span class="nc" id="L1336">            .addStringTemplate(&quot;%unit%&quot;, unit.getLabel());</span>
    }


    //
    // Liberty and founding fathers
    //

    /**
     * Gets the current amount of liberty points this player has.
     * Liberty is regularly reduced to pay for a founding father.
     *
     * @return The amount of liberty points.
     */
    public int getLiberty() {
<span class="nc bnc" id="L1351" title="All 2 branches missed.">        return (canHaveFoundingFathers()) ? liberty : 0;</span>
    }

    /**
     * Sets the current amount of liberty this player has.
     *
     * @param liberty The new amount of liberty.
     */
    public void setLiberty(int liberty) {
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        if (!canHaveFoundingFathers()) return;</span>
<span class="nc" id="L1361">        this.liberty = liberty;</span>
<span class="nc" id="L1362">    }</span>

    /**
     * Modifies the current amount of liberty this player has.
     *
     * @param amount The amount of liberty to add.
     */
    public void modifyLiberty(int amount) {
<span class="nc" id="L1370">        setLiberty(Math.max(0, liberty + amount));</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">        if (isRebel()) interventionBells += amount;</span>
<span class="nc" id="L1372">    }</span>

    /**
     * Recalculate bells bonus when tax changes.
     *
     * @return True if a bells bonus was set.
     */
    protected boolean recalculateBellsBonus() {
<span class="nc" id="L1380">        Set&lt;Modifier&gt; libertyBonus = getModifiers(&quot;model.goods.bells&quot;);</span>
<span class="nc" id="L1381">        boolean ret = false;</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        for (Ability ability : getAbilities(Ability.ADD_TAX_TO_BELLS)) {</span>
<span class="nc" id="L1383">            FreeColObject source = ability.getSource();</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            if (source != null) {</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">                for (Modifier modifier : libertyBonus) {</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                    if (source.equals(modifier.getSource())) {</span>
<span class="nc" id="L1387">                        modifier.setValue(tax);</span>
<span class="nc" id="L1388">                        ret = true;</span>
                    }
                }
            }
        }
<span class="nc" id="L1393">        return ret;</span>
    }

    /**
     * Gets how much liberty will be produced next turn if no colonies
     * are lost and nothing unexpected happens.
     *
     * @return The total amount of liberty this &lt;code&gt;Player&lt;/code&gt;'s
     *     &lt;code&gt;Colony&lt;/code&gt;s will make next turn.
     */
    public int getLibertyProductionNextTurn() {
<span class="nc" id="L1404">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1405">        int nextTurn = sum(getColonies(),</span>
<span class="nc" id="L1406">            c -&gt; sum(spec.getLibertyGoodsTypeList(),</span>
<span class="nc" id="L1407">                     gt -&gt; c.getTotalProductionOf(gt)));</span>
<span class="nc" id="L1408">        return (int)applyModifiers((float)nextTurn, getGame().getTurn(),</span>
<span class="nc" id="L1409">                                   Modifier.LIBERTY);</span>
    }

    /**
     * Gets the total percentage of rebels in all this player's colonies.
     *
     * @return The total percentage of rebels in all this player's colonies.
     */
    public int getSoL() {
<span class="nc" id="L1418">        final List&lt;Colony&gt; colonies = getColonies();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        return (colonies.isEmpty()) ? 0</span>
<span class="nc" id="L1420">            : sum(colonies, Colony::getSoL) / colonies.size();</span>
    }

    /**
     * Gets the founding fathers in this player's congress.
     *
     * @return A set of &lt;code&gt;FoundingFather&lt;/code&gt;s in congress.
     */
    public Set&lt;FoundingFather&gt; getFathers() {
<span class="nc" id="L1429">        return foundingFathers;</span>
    }

    /**
     * Does this player have a certain Founding father.
     *
     * @param someFather The &lt;code&gt;FoundingFather&lt;/code&gt; to check.
     * @return Whether this player has this Founding father
     * @see FoundingFather
     */
    public boolean hasFather(FoundingFather someFather) {
<span class="nc" id="L1440">        return foundingFathers.contains(someFather);</span>
    }

    /**
     * Gets the number of founding fathers in this players congress. 
     * Used to calculate number of liberty needed to recruit new fathers.
     *
     * @return The number of founding fathers in this players congress
     */
    public int getFatherCount() {
<span class="nc" id="L1450">        return foundingFathers.size();</span>
    }

    /**
     * Add a founding father to the congress.
     *
     * @param father The &lt;code&gt;FoundingFather&lt;/code&gt; to add.
     */
    public void addFather(FoundingFather father) {
<span class="nc" id="L1459">        foundingFathers.add(father);</span>
<span class="nc" id="L1460">        addFeatures(father);</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        for (Colony colony : getColonies()) colony.invalidateCache();</span>
<span class="nc" id="L1462">    }</span>

    /**
     * Gets the {@link FoundingFather founding father} this player is working
     * towards.
     *
     * @return The current &lt;code&gt;FoundingFather&lt;/code&gt;, or null if
     *     there is none.
     * @see #setCurrentFather
     * @see FoundingFather
     */
    public FoundingFather getCurrentFather() {
<span class="nc" id="L1474">        return currentFather;</span>
    }

    /**
     * Sets the current founding father to recruit.
     *
     * @param someFather The &lt;code&gt;FoundingFather&lt;/code&gt; to recruit.
     * @see FoundingFather
     */
    public void setCurrentFather(FoundingFather someFather) {
<span class="nc" id="L1484">        currentFather = someFather;</span>
<span class="nc" id="L1485">    }</span>

    /**
     * Gets the offered fathers for this player.
     *
     * @return A list of the current offered &lt;code&gt;FoundingFather&lt;/code&gt;s.
     */
    public List&lt;FoundingFather&gt; getOfferedFathers() {
<span class="nc" id="L1493">        return offeredFathers;</span>
    }

    /**
     * Clear the set of offered fathers.
     */
    public void clearOfferedFathers() {
<span class="nc" id="L1500">        offeredFathers.clear();</span>
<span class="nc" id="L1501">    }</span>

    /**
     * Sets the set of offered fathers.
     *
     * @param fathers A list of &lt;code&gt;FoundingFather&lt;/code&gt;s to offer.
     */
    public void setOfferedFathers(List&lt;FoundingFather&gt; fathers) {
<span class="nc" id="L1509">        clearOfferedFathers();</span>
<span class="nc" id="L1510">        offeredFathers.addAll(fathers);</span>
<span class="nc" id="L1511">    }</span>

    /**
     * Gets the number of liberty points needed to recruit the next
     * founding father.
     *
     * @return How many more liberty points the &lt;code&gt;Player&lt;/code&gt;
     *     needs in order to recruit the next &lt;code&gt;FoundingFather&lt;/code&gt;.
     */
    public int getRemainingFoundingFatherCost() {
<span class="nc" id="L1521">        return getTotalFoundingFatherCost() - getLiberty();</span>
    }

    /**
     * How many liberty points in total are needed to earn the
     * Founding Father we are trying to recruit.  See
     * https://sourceforge.net/p/freecol/bugs/2623 where the Col1
     * numbers were checked.
     *
     * @return Total number of liberty points the &lt;code&gt;Player&lt;/code&gt;
     *     needs to recruit the next &lt;code&gt;FoundingFather&lt;/code&gt;.
     */
    public int getTotalFoundingFatherCost() {
<span class="nc" id="L1534">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1535">        int base = spec.getInteger(GameOptions.FOUNDING_FATHER_FACTOR);</span>
<span class="nc" id="L1536">        int count = getFatherCount();</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">        return (count == 0) ? base : 2 * (count + 1) * base + 1;</span>
    }

    /**
     * Gets the &lt;code&gt;Turn&lt;/code&gt;s during which FoundingFathers were
     * elected to the Continental Congress
     *
     * @return A map of father id to &lt;code&gt;Turn&lt;/code&gt;s.
     */
    public java.util.Map&lt;String, Turn&gt; getElectionTurns() {
<span class="nc" id="L1547">        return transform(getHistory(),</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">            e -&gt; e.getEventType() == HistoryEvent.HistoryEventType.FOUNDING_FATHER,</span>
<span class="nc" id="L1549">            Collectors.toMap(e -&gt; e.getReplacement(&quot;%father%&quot;).getId(),</span>
<span class="nc" id="L1550">                             e -&gt; e.getTurn()));</span>
    }

    /**
     * Check whether this player can declare independence.
     *
     * @return Null if there is no barrier to declaration, otherwise
     *     a &lt;code&gt;StringTemplate&lt;/code&gt; explaining the problem.
     */
    public StringTemplate checkDeclareIndependence() {
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        if (getPlayerType() != PlayerType.COLONIAL)</span>
<span class="nc" id="L1561">            return StringTemplate.template(&quot;model.player.colonialIndependence&quot;);</span>
<span class="nc" id="L1562">        final Event event = getSpecification()</span>
<span class="nc" id="L1563">            .getEvent(&quot;model.event.declareIndependence&quot;);</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">        Limit limit = find(event.getLimits(), l -&gt; !l.evaluate(this));</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">        return (limit == null) ? null</span>
<span class="nc" id="L1566">            : StringTemplate.template(limit.getDescriptionKey())</span>
<span class="nc" id="L1567">                .addAmount(&quot;%limit%&quot;, limit.getRightHandSide()</span>
<span class="nc" id="L1568">                    .getValue(getGame()));</span>
    }

    /**
     * Generic strength calculation.
     *
     * @param naval If true consider naval units, otherwise land units.
     * @return A measure of naval or land offensive power.
     */
    public int calculateStrength(boolean naval) {
<span class="nc" id="L1578">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">        return (int)sumDouble(getUnits(), u -&gt; u.isNaval() == naval,</span>
<span class="nc" id="L1580">                              u -&gt; cm.getOffencePower(u, null));</span>
    }

    /**
     * Get the strength ratio of this player with respect to its REF.
     *
     * @param naval If true consider naval units, otherwise land units.
     * @return A measure of the military viability of this player.
     */
    public double getRebelStrengthRatio(boolean naval) {
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        if (getPlayerType() != PlayerType.COLONIAL) return 0.0;</span>
<span class="nc" id="L1591">        return strengthRatio(calculateStrength(naval),</span>
<span class="nc" id="L1592">            getMonarch().getExpeditionaryForce().calculateStrength(naval));</span>
    }


    /**
     * Get a list of abstract REF units for this player.
     *
     * @return A list of &lt;code&gt;AbstractUnit&lt;/code&gt;s defining the REF,
     *     or null if not available.
     */
    public List&lt;AbstractUnit&gt; getREFUnits() {
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        return (getPlayerType() == PlayerType.COLONIAL)</span>
<span class="nc" id="L1604">            ? getMonarch().getExpeditionaryForce().getUnits()</span>
<span class="nc" id="L1605">            : null;</span>
    }

    /**
     * Get a list of the military units for this player.
     *
     * @return A list of military &lt;code&gt;AbstractUnit&lt;/code&gt;s.
     */
    public List&lt;AbstractUnit&gt; getMilitaryUnits() {
<span class="nc" id="L1614">        final UnitType defaultType = getSpecification().getDefaultUnitType(this);</span>
<span class="nc" id="L1615">        java.util.Map&lt;UnitType, HashMap&lt;String, Integer&gt;&gt; unitHash</span>
<span class="nc" id="L1616">            = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1617">        List&lt;AbstractUnit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        for (Unit unit : getUnits()) {</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">            if (!unit.isOffensiveUnit()) continue;</span>
<span class="nc" id="L1620">            UnitType unitType = defaultType;</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">            if (unit.getType().getOffence() &gt; 0</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                || unit.hasAbility(Ability.EXPERT_SOLDIER)) {</span>
<span class="nc" id="L1623">                unitType = unit.getType();</span>
            }
<span class="nc" id="L1625">            HashMap&lt;String, Integer&gt; roleMap = unitHash.get(unitType);</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">            if (roleMap == null) roleMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1627">            String roleId = unit.getRole().getId();</span>
<span class="nc" id="L1628">            Integer count = roleMap.get(roleId);</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">            roleMap.put(roleId, (count == null) ? 1 : count + 1);</span>
<span class="nc" id="L1630">            unitHash.put(unitType, roleMap);</span>
        }
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        for (java.util.Map.Entry&lt;UnitType, HashMap&lt;String, Integer&gt;&gt; typeEntry</span>
<span class="nc" id="L1633">                 : unitHash.entrySet()) {</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">            for (java.util.Map.Entry&lt;String, Integer&gt; roleEntry</span>
<span class="nc" id="L1635">                     : typeEntry.getValue().entrySet()) {</span>
<span class="nc" id="L1636">                units.add(new AbstractUnit(typeEntry.getKey(),</span>
<span class="nc" id="L1637">                        roleEntry.getKey(), roleEntry.getValue()));</span>
            }
        }
<span class="nc" id="L1640">        return units;</span>
    }
    

    //
    // Taxation and trade
    //

    /**
     * Get the current tax.
     *
     * @return The current tax.
     */
    public int getTax() {
<span class="nc" id="L1654">        return tax;</span>
    }

    /**
     * Sets the current tax
     *
     * @param amount The new tax amount.
     */
    public void setTax(int amount) {
<span class="nc" id="L1663">        tax = amount;</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if (recalculateBellsBonus()) {</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">            for (Colony colony : getColonies()) colony.invalidateCache();</span>
        }
<span class="nc" id="L1667">    }</span>

    /**
     * Get this player's Market.
     *
     * @return The &lt;code&gt;Market&lt;/code&gt;.
     */
    public Market getMarket() {
<span class="nc" id="L1675">        return market;</span>
    }

    /**
     * Resets this player's Market.
     */
    public void reinitialiseMarket() {
<span class="nc" id="L1682">        market = new Market(getGame(), this);</span>
<span class="nc" id="L1683">    }</span>

    /**
     * Gets the current sales data for a location and goods type.
     *
     * @param where The &lt;code&gt;Location&lt;/code&gt; of the sale.
     * @param what The &lt;code&gt;GoodsType&lt;/code&gt; sold.
     *
     * @return An appropriate &lt;code&gt;LastSaleData&lt;/code&gt; record, or
     *     null if no appropriate sale can be found.
     */
    public LastSale getLastSale(Location where, GoodsType what) {
<span class="nc bnc" id="L1695" title="All 2 branches missed.">        return (lastSales == null) ? null</span>
<span class="nc" id="L1696">            : lastSales.get(LastSale.makeKey(where, what));</span>
    }

    /**
     * Saves a record of a sale.
     *
     * @param sale The &lt;code&gt;LastSale&lt;/code&gt; to save.
     */
    public void addLastSale(LastSale sale) {
<span class="nc bnc" id="L1705" title="All 2 branches missed.">        if (lastSales == null) lastSales = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1706">        lastSales.put(sale.getId(), sale);</span>
<span class="nc" id="L1707">    }</span>

    /**
     * Gets the last sale price for a location and goods type as a string.
     *
     * @param where The &lt;code&gt;Location&lt;/code&gt; of the sale.
     * @param what The &lt;code&gt;GoodsType&lt;/code&gt; sold.
     * @return An abbreviation for the sale price, or null if none found.
     */
    public String getLastSaleString(Location where, GoodsType what) {
<span class="nc" id="L1717">        LastSale data = getLastSale(where, what);</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">        return (data == null) ? null : String.valueOf(data.getPrice());</span>
    }

    /**
     * Get a template for the last sale price for a location and goods type.
     *
     * @param where The &lt;code&gt;Location&lt;/code&gt; of the sale.
     * @param what The &lt;code&gt;GoodsType&lt;/code&gt; sold.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the sale, or null if
     *     none found.
     */
    public StringTemplate getLastSaleTip(Location where, GoodsType what) {
<span class="nc" id="L1730">        LastSale data = getLastSale(where, what);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        return (data == null) ? null</span>
<span class="nc" id="L1732">            : StringTemplate.template(&quot;model.indianSettlement.lastSale&quot;)</span>
<span class="nc" id="L1733">                .addNamed(&quot;%goodsType%&quot;, what)</span>
<span class="nc" id="L1734">                .addAmount(&quot;%price%&quot;, data.getPrice())</span>
<span class="nc" id="L1735">                .addStringTemplate(&quot;%turn%&quot;, data.getWhen().getLabel());</span>
    }

    /**
     * Gets the arrears due for a type of goods.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return The arrears due for this type of goods.
     */
    public int getArrears(GoodsType type) {
<span class="nc" id="L1745">        return getMarket().getArrears(type);</span>
    }

    /**
     * Can a type of goods can be traded in Europe?
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return True if there are no arrears due for this type of goods.
     */
    public boolean canTrade(GoodsType type) {
<span class="nc" id="L1755">        return canTrade(type, Market.Access.EUROPE);</span>
    }

    /**
     * Can a type of goods can be traded at a specified place?
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @param access The way the goods are traded (Europe OR Custom)
     * @return True if type of goods can be traded.
     */
    public boolean canTrade(GoodsType type, Market.Access access) {
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        return getMarket().getArrears(type) == 0</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">            || (access == Market.Access.CUSTOM_HOUSE</span>
<span class="nc bnc" id="L1768" title="All 2 branches missed.">                &amp;&amp; (getSpecification().getBoolean(GameOptions.CUSTOM_IGNORE_BOYCOTT)</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">                    || (hasAbility(Ability.CUSTOM_HOUSE_TRADES_WITH_FOREIGN_COUNTRIES)</span>
<span class="nc" id="L1770">                        &amp;&amp; any(getGame().getLiveEuropeanPlayers(this),</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                            p -&gt; getStance(p) == Stance.PEACE</span>
<span class="nc bnc" id="L1772" title="All 4 branches missed.">                                || getStance(p) == Stance.ALLIANCE))));</span>
    }

    /**
     * Get the current sales of a type of goods.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to query.
     * @return The current sales.
     */
    public int getSales(GoodsType goodsType) {
<span class="nc" id="L1782">        return getMarket().getSales(goodsType);</span>
    }

    /**
     * Modifies the current sales.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
     * @param amount The new sales.
     */
    public void modifySales(GoodsType goodsType, int amount) {
<span class="nc" id="L1792">        getMarket().modifySales(goodsType, amount);</span>
<span class="nc" id="L1793">    }</span>

    /**
     * Has a type of goods been traded?
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to check.
     * @return Whether these goods have been traded.
     */
    public boolean hasTraded(GoodsType goodsType) {
<span class="nc" id="L1802">        return getMarket().hasBeenTraded(goodsType);</span>
    }

    /**
     * Get the most valuable goods available in one of the player's
     * colonies for the purposes of choosing a threat-to-boycott.  The
     * goods must not currently be boycotted, the player must have
     * traded in it, and the amount to be discarded will not exceed
     * GoodsContainer.CARGO_SIZE.
     *
     * @return A goods object, or null if nothing suitable found.
     */
    public Goods getMostValuableGoods() {
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (!isEuropean()) return null;</span>

<span class="nc" id="L1817">        Goods goods = null;</span>
<span class="nc" id="L1818">        int highValue = 0;</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        for (Colony colony : getColonies()) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            for (Goods g : colony.getCompactGoods()) {</span>
<span class="nc bnc" id="L1821" title="All 4 branches missed.">                if (getArrears(g.getType()) &lt;= 0 &amp;&amp; hasTraded(g.getType())) {</span>
<span class="nc" id="L1822">                    int amount = Math.min(g.getAmount(),</span>
<span class="nc" id="L1823">                                          GoodsContainer.CARGO_SIZE);</span>
<span class="nc" id="L1824">                    int value = market.getSalePrice(g.getType(), amount);</span>
<span class="nc bnc" id="L1825" title="All 2 branches missed.">                    if (value &gt; highValue) {</span>
<span class="nc" id="L1826">                        highValue = value;</span>
<span class="nc" id="L1827">                        goods = g;</span>
                    }
                }
            }
        }
<span class="nc" id="L1832">        return goods;</span>
    }

    /**
     * Get the current incomeBeforeTaxes.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to query.
     * @return The current incomeBeforeTaxes.
     */
    public int getIncomeBeforeTaxes(GoodsType goodsType) {
<span class="nc" id="L1842">        return getMarket().getIncomeBeforeTaxes(goodsType);</span>
    }

    /**
     * Modifies the current incomeBeforeTaxes.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
     * @param amount The new incomeBeforeTaxes.
     */
    public void modifyIncomeBeforeTaxes(GoodsType goodsType, int amount) {
<span class="nc" id="L1852">        getMarket().modifyIncomeBeforeTaxes(goodsType, amount);</span>
<span class="nc" id="L1853">    }</span>

    /**
     * Get the current incomeAfterTaxes.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to query.
     * @return The current incomeAfterTaxes.
     */
    public int getIncomeAfterTaxes(GoodsType goodsType) {
<span class="nc" id="L1862">        return getMarket().getIncomeAfterTaxes(goodsType);</span>
    }

    /**
     * Modifies the current incomeAfterTaxes.
     *
     * @param goodsType The &lt;code&gt;GoodsType&lt;/code&gt; to modify.
     * @param amount The new incomeAfterTaxes.
     */
    public void modifyIncomeAfterTaxes(GoodsType goodsType, int amount) {
<span class="nc" id="L1872">        getMarket().modifyIncomeAfterTaxes(goodsType, amount);</span>
<span class="nc" id="L1873">    }</span>


    //
    // Europe
    //

    /**
     * Gets this players Europe object.
     *
     * @return The Europe object, or null if the player is not
     *     European or indpendent.
     */
    public Europe getEurope() {
<span class="nc" id="L1887">        return europe;</span>
    }

    /**
     * Set the Europe object for a player.
     *
     * @param europe The new &lt;code&gt;Europe&lt;/code&gt; object.
     */
    public void setEurope(Europe europe) {
<span class="nc" id="L1896">        this.europe = europe;</span>
<span class="nc" id="L1897">    }</span>

    /**
     * Checks if this player can move units to Europe.
     *
     * @return True if this player has an instance of &lt;code&gt;Europe&lt;/code&gt;.
     */
    public boolean canMoveToEurope() {
<span class="nc bnc" id="L1905" title="All 2 branches missed.">        return getEurope() != null;</span>
    }

    /**
     * Gets the price for a recruit in Europe.
     *
     * @return The price of a single recruit in {@link Europe}.
     */
    public int getRecruitPrice() {
        // return Math.max(0, (getCrossesRequired() - crosses) * 10);
<span class="nc" id="L1915">        return getEurope().getRecruitPrice();</span>
    }

    /**
     * Gets the price to this player to purchase a unit in Europe.
     *
     * @param au The proposed &lt;code&gt;AbstractUnit&lt;/code&gt;.
     * @return The price for the unit.
     */
    public int getPrice(AbstractUnit au) {
<span class="nc" id="L1925">        final Specification spec = getSpecification();</span>
<span class="nc" id="L1926">        final UnitType unitType = au.getType(spec);</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">        if (!unitType.hasPrice()) return INFINITY;</span>

<span class="nc" id="L1929">        return au.getNumber() * (getEurope().getUnitPrice(unitType)</span>
<span class="nc" id="L1930">            + au.getRole(spec).getRequiredGoodsPrice(getMarket()));</span>
    }

    /**
     * Gets the monarch object this player has.
     *
     * @return The &lt;code&gt;Monarch&lt;/code&gt; object this player has, or null
     *     if there is no monarch.
     */
    public Monarch getMonarch() {
<span class="nc" id="L1940">        return monarch;</span>
    }

    /**
     * Sets the monarch object this player has.
     *
     * @param monarch The new &lt;code&gt;Monarch&lt;/code&gt; object.
     */
    public void setMonarch(Monarch monarch) {
<span class="nc" id="L1949">        this.monarch = monarch;</span>
<span class="nc" id="L1950">    }</span>


    //
    // Units and trade routes
    //

    /**
     * Does this player's units list contain the given unit?
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to test.
     * @return True if the player has the unit.
     */
    public boolean hasUnit(Unit unit) {
<span class="nc" id="L1964">        synchronized (this.units) {</span>
<span class="nc" id="L1965">            return this.units.contains(unit);</span>
        }
    }

    /**
     * Get a copy of the players units.
     *
     * @return A list of the player &lt;code&gt;Unit&lt;/code&gt;s.
     */
    public List&lt;Unit&gt; getUnits() {
<span class="nc" id="L1975">        synchronized (this.units) {</span>
<span class="nc" id="L1976">            return new ArrayList&lt;&gt;(this.units);</span>
        }
    }

    /**
     * Get a player unit by name.
     *
     * @param name The name of the unit.
     * @return The unit with the given name, or null if none found.
     */
    public Unit getUnitByName(String name) {
<span class="nc" id="L1987">        synchronized (this.units) {</span>
<span class="nc" id="L1988">            return find(this.units, u -&gt; name.equals(u.getName()));</span>
        }
    }

    /**
     * Get an iterator containing all the units this player owns.
     *
     * @return An &lt;code&gt;Iterator&lt;/code&gt; over the player &lt;code&gt;Unit&lt;/code&gt;s.
     * @see Unit
     */
    public Iterator&lt;Unit&gt; getUnitIterator() {
<span class="nc" id="L1999">        synchronized (this.units) {</span>
<span class="nc" id="L2000">            return this.units.iterator();</span>
        }
    }

    /**
     * Add a unit to this player.
     *
     * @param newUnit The new &lt;code&gt;Unit&lt;/code&gt; value.
     * @return True if the units container changed.
     */
    public final boolean addUnit(final Unit newUnit) {
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        if (newUnit == null) return false;</span>

        // Make sure the owner of the unit is set first, before adding
        // it to the list
<span class="nc bnc" id="L2015" title="All 2 branches missed.">        if (!this.owns(newUnit)) {</span>
<span class="nc" id="L2016">            throw new IllegalStateException(&quot;Adding another players unit:&quot;</span>
<span class="nc" id="L2017">                + newUnit.getId() + &quot; to &quot; + this);</span>
        }
<span class="nc bnc" id="L2019" title="All 2 branches missed.">        if (hasUnit(newUnit)) return false;</span>

<span class="nc" id="L2021">        synchronized (this.units) {</span>
<span class="nc" id="L2022">            return this.units.add(newUnit);</span>
        }
    }

    /**
     * Remove a unit from this player.
     *
     * @param oldUnit The &lt;code&gt;Unit&lt;/code&gt; to remove.
     * @return True if the units container changed.
     */
    public boolean removeUnit(final Unit oldUnit) {
<span class="nc bnc" id="L2033" title="All 2 branches missed.">        if (oldUnit == null) return false;</span>

<span class="nc" id="L2035">        nextActiveUnitIterator.remove(oldUnit);</span>
<span class="nc" id="L2036">        nextGoingToUnitIterator.remove(oldUnit);</span>

<span class="nc" id="L2038">        synchronized (this.units) {</span>
<span class="nc" id="L2039">            return this.units.remove(oldUnit);</span>
        }
    }

    /**
     * Gets the carrier units that can carry the supplied unit, if one exists.
     *
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to carry.
     * @return A list of suitable carriers.
     */
    public List&lt;Unit&gt; getCarriersForUnit(Unit unit) {
<span class="nc" id="L2050">        return transform(getUnits(), u -&gt; u.couldCarry(unit),</span>
<span class="nc" id="L2051">                         Collectors.toList());</span>
    }

    /**
     * Get the number of units a player has, either land or naval.
     *
     * @param naval If true, count naval units, else count land units.
     * @return The number of units.
     */
    public int getUnitCount(boolean naval) {
<span class="nc bnc" id="L2061" title="All 2 branches missed.">        return count(getUnits(), u -&gt; u.isNaval() == naval);</span>
    }
        
    /**
     * Gets the number of King's land units.
     *
     * @return The number of units
     */
    public int getNumberOfKingLandUnits() {
<span class="nc" id="L2070">        return count(getUnits(),</span>
<span class="nc bnc" id="L2071" title="All 4 branches missed.">                     u -&gt; u.hasAbility(Ability.REF_UNIT) &amp;&amp; !u.isNaval());</span>
    }

    /**
     * Checks if this player has at least one of a given unit type.
     *
     * @param typeId The identifier for the unit type to check.
     * @return True if this player owns at least one of the specified unit type.
     */
    public boolean hasUnitType(String typeId) {
<span class="nc" id="L2081">        return any(getUnits(), u -&gt; typeId.equals(u.getType().getId()));</span>
    }

    /**
     * Gets a new active unit.
     *
     * @return A &lt;code&gt;Unit&lt;/code&gt; that can be made active.
     */
    public Unit getNextActiveUnit() {
<span class="nc" id="L2090">        return nextActiveUnitIterator.next();</span>
    }

    /**
     * Sets a new active unit.
     *
     * @param unit A &lt;code&gt;Unit&lt;/code&gt; to make the next one to be active.
     * @return True if the operation succeeded.
     */
    public boolean setNextActiveUnit(Unit unit) {
<span class="nc" id="L2100">        return nextActiveUnitIterator.setNext(unit);</span>
    }

    /**
     * Checks if a new active unit can be made active.
     *
     * @return True if there is a potential active unit.
     */
    public boolean hasNextActiveUnit() {
<span class="nc" id="L2109">        return nextActiveUnitIterator.hasNext();</span>
    }

    /**
     * Gets a new going-to unit.
     *
     * @return A &lt;code&gt;Unit&lt;/code&gt; that can be made active.
     */
    public Unit getNextGoingToUnit() {
<span class="nc" id="L2118">        return nextGoingToUnitIterator.next();</span>
    }

    /**
     * Sets a new going-to unit.
     *
     * @param unit A &lt;code&gt;Unit&lt;/code&gt; to make the next one to be active.
     * @return True if the operation succeeded.
     */
    public boolean setNextGoingToUnit(Unit unit) {
<span class="nc" id="L2128">        return nextGoingToUnitIterator.setNext(unit);</span>
    }

    /**
     * Checks if there is a unit that has a destination.
     *
     * @return True if there is a unit with a destination.
     */
    public boolean hasNextGoingToUnit() {
<span class="nc" id="L2137">        return nextGoingToUnitIterator.hasNext();</span>
    }

    /**
     * Reset the player iterators ready for a new turn.
     */
    public void resetIterators() {
<span class="nc" id="L2144">        nextActiveUnitIterator.reset();</span>
<span class="nc" id="L2145">        nextGoingToUnitIterator.reset();</span>
<span class="nc" id="L2146">    }</span>

    /**
     * Get the trade routes defined for this player.
     *
     * @return A copy of the list of &lt;code&gt;TradeRoute&lt;/code&gt;s for this player.
     */
    public final List&lt;TradeRoute&gt; getTradeRoutes() {
<span class="nc" id="L2154">        synchronized (this.tradeRoutes) {</span>
<span class="nc" id="L2155">            return new ArrayList&lt;&gt;(this.tradeRoutes);</span>
        }
    }

    /**
     * Get number of trade routes defined for this player.
     *
     * @return The trade route count.
     */
    public final int getTradeRouteCount() {
<span class="nc" id="L2165">        synchronized (this.tradeRoutes) {</span>
<span class="nc" id="L2166">            return this.tradeRoutes.size();</span>
        }
    }

    /**
     * Get the most recently defined trade route.
     *
     * Relies on trade routes *always* being added at the end of the list.
     *
     * @return The most recently defined &lt;code&gt;TradeRoute&lt;/code&gt;.
     */
    public final TradeRoute getNewestTradeRoute() {
<span class="nc" id="L2178">        synchronized (this.tradeRoutes) {</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">            return (this.tradeRoutes.isEmpty()) ? null</span>
<span class="nc" id="L2180">                : this.tradeRoutes.get(this.tradeRoutes.size()-1);</span>
        }
    }

    /**
     * Add a new trade route.
     *
     * @param tradeRoute The &lt;code&gt;TradeRoute&lt;/code&gt; to add.
     */
    public final void addTradeRoute(TradeRoute tradeRoute) {
        String name;
<span class="nc bnc" id="L2191" title="All 4 branches missed.">        if (tradeRoute != null &amp;&amp; (name = tradeRoute.getName()) != null</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">            &amp;&amp; getTradeRouteByName(name, tradeRoute) == null) {</span>
<span class="nc" id="L2193">            synchronized (this.tradeRoutes) {</span>
<span class="nc" id="L2194">                this.tradeRoutes.add(tradeRoute);</span>
            }
        }
<span class="nc" id="L2197">    }</span>
    
    /**
     * Get a trade route by name.
     *
     * @param name The trade route name.
     * @param exclude An optional &lt;code&gt;TradeRoute&lt;/code&gt; to exclude.
     * @return The &lt;code&gt;TradeRoute&lt;/code&gt; found.
     */
    public final TradeRoute getTradeRouteByName(final String name,
        final TradeRoute exclude) {
<span class="nc" id="L2208">        synchronized (this.tradeRoutes) {</span>
<span class="nc" id="L2209">            return find(this.tradeRoutes,</span>
<span class="nc bnc" id="L2210" title="All 4 branches missed.">                t -&gt; t.getName().equals(name) &amp;&amp; t != exclude);</span>
        }
    }

    /**
     * Remove a trade route.
     *
     * @param tradeRoute The &lt;code&gt;TradeRoute&lt;/code&gt; to remove.
     * @return A list of units that were formally assigned to the trade route.
     */
    public final List&lt;Unit&gt; removeTradeRoute(TradeRoute tradeRoute) {
        List&lt;Unit&gt; ret;
<span class="nc" id="L2222">        synchronized (this.tradeRoutes) {</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">            ret = (!this.tradeRoutes.remove(tradeRoute))</span>
<span class="nc" id="L2224">                ? Collections.&lt;Unit&gt;emptyList()</span>
<span class="nc" id="L2225">                : tradeRoute.getAssignedUnits();</span>
        }
<span class="nc bnc" id="L2227" title="All 2 branches missed.">        for (Unit u : ret) u.setTradeRoute(null);</span>
<span class="nc" id="L2228">        return ret;</span>
    }

    /**
     * Clear the trade routes.
     */
    private void clearTradeRoutes() {
<span class="nc" id="L2235">        synchronized (this.tradeRoutes) {</span>
<span class="nc" id="L2236">            this.tradeRoutes.clear();</span>
        }
<span class="nc" id="L2238">    }</span>

    /**
     * Get a unique name for a new trade route.
     *
     * @return A suitable name.
     */
    public String getNameForTradeRoute() {
<span class="nc" id="L2246">        return NameCache.getTradeRouteName(this);</span>
    }

    /**
     * Add an ownable to a caching container.  Not all ownables are
     * cached.
     *
     * @param o The &lt;code&gt;Ownable&lt;/code&gt; to add.
     * @return True if the container changed.
     */
    public boolean addOwnable(Ownable o) {
<span class="nc bnc" id="L2257" title="All 2 branches missed.">        return (o instanceof Settlement) ? addSettlement((Settlement)o)</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            : (o instanceof Unit) ? addUnit((Unit)o)</span>
<span class="nc" id="L2259">            : false;</span>
    }

    /**
     * Remove an ownable from a caching container.  Not all ownables
     * are cached.
     *
     * @param o The &lt;code&gt;Ownable&lt;/code&gt; to remove.
     * @return True if the container changed.
     */
    public boolean removeOwnable(Ownable o) {
<span class="nc bnc" id="L2270" title="All 2 branches missed.">        return (o instanceof Settlement) ? removeSettlement((Settlement)o)</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">            : (o instanceof Unit) ? removeUnit((Unit)o)</span>
<span class="nc" id="L2272">            : false;</span>
    }


    //
    // Settlements
    //

    /**
     * Gets a the settlements this player owns.
     *
     * @return The list of &lt;code&gt;Settlements&lt;/code&gt; this player owns.
     */
    public List&lt;Settlement&gt; getSettlements() {
<span class="nc" id="L2286">        synchronized (this.settlements) {</span>
<span class="nc" id="L2287">            return this.settlements;</span>
        }
    }

    /**
     * Does this player have any settlements at present.
     *
     * @return True if this player has settlements.
     */
    public boolean hasSettlements() {
<span class="nc" id="L2297">        synchronized (this.settlements) {</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">            return !settlements.isEmpty();</span>
        }
    }

    /**
     * Get the count of settlements.
     *
     * @return The number of settlements this player has.
     */
    private int getSettlementCount() {
<span class="nc" id="L2308">        synchronized (this.settlements) {</span>
<span class="nc" id="L2309">            return this.settlements.size();</span>
        }
    }

    /**
     * Get the number of port settlements.
     *
     * @return The number of port settlements this player has.
     */
    public int getNumberOfPorts() {
<span class="nc bnc" id="L2319" title="All 2 branches missed.">        return (!isEuropean()) ? 0</span>
<span class="nc" id="L2320">            : count(getColonies(), Colony::isConnectedPort);</span>
    }

    /**
     * Get the port settlements.
     *
     * @return A list of port &lt;code&gt;Colony&lt;/code&gt;s.
     */
    public List&lt;Colony&gt; getPorts() {
<span class="nc bnc" id="L2329" title="All 2 branches missed.">        return (!isEuropean())</span>
<span class="nc" id="L2330">            ? Collections.&lt;Colony&gt;emptyList()</span>
<span class="nc" id="L2331">            : transform(getColonies(), Colony::isConnectedPort,</span>
<span class="nc" id="L2332">                        Collectors.toList());</span>
    }

    /**
     * Does this player own a given settlement.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to check.
     * @return True if this &lt;code&gt;Player&lt;/code&gt; owns the given
     *     &lt;code&gt;Settlement&lt;/code&gt;.
     */
    public boolean hasSettlement(Settlement settlement) {
<span class="nc" id="L2343">        synchronized (this.settlements) {</span>
<span class="nc" id="L2344">            return this.settlements.contains(settlement);</span>
        }
    }

    /**
     * Adds a given settlement to this player's list of settlements.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to add.
     * @return True if the settlements container changed.
     */
    public boolean addSettlement(Settlement settlement) {
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        if (settlement == null) return false;</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">        if (!owns(settlement)) {</span>
<span class="nc" id="L2357">            throw new IllegalStateException(&quot;Does not own: &quot; + settlement);</span>
        }
<span class="nc bnc" id="L2359" title="All 2 branches missed.">        if (hasSettlement(settlement)) return false;</span>
<span class="nc" id="L2360">        synchronized (this.settlements) {</span>
<span class="nc" id="L2361">            this.settlements.add(settlement);</span>
        }
<span class="nc" id="L2363">        return true;</span>
    }

    /**
     * Removes the given settlement from this player's list of settlements.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to remove.
     * @return True if the settlements container changed.
     */
    public boolean removeSettlement(Settlement settlement) {
<span class="nc" id="L2373">        synchronized (this.settlements) {</span>
<span class="nc" id="L2374">            return this.settlements.remove(settlement);</span>
        }
    }

    /**
     * Gets the sum of units currently working in the colonies of this
     * player.
     *
     * @return The sum of the units currently working in the colonies.
     */
    public int getColoniesPopulation() {
<span class="nc" id="L2385">        return sum(getColonies(), Colony::getUnitCount);</span>
    }

    /**
     * Gets the &lt;code&gt;Colony&lt;/code&gt; with the given name.
     *
     * @param name The name of the &lt;code&gt;Colony&lt;/code&gt;.
     * @return The &lt;code&gt;Colony&lt;/code&gt; with the given name, or null if
     *     not found.
     */
    public Colony getColonyByName(String name) {
<span class="nc" id="L2396">        return find(getColonies(), c -&gt; c.getName().equals(name));</span>
    }

    /**
     * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; with the given name.
     *
     * @param name The name of the &lt;code&gt;IndianSettlement&lt;/code&gt;.
     * @return The &lt;code&gt;IndianSettlement&lt;/code&gt; with the given name,
     *     or null if not found.
     */
    public IndianSettlement getIndianSettlementByName(String name) {
<span class="nc" id="L2407">        return find(getIndianSettlements(), is -&gt; is.getName().equals(name));</span>
    }

    /**
     * Gets a fresh list of all colonies this player owns.
     * It is an error to call this on non-European players.
     *
     * @return A fresh list of the &lt;code&gt;Colony&lt;/code&gt;s this player owns.
     */
    public List&lt;Colony&gt; getColonies() {
<span class="nc" id="L2417">        return transform(getSettlements(), s -&gt; s instanceof Colony,</span>
<span class="nc" id="L2418">                         s -&gt; (Colony)s, Collectors.toList());</span>
    }

    /**
     * Get a sorted list of all colonies this player owns.
     *
     * @param comp A &lt;code&gt;Comparator&lt;/code&gt; to operate on the colony list.
     * @return A fresh list of the &lt;code&gt;Colony&lt;/code&gt;s this player owns.
     */
    public List&lt;Colony&gt; getSortedColonies(Comparator&lt;Colony&gt; comp) {
<span class="nc" id="L2428">        return transformAndSort(getSettlements(), s -&gt; s instanceof Colony,</span>
<span class="nc" id="L2429">                                s -&gt; (Colony)s, comp, Collectors.toList());</span>
    }

    /**
     * Gets a list of all the IndianSettlements this player owns.
     * It is an error to call this on non-native players.
     *
     * @return The indian settlements this player owns.
     */
    public List&lt;IndianSettlement&gt; getIndianSettlements() {
<span class="nc" id="L2439">        return transform(getSettlements(), s -&gt; s instanceof IndianSettlement,</span>
<span class="nc" id="L2440">                         s -&gt; (IndianSettlement)s, Collectors.toList());</span>
    }

    /**
     * Find a &lt;code&gt;Settlement&lt;/code&gt; by name.
     *
     * @param name The name of the &lt;code&gt;Settlement&lt;/code&gt;.
     * @return The &lt;code&gt;Settlement&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if not found.
     **/
    public Settlement getSettlementByName(String name) {
<span class="nc bnc" id="L2450" title="All 2 branches missed.">        return (isIndian()) ? getIndianSettlementByName(name)</span>
<span class="nc" id="L2451">            : getColonyByName(name);</span>
    }

    /**
     * Gets the port closest to Europe owned by this player.
     *
     * @return This players closest port.
     */
    public Settlement getClosestPortForEurope() {
<span class="nc" id="L2460">        final Comparator&lt;Settlement&gt; comp</span>
<span class="nc" id="L2461">            = Comparator.comparingInt(Settlement::getHighSeasCount);</span>
<span class="nc" id="L2462">        return minimize(getSettlements(), comp);</span>
    }


    //
    // Messages and history
    //

    /**
     * Gets all the model messages for this player.
     *
     * @return A copy of the &lt;code&gt;ModelMessage&lt;/code&gt;s for this
     *     &lt;code&gt;Player&lt;/code&gt;.
     */
    public List&lt;ModelMessage&gt; getModelMessages() {
<span class="nc" id="L2477">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2478">            return new ArrayList&lt;&gt;(this.modelMessages);</span>
        }
    }

    /**
     * Gets all new messages for this player.
     *
     * @return all The new &lt;code&gt;ModelMessage&lt;/code&gt;s for this
     *     &lt;code&gt;Player&lt;/code&gt;.
     */
    public List&lt;ModelMessage&gt; getNewModelMessages() {
<span class="nc" id="L2489">        synchronized (this.modelMessages) {</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">            return transform(this.modelMessages, m -&gt; !m.hasBeenDisplayed(),</span>
<span class="nc" id="L2491">                             Collectors.toList());</span>
        }
    }

    /**
     * Adds a message for this player.
     *
     * @param modelMessage The &lt;code&gt;ModelMessage&lt;/code&gt; to add.
     */
    public void addModelMessage(ModelMessage modelMessage) {
<span class="nc" id="L2501">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2502">            this.modelMessages.add(modelMessage);</span>
        }
<span class="nc" id="L2504">    }</span>

    /**
     * Refilters the current model messages, removing the ones that
     * are no longer valid.
     *
     * @param options The &lt;code&gt;OptionGroup&lt;/code&gt; for message display
     *     to enforce.
     */
    public void refilterModelMessages(OptionGroup options) {
<span class="nc" id="L2514">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2515">            Iterator&lt;ModelMessage&gt; mi = this.modelMessages.iterator();</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">            while (mi.hasNext()) {</span>
<span class="nc" id="L2517">                ModelMessage message = mi.next();</span>
<span class="nc" id="L2518">                String id = message.getMessageType().getOptionName();</span>
<span class="nc bnc" id="L2519" title="All 2 branches missed.">                if (!options.getBoolean(id)) mi.remove();</span>
            }
        }
<span class="nc" id="L2522">    }</span>

    /**
     * Removes all undisplayed model messages for this player.
     */
    public void removeDisplayedModelMessages() {
<span class="nc" id="L2528">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2529">            Iterator&lt;ModelMessage&gt; mi = this.modelMessages.iterator();</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">            while (mi.hasNext()) {</span>
<span class="nc" id="L2531">                ModelMessage message = mi.next();</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">                if (message.hasBeenDisplayed()) mi.remove();</span>
            }
        }
<span class="nc" id="L2535">    }</span>

    /**
     * Removes all the model messages for this player.
     */
    public void clearModelMessages() {
<span class="nc" id="L2541">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2542">            this.modelMessages.clear();</span>
        }
<span class="nc" id="L2544">    }</span>

    /**
     * Sometimes an event causes the source (and display) fields in an
     * accumulated model message to become invalid (e.g. Europe disappears
     * on independence).  This routine is for cleaning up such cases.
     *
     * @param source The source field that has become invalid.
     * @param newSource A new source field to replace the old with, or
     *     if null then remove the message
     */
    public void divertModelMessages(FreeColGameObject source,
                                    FreeColGameObject newSource) {
<span class="nc" id="L2557">        synchronized (this.modelMessages) {</span>
<span class="nc" id="L2558">            Iterator&lt;ModelMessage&gt; mi = this.modelMessages.iterator();</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">            while (mi.hasNext()) {</span>
<span class="nc" id="L2560">                ModelMessage message = mi.next();</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">                if (Utils.equals(message.getSourceId(), source.getId())) {</span>
<span class="nc bnc" id="L2562" title="All 2 branches missed.">                    if (newSource == null) {</span>
<span class="nc" id="L2563">                        mi.remove();</span>
<span class="nc" id="L2564">                    } else {</span>
<span class="nc" id="L2565">                        message.divert(newSource);</span>
                    }
                }
            }
        }
<span class="nc" id="L2570">    }</span>

    /**
     * Add the tutorial message for the start of the game.
     */
    public void addStartGameMessage() {
<span class="nc" id="L2576">        Tile tile = getEntryLocation().getTile();</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">        String sailTag = (tile == null) ? &quot;unknown&quot;</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">            : (tile.getX() &lt; tile.getMap().getWidth() / 2) ? &quot;east&quot;</span>
<span class="nc" id="L2579">            : &quot;west&quot;;</span>
<span class="nc" id="L2580">        addModelMessage(new ModelMessage(ModelMessage.MessageType.TUTORIAL,</span>
<span class="nc" id="L2581">                                         &quot;model.player.startGame&quot;, this)</span>
<span class="nc" id="L2582">            .addTagged(&quot;%direction%&quot;, sailTag));</span>
<span class="nc" id="L2583">    }</span>

    /**
     * Get the history events for this player.
     *
     * @return A copy of the &lt;code&gt;HistoryEvent&lt;/code&gt;s for this player.
     */
    public final List&lt;HistoryEvent&gt; getHistory() {
<span class="nc" id="L2591">        synchronized (this.history) {</span>
<span class="nc" id="L2592">            return new ArrayList&lt;&gt;(this.history);</span>
        }
    }

    /**
     * Add a history event to this player.
     *
     * @param event The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
     */
    public void addHistory(HistoryEvent event) {
<span class="nc" id="L2602">        synchronized (this.history) {</span>
<span class="nc" id="L2603">            this.history.add(event);</span>
        }
<span class="nc" id="L2605">    }</span>

    /**
     * Clear the history events.
     */
    private void clearHistory() {
<span class="nc" id="L2611">        synchronized (this.history) {</span>
<span class="nc" id="L2612">            this.history.clear();</span>
        }
<span class="nc" id="L2614">    }</span>


    //
    // The players view of the Map
    //

    /**
     * Gets the default initial location where the units arriving from
     * {@link Europe} appear on the map.
     *
     * @return The entry &lt;code&gt;Location&lt;/code&gt;.
     * @see Unit#getEntryLocation
     */
    public Location getEntryLocation() {
<span class="nc" id="L2629">        return entryLocation;</span>
    }

    /**
     * Sets the default initial location where the units arriving from
     * {@link Europe} appear on the map.
     *
     * @param entryLocation The new entry &lt;code&gt;Location&lt;/code&gt;.
     * @see #getEntryLocation
     */
    public void setEntryLocation(Location entryLocation) {
<span class="nc" id="L2640">        this.entryLocation = entryLocation;</span>
<span class="nc" id="L2641">    }</span>

    /**
     * Get a default tile to display at the start of the player turn should
     * there not be any active units.
     *
     * Favour the first settlement, followed by the entry tile.
     * 
     * @return A suitable &lt;code&gt;Tile&lt;/code&gt;.
     */
    public Tile getFallbackTile() {
<span class="nc" id="L2652">        List&lt;Settlement&gt; settlements = getSettlements();</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">        return (!settlements.isEmpty())</span>
<span class="nc" id="L2654">            ? settlements.get(0).getTile()</span>
<span class="nc" id="L2655">            : getEntryLocation().getTile();</span>
    }

    /**
     * Get the players high seas.
     *
     * @return The &lt;code&gt;HighSeas&lt;/code&gt; for this player.
     */
    public final HighSeas getHighSeas() {
<span class="nc" id="L2664">        return highSeas;</span>
    }

    /**
     * Initialize the highSeas.
     * Needs to be public until the backward compatibility code in
     * FreeColServer is gone.
     */
    public void initializeHighSeas() {
<span class="nc" id="L2673">        Game game = getGame();</span>
<span class="nc" id="L2674">        highSeas = new HighSeas(game);</span>
<span class="nc bnc" id="L2675" title="All 2 branches missed.">        if (europe != null) highSeas.addDestination(europe);</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">        if (game.getMap() != null ) highSeas.addDestination(game.getMap());</span>
<span class="nc" id="L2677">    }</span>

    /**
     * Can this player see a given tile.
     *
     * The tile can be seen if it is in a unit or settlement's line of sight.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if this player can see the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public boolean canSee(Tile tile) {
<span class="nc bnc" id="L2688" title="All 2 branches missed.">        if (tile == null) return false;</span>

        do {
<span class="nc" id="L2691">            synchronized (canSeeLock) {</span>
<span class="nc bnc" id="L2692" title="All 2 branches missed.">                if (canSeeValid) {</span>
<span class="nc" id="L2693">                    return canSeeTiles[tile.getX()][tile.getY()];</span>
                }
            }
<span class="nc bnc" id="L2696" title="All 2 branches missed.">        } while (resetCanSeeTiles());</span>
<span class="nc" id="L2697">        return false;</span>
    }

    /**
     * Forces an update of the &lt;code&gt;canSeeTiles&lt;/code&gt;.
     *
     * This method should be used to invalidate the current
     * &lt;code&gt;canSeeTiles&lt;/code&gt; when something significant changes.
     * The method {@link #resetCanSeeTiles} will be called whenever it
     * is needed.
     *
     * So what is &quot;significant&quot;?  Looking at the makeCanSeeTiles routine
     * suggests the following:
     *
     * - Unit added to map
     * - Unit removed from map
     * - Unit moved on map
     * - Unit type changes (which may change its line-of-sight)
     * - Unit ownership changes
     * - Settlement added to map
     * - Settlement removed from map
     * - Settlement ownership changes
     * - Coronado added (can now see other colonies)
     * - Coronado removed (only in debug mode)
     * - Mission established (if enhanced missionaries enabled)
     * - Mission removed (if enhanced missionaries enabled)
     * - Mission ownership changes (Spanish succession with enhanced
     *                              missionaries enabled)
     * - Map is unexplored (debug mode)
     *
     * Ideally then when any of these events occurs we should call
     * invalidateCanSeeTiles().  However while iCST is quick and
     * cheap, as soon as we then call canSee() the big expensive
     * makeCanSeeTiles will be run.  Often the situation in the server
     * is that several routines with visibility implications will be
     * called in succession.  Usually there, the best solution is to
     * make all the changes and issue the iCST at the end.  So, to
     * make this a bit more visible, routines that change visibility
     * are annotated with a &quot;-vis&quot; comment at both definition and call
     * sites.  Similarly routines that fix up the mess have a &quot;+vis&quot;
     * comment.  Thus it is an error for a -vis to appear without a
     * following +vis (unless the enclosing routine is marked -vis).
     * By convention, we try to avoid cs* routines being -vis.
     */
    public void invalidateCanSeeTiles() {
<span class="nc" id="L2742">        synchronized (canSeeLock) {</span>
<span class="nc" id="L2743">            canSeeValid = false;</span>
        }
<span class="nc" id="L2745">    }</span>

    /**
     * Resets this player's &quot;can see&quot;-tiles.  This is done by setting
     * all the tiles within each {@link Unit} and {@link Settlement}s
     * line of sight visible.  The other tiles are made invisible.
     *
     * Use {@link #invalidateCanSeeTiles} whenever possible.
     *
     * @return True if successful.
     */
    private boolean resetCanSeeTiles() {
<span class="nc" id="L2757">        Map map = getGame().getMap();</span>
<span class="nc bnc" id="L2758" title="All 2 branches missed.">        if (map == null) return false;</span>

<span class="nc" id="L2760">        boolean[][] cST = makeCanSeeTiles(map);</span>
<span class="nc" id="L2761">        synchronized (canSeeLock) {</span>
<span class="nc" id="L2762">            canSeeTiles = cST;</span>
<span class="nc" id="L2763">            canSeeValid = true;</span>
        }
<span class="nc" id="L2765">        return true;</span>
    }

    /**
     * Checks if this player has explored the given tile.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if the &lt;code&gt;Tile&lt;/code&gt; has been explored.
     */
    public boolean hasExplored(Tile tile) {
<span class="nc" id="L2775">        return tile.isExplored();</span>
    }

    /**
     * Builds a canSeeTiles array.
     *
     * Note that tiles must be tested for null as they may be both
     * valid tiles but yet null during a save game load.
     *
     * Note the use of copies of the unit and settlement lists to
     * avoid nasty surprises due to asynchronous disappearance of
     * members of either.  FIXME: see if this can be relaxed.
     *
     * @param map The &lt;code&gt;Map&lt;/code&gt; to use.
     * @return A canSeeTiles array.
     */
    private boolean[][] makeCanSeeTiles(Map map) {
<span class="nc" id="L2792">        final Specification spec = getSpecification();</span>
        // Simple case when there is no fog of war: a tile is
        // visible once it is explored.
<span class="nc bnc" id="L2795" title="All 2 branches missed.">        if (!spec.getBoolean(GameOptions.FOG_OF_WAR)) {</span>
<span class="nc bnc" id="L2796" title="All 2 branches missed.">            boolean[][] cST = (canSeeTiles != null) ? canSeeTiles</span>
<span class="nc" id="L2797">                : new boolean[map.getWidth()][map.getHeight()];</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">            for (Tile t : getGame().getMap().getAllTiles()) {</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">                if (t != null) {</span>
<span class="nc" id="L2800">                    cST[t.getX()][t.getY()] = hasExplored(t);</span>
                }
            }
<span class="nc" id="L2803">            return cST;</span>
        }

        // When there is fog, have to trace all locations where the
        // player has units, settlements, (optionally) missions, and
        // extra visibility.
        // Set the PET for visible tiles to the tile itself.
<span class="nc" id="L2810">        boolean[][] cST = new boolean[map.getWidth()][map.getHeight()];</span>

<span class="nc bnc" id="L2812" title="All 2 branches missed.">        for (Unit unit : getUnits()) {</span>
            // Only consider units directly on the map, not those on a
            // carrier or in Europe.
<span class="nc bnc" id="L2815" title="All 2 branches missed.">            if (!(unit.getLocation() instanceof Tile)) continue;</span>

            // All the units.
<span class="nc bnc" id="L2818" title="All 2 branches missed.">            for (Tile t : ((Tile)unit.getLocation()).getSurroundingTiles(0,</span>
<span class="nc" id="L2819">                    unit.getLineOfSight())) {</span>
<span class="nc" id="L2820">                cST[t.getX()][t.getY()] = true;</span>
<span class="nc" id="L2821">                t.seeTile(this);</span>
            }
        }
        // All the settlements.
<span class="nc bnc" id="L2825" title="All 2 branches missed.">        for (Settlement settlement : getSettlements()) {</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">            for (Tile t : settlement.getTile().getSurroundingTiles(0,</span>
<span class="nc" id="L2827">                    settlement.getLineOfSight())) {</span>
<span class="nc" id="L2828">                cST[t.getX()][t.getY()] = true;</span>
<span class="nc" id="L2829">                t.seeTile(this);</span>
            }
        }
        // All missions if using enhanced missionaries.
<span class="nc bnc" id="L2833" title="All 2 branches missed.">        if (isEuropean()</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">                &amp;&amp; spec.getBoolean(GameOptions.ENHANCED_MISSIONARIES)) {</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">            for (Player other : getGame().getLiveNativePlayers(this)) {</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">                for (IndianSettlement is : other.getIndianSettlements()) {</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">                    if (!is.hasMissionary(this)) {</span>
<span class="nc" id="L2838">                        continue;</span>
                    }
<span class="nc bnc" id="L2840" title="All 2 branches missed.">                    for (Tile t : is.getTile().getSurroundingTiles(0,</span>
<span class="nc" id="L2841">                            is.getLineOfSight())) {</span>
<span class="nc" id="L2842">                        cST[t.getX()][t.getY()] = true;</span>
<span class="nc" id="L2843">                        t.seeTile(this);</span>
                    }
                }
            }
        }
        // All other European settlements if can see all colonies.
<span class="nc bnc" id="L2849" title="All 4 branches missed.">        if (isEuropean() &amp;&amp; hasAbility(Ability.SEE_ALL_COLONIES)) {</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">            for (Colony c : getGame().getAllColonies(this)) {</span>
<span class="nc bnc" id="L2851" title="All 2 branches missed.">                for (Tile t : c.getTile().getSurroundingTiles(0,</span>
<span class="nc" id="L2852">                        c.getLineOfSight())) {</span>
<span class="nc" id="L2853">                    cST[t.getX()][t.getY()] = true;</span>
<span class="nc" id="L2854">                    t.seeTile(this);</span>
                }
            }
        }
<span class="nc" id="L2858">        return cST;</span>
    }


    //
    // Foreign relations
    //

    /**
     * Gets the hostility this player has against the given player.
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt;.
     * @return An object representing the tension level.
     */
    public Tension getTension(Player player) {
<span class="nc bnc" id="L2873" title="All 2 branches missed.">        if (player == null) throw new IllegalStateException(&quot;Null player.&quot;);</span>
<span class="nc" id="L2874">        Tension newTension = tension.get(player);</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        if (newTension == null) {</span>
<span class="nc" id="L2876">            newTension = new Tension(Tension.TENSION_MIN);</span>
<span class="nc" id="L2877">            tension.put(player, newTension);</span>
        }
<span class="nc" id="L2879">        return newTension;</span>
    }

    /**
     * Sets the tension with respect to a given player.
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt;.
     * @param newTension The new &lt;code&gt;Tension&lt;/code&gt;.
     */
    public void setTension(Player player, Tension newTension) {
<span class="nc bnc" id="L2889" title="All 4 branches missed.">        if (player == this || player == null) return;</span>
<span class="nc" id="L2890">        tension.put(player, newTension);</span>
<span class="nc" id="L2891">    }</span>

    /**
     * Removes all tension with respect to a given player.  Used when a
     * player leaves the game.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to remove tension for.
     */
    public void removeTension(Player player) {
<span class="nc bnc" id="L2900" title="All 2 branches missed.">        if (player != null) tension.remove(player);</span>
<span class="nc" id="L2901">    }</span>

    /**
     * Does this player ban missions from another player?
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt; to test.
     * @return True if the given player is banned.
     */
    public boolean missionsBanned(Player player) {
<span class="nc bnc" id="L2910" title="All 4 branches missed.">        return bannedMissions != null &amp;&amp; bannedMissions.contains(player);</span>
    }

    /**
     * Ban a player from establishing missions to this player.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to ban.
     */
    public void addMissionBan(Player player) {
<span class="nc bnc" id="L2919" title="All 2 branches missed.">        if (bannedMissions == null) bannedMissions = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2920">        bannedMissions.add(player);</span>
<span class="nc" id="L2921">    }</span>

    /**
     * Remove a mission ban from a player.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to clear the ban for.
     */
    public void removeMissionBan(Player player) {
<span class="nc bnc" id="L2929" title="All 2 branches missed.">        if (bannedMissions != null) bannedMissions.remove(player);</span>
<span class="nc" id="L2930">    }</span>

    /**
     * Gets the stance towards a given player.
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt; to check.
     * @return The stance.
     */
    public Stance getStance(Player player) {
<span class="nc bnc" id="L2939" title="All 4 branches missed.">        return (player == null || stance.get(player.getId()) == null)</span>
<span class="nc" id="L2940">            ? Stance.UNCONTACTED</span>
<span class="nc" id="L2941">            : stance.get(player.getId());</span>
    }

    /**
     * Sets the stance towards a given player.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to set the
     *     &lt;code&gt;Stance&lt;/code&gt; for.
     * @param newStance The new &lt;code&gt;Stance&lt;/code&gt;.
     * @return True if the stance change was valid.
     * @throws IllegalArgumentException if player is null or this.
     */
    public boolean setStance(Player player, Stance newStance) {
<span class="nc bnc" id="L2954" title="All 2 branches missed.">        if (player == null) {</span>
<span class="nc" id="L2955">            throw new IllegalArgumentException(&quot;Player must not be 'null'.&quot;);</span>
        }
<span class="nc bnc" id="L2957" title="All 2 branches missed.">        if (player == this) {</span>
<span class="nc" id="L2958">            throw new IllegalArgumentException(&quot;Cannot set the stance towards ourselves.&quot;);</span>
        }
<span class="nc bnc" id="L2960" title="All 2 branches missed.">        if (newStance == null) {</span>
<span class="nc" id="L2961">            stance.remove(player.getId());</span>
<span class="nc" id="L2962">            return true;</span>
        }
<span class="nc" id="L2964">        Stance oldStance = stance.get(player.getId());</span>
<span class="nc bnc" id="L2965" title="All 2 branches missed.">        if (newStance == oldStance) return true;</span>

<span class="nc" id="L2967">        boolean valid = true;;</span>
<span class="nc bnc" id="L2968" title="All 4 branches missed.">        if ((newStance == Stance.CEASE_FIRE &amp;&amp; oldStance != Stance.WAR)</span>
<span class="nc bnc" id="L2969" title="All 2 branches missed.">            || newStance == Stance.UNCONTACTED) {</span>
<span class="nc" id="L2970">            valid = false;</span>
        }
<span class="nc" id="L2972">        stance.put(player.getId(), newStance);</span>
<span class="nc" id="L2973">        return valid;</span>
    }

    /**
     * Is this player at war with the specified one.
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt; to check.
     * @return True if the players are at war.
     */
    public boolean atWarWith(Player player) {
<span class="nc bnc" id="L2983" title="All 2 branches missed.">        return getStance(player) == Stance.WAR;</span>
    }

    /**
     * Checks whether this player is at war with any other player.
     *
     * @return True if this player is at war with any other.
     */
    public boolean isAtWar() {
<span class="nc" id="L2992">        return any(getGame().getLivePlayers(null), p -&gt; atWarWith(p));</span>
    }

    /**
     * Has this player met contacted the given one?
     *
     * @param player The other &lt;code&gt;Player&lt;/code&gt; to check.
     * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted the other.
     */
    public boolean hasContacted(Player player) {
<span class="nc bnc" id="L3002" title="All 2 branches missed.">        return getStance(player) != Stance.UNCONTACTED;</span>
    }

    /**
     * Has this player has met with any Europeans at all?
     *
     * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted any Europeans.
     */
    public boolean hasContactedEuropeans() {
<span class="nc" id="L3011">        return any(getGame().getLiveEuropeanPlayers(this),</span>
<span class="nc" id="L3012">            p -&gt; hasContacted(p));</span>
    }

    /**
     * Has this player met any natives at all?
     *
     * @return True if this &lt;code&gt;Player&lt;/code&gt; has contacted any natives.
     */
    public boolean hasContactedIndians() {
<span class="nc" id="L3021">        return any(getGame().getLiveNativePlayers(this),</span>
<span class="nc" id="L3022">            p -&gt; hasContacted(p));</span>
    }

    /**
     * Set this player as having made initial contact with another player.
     * Always start with PEACE, which can go downhill fast.
     *
     * @param player1 One &lt;code&gt;Player&lt;/code&gt; to check.
     * @param player2 The other &lt;code&gt;Player&lt;/code&gt; to check.
     */
    public static void makeContact(Player player1, Player player2) {
<span class="nc" id="L3033">        player1.stance.put(player2.getId(), Stance.PEACE);</span>
<span class="nc" id="L3034">        player2.stance.put(player1.getId(), Stance.PEACE);</span>
<span class="nc" id="L3035">        player1.setTension(player2, new Tension(Tension.TENSION_MIN));</span>
<span class="nc" id="L3036">        player2.setTension(player1, new Tension(Tension.TENSION_MIN));</span>
<span class="nc" id="L3037">    }</span>

    /**
     * Gets the price of the given land.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to get the price for.
     * @return The price of the land if it is for sale, zero if it is
     *     already ours, unclaimed or unwanted, negative if it is not
     *     for sale.
     */
    public int getLandPrice(Tile tile) {
<span class="nc" id="L3048">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3049">        Player nationOwner = tile.getOwner();</span>

<span class="nc bnc" id="L3051" title="All 4 branches missed.">        if (nationOwner == null || nationOwner == this) {</span>
<span class="nc" id="L3052">            return 0; // Freely available</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">        } else if (tile.hasSettlement()) {</span>
<span class="nc" id="L3054">            return -1; // Not for sale</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">        } else if (nationOwner.isEuropean()) {</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">            if (tile.getOwningSettlement() != null</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">                &amp;&amp; tile.getOwningSettlement().getOwner() == nationOwner) {</span>
<span class="nc" id="L3058">                return -1; // Nailed down by a European colony</span>
            } else {
<span class="nc" id="L3060">                return 0; // Claim abandoned or only by tile improvement</span>
            }
        } // Else, native ownership
<span class="nc" id="L3063">        int price = spec.getInteger(GameOptions.LAND_PRICE_FACTOR)</span>
<span class="nc" id="L3064">            * sum(spec.getGoodsTypeList(),</span>
                // Only consider specific food types, not the aggregation.
<span class="nc bnc" id="L3066" title="All 2 branches missed.">                gt -&gt; gt != spec.getPrimaryFoodType(),</span>
<span class="nc" id="L3067">                gt -&gt; tile.getPotentialProduction(gt, null))</span>
<span class="nc" id="L3068">            + 100;</span>
<span class="nc" id="L3069">        return (int)applyModifiers(price, getGame().getTurn(),</span>
<span class="nc" id="L3070">                                   Modifier.LAND_PAYMENT_MODIFIER);</span>
    }

    /**
     * Access the nation cache.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to get the summary for.
     * @return The current &lt;code&gt;NationSummary&lt;/code&gt; for a player.
     */
    public NationSummary getNationSummary(Player player) {
<span class="nc" id="L3080">        return nationCache.get(player);</span>
    }

    /**
     * Update the nation cache.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to get the summary for.
     * @param ns The new &lt;code&gt;NationSummary&lt;/code&gt; for the player.
     */
    public void putNationSummary(Player player, NationSummary ns) {
<span class="nc" id="L3090">        nationCache.put(player, ns);</span>
<span class="nc" id="L3091">    }</span>

    /**
     * Clear the nation cache.
     */
    public void clearNationCache() {
<span class="nc" id="L3097">        nationCache.clear();</span>
<span class="nc" id="L3098">    }</span>

    /**
     * Get the strength ratio of this player with respect to another.
     *
     * This relies on an up-to-date nation cache value for the target
     * player.
     *
     * @param other The other &lt;code&gt;Player&lt;/code&gt;.
     * @param naval If true, get the naval strength, else the land strength.
     * @return The strength ratio (strength/sum(strengths)), or negative
     *     on error.
     */
    public double getStrengthRatio(Player other, boolean naval) {
<span class="nc" id="L3112">        NationSummary ns = getNationSummary(other);</span>
<span class="nc bnc" id="L3113" title="All 2 branches missed.">        if (ns == null) return -1.0;</span>
<span class="nc" id="L3114">        int strength = calculateStrength(naval);</span>
<span class="nc" id="L3115">        return strengthRatio((double)strength, ns.getMilitaryStrength());</span>
    }

    /**
     * Abstraction of the strength ratio calculation.
     *
     * @param ours The player strength.
     * @param theirs The enemy strength.
     * @return The resulting strength ratio.
     */
    public static double strengthRatio(double ours, double theirs) {
<span class="nc bnc" id="L3126" title="All 2 branches missed.">        return (ours == 0.0) ? 0.0 : ours / (ours + theirs);</span>
    }

    //
    // Claiming of tiles
    //

    /**
     * A variety of reasons why a tile can not be claimed, either
     * to found a settlement or just to be used by one, including the
     * double negative NONE == &quot;no reason&quot; case.
     */
<span class="nc" id="L3138">    public static enum NoClaimReason implements Named {</span>
<span class="nc" id="L3139">        NONE,            // Actually, tile can be claimed</span>
<span class="nc" id="L3140">        TERRAIN,         // Not on settleable terrain</span>
<span class="nc" id="L3141">        RUMOUR,          // Europeans can not claim tiles with LCR</span>
<span class="nc" id="L3142">        WATER,           // Natives do not claim water</span>
<span class="nc" id="L3143">        OCCUPIED,        // Hostile unit present.</span>
<span class="nc" id="L3144">        SETTLEMENT,      // Settlement present</span>
<span class="nc" id="L3145">        WORKED,          // One of our settlements is working this tile</span>
<span class="nc" id="L3146">        EUROPEANS,       // Owned by Europeans and not for sale</span>
<span class="nc" id="L3147">        NATIVES;         // Owned by natives and they want payment for it</span>

        /**
         * Get a message key describing this reason.
         *
         * @return A message key.
         */
        private String getKey() {
<span class="nc" id="L3155">            return &quot;noClaimReason.&quot; + getEnumKey(this);</span>
        }

        public String getDescriptionKey() {
<span class="nc" id="L3159">            return Messages.descriptionKey(&quot;model.&quot; + getKey());</span>
        }
        
        // Implement Named

        /**
         * {@inheritDoc}
         */
        public String getNameKey() {
<span class="nc" id="L3168">            return Messages.nameKey(&quot;model.&quot; + getKey());</span>
        }        
    };

    /**
     * Can a tile be owned by this player?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return True if the tile can be owned by this player.
     */
    public boolean canOwnTile(Tile tile) {
<span class="nc bnc" id="L3179" title="All 2 branches missed.">        return canOwnTileReason(tile) == NoClaimReason.NONE;</span>
    }

    /**
     * Can a tile be owned by this player?
     * This is a test of basic practicality and does not consider
     * the full complexity of tile ownership issues.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return The reason why/not the tile can be owned by this player.
     */
    private NoClaimReason canOwnTileReason(Tile tile) {
<span class="nc" id="L3191">        return (any(tile.getUnitList(),</span>
<span class="nc bnc" id="L3192" title="All 6 branches missed.">                u -&gt; u.getOwner() != this &amp;&amp; u.isOffensiveUnit()))</span>
<span class="nc" id="L3193">            ? NoClaimReason.OCCUPIED // The tile is held against us</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">            : (isEuropean())</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">            ? ((tile.hasLostCityRumour())</span>
<span class="nc" id="L3196">                ? NoClaimReason.RUMOUR</span>
<span class="nc" id="L3197">                : NoClaimReason.NONE)</span>
<span class="nc bnc" id="L3198" title="All 2 branches missed.">            : ((tile.isLand())</span>
<span class="nc" id="L3199">                ? NoClaimReason.NONE</span>
<span class="nc" id="L3200">                : NoClaimReason.WATER);</span>
    }

    /**
     * Checks if a tile can be claimed for use by a settlement.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
     * @return True if the tile can be claimed to found a settlement.
     */
    public boolean canClaimForSettlement(Tile tile) {
<span class="nc bnc" id="L3210" title="All 2 branches missed.">        return canClaimForSettlementReason(tile) == NoClaimReason.NONE;</span>
    }

    /**
     * The test for whether a tile can be freely claimed by a player
     * settlement (freely implies not by purchase or stealing).  The
     * rule for the center tile is different, see below.
     *
     * The tile must be ownable by this player, settlement-free, and
     * either not currently owned, owned by this player and not by
     * another settlement that is using the tile, or owned by someone
     * else who does not want anything for it.  Got that?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
     * @return The reason why/not the tile can be claimed.
     */
    public NoClaimReason canClaimForSettlementReason(Tile tile) {
        int price;
<span class="nc" id="L3228">        NoClaimReason reason = canOwnTileReason(tile);</span>
<span class="nc bnc" id="L3229" title="All 2 branches missed.">        return (reason != NoClaimReason.NONE) ? reason</span>
<span class="nc bnc" id="L3230" title="All 2 branches missed.">            : (tile.hasSettlement()) ? NoClaimReason.SETTLEMENT</span>
<span class="nc bnc" id="L3231" title="All 2 branches missed.">            : (tile.getOwner() == null) ? NoClaimReason.NONE</span>
<span class="nc bnc" id="L3232" title="All 4 branches missed.">            : (tile.getOwner() == this) ? ((tile.isInUse())</span>
<span class="nc" id="L3233">                                           ? NoClaimReason.WORKED</span>
<span class="nc" id="L3234">                                           : NoClaimReason.NONE)</span>
<span class="nc bnc" id="L3235" title="All 2 branches missed.">            : ((price = getLandPrice(tile)) &lt; 0) ? NoClaimReason.EUROPEANS</span>
<span class="nc bnc" id="L3236" title="All 2 branches missed.">            : (price &gt; 0) ? NoClaimReason.NATIVES</span>
<span class="nc" id="L3237">            : NoClaimReason.NONE;</span>
    }

    /**
     * Can a tile be claimed to found a settlement on?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
     * @return True if the tile can be claimed to found a settlement.
     */
    public boolean canClaimToFoundSettlement(Tile tile) {
<span class="nc bnc" id="L3247" title="All 2 branches missed.">        return canClaimToFoundSettlementReason(tile) == NoClaimReason.NONE;</span>
    }

    /**
     * Can a tile be claimed to found a settlement on?
     * Almost the same as canClaimForSettlement but there is an extra
     * requirement that the tile be of a settleable type, and some
     * relaxations that allow free center tile acquisition
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
     * @return The reason why/not the tile can be claimed.
     */
    public NoClaimReason canClaimToFoundSettlementReason(Tile tile) {
        NoClaimReason reason;
<span class="nc bnc" id="L3261" title="All 2 branches missed.">        return (!tile.getType().canSettle()) ? NoClaimReason.TERRAIN</span>
<span class="nc bnc" id="L3262" title="All 2 branches missed.">            : ((reason = canClaimForSettlementReason(tile))</span>
<span class="nc" id="L3263">               != NoClaimReason.NATIVES) ? reason</span>
<span class="nc bnc" id="L3264" title="All 2 branches missed.">            : (!tile.getAdjacentColonies().isEmpty()) ? NoClaimReason.SETTLEMENT</span>
<span class="nc bnc" id="L3265" title="All 2 branches missed.">            : (canClaimFreeCenterTile(tile)) ? NoClaimReason.NONE</span>
<span class="nc" id="L3266">            : NoClaimReason.NATIVES;</span>
    }

    /**
     * Is this tile claimable for a colony center tile under the
     * special provisions of the model.option.buildOnNativeLand option.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to try to claim.
     * @return True if the tile can be claimed.
     */
    private boolean canClaimFreeCenterTile(Tile tile) {
<span class="nc" id="L3277">        final Specification spec = getGame().getSpecification();</span>
<span class="nc" id="L3278">        String build = spec.getString(GameOptions.BUILD_ON_NATIVE_LAND);</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">        return isEuropean()</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">            &amp;&amp; tile.getOwner() != null</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">            &amp;&amp; tile.getOwner().isIndian()</span>
<span class="nc bnc" id="L3282" title="All 2 branches missed.">            &amp;&amp; (GameOptions.BUILD_ON_NATIVE_LAND_ALWAYS.equals(build)</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">                || (GameOptions.BUILD_ON_NATIVE_LAND_FIRST.equals(build)</span>
<span class="nc bnc" id="L3284" title="All 2 branches missed.">                    &amp;&amp; hasZeroSettlements())</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">                || (GameOptions.BUILD_ON_NATIVE_LAND_FIRST_AND_UNCONTACTED.equals(build)</span>
<span class="nc bnc" id="L3286" title="All 2 branches missed.">                    &amp;&amp; hasZeroSettlements()</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">                    &amp;&amp; (tile.getOwner() == null</span>
<span class="nc bnc" id="L3288" title="All 2 branches missed.">                        || tile.getOwner().getStance(this)</span>
<span class="nc" id="L3289">                        == Stance.UNCONTACTED)));</span>
    }

    /**
     * The second and third cases of buildOnNative land need to test
     * if the player has no settlements yet.  We can not just check
     * that the number of settlement is zero because by the time the
     * settlement is being placed and we are collecting the tiles to
     * claim, the settlement already exists and thus there will
     * already be one settlement--- so we have to check if that one
     * settlement is on the map yet.
     *
     * @return True if the player has no settlements (on the map) yet.
     */
    private boolean hasZeroSettlements() {
<span class="nc" id="L3304">        List&lt;Settlement&gt; settlements = getSettlements();</span>
<span class="nc bnc" id="L3305" title="All 2 branches missed.">        return settlements.isEmpty()</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">            || (settlements.size() == 1</span>
<span class="nc bnc" id="L3307" title="All 2 branches missed.">                &amp;&amp; settlements.get(0).getTile().getSettlement() == null);</span>
    }

    /**
     * Can the ownership of this tile be claimed for the purposes of
     * making an improvement.  Quick test that does not handle the
     * curly case of tile transfer between colonies, or guarantee
     * success (natives may want to be paid), but just that success is
     * possible.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to consider.
     *
     * @return True if the tile ownership can be claimed.
     */
    public boolean canClaimForImprovement(Tile tile) {
<span class="nc" id="L3322">        Player owner = tile.getOwner();</span>
<span class="nc bnc" id="L3323" title="All 6 branches missed.">        return owner == null || owner == this || getLandPrice(tile) == 0;</span>
    }

    /**
     * Can a tile be acquired from its owners and used for an improvement?
     * Slightly weakens canClaimForImprovement to allow for purchase
     * and/or stealing.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return True if the tile ownership can be claimed.
     */
    public boolean canAcquireForImprovement(Tile tile) {
<span class="nc bnc" id="L3335" title="All 4 branches missed.">        return canClaimForImprovement(tile)</span>
<span class="nc" id="L3336">            || getLandPrice(tile) &gt; 0;</span>
    }

    /**
     * Gets the list of tiles that might be claimable by a settlement.
     * We can not do a simple iteration of the rings because this
     * allows settlements to claim tiles across unclaimable gaps
     * (e.g. Aztecs owning tiles on nearby islands).  So we have to
     * only allow tiles that are adjacent to a known connected tile.
     *
     * @param centerTile The intended settlement center &lt;code&gt;Tile&lt;/code&gt;.
     * @param radius The radius of the settlement.
     * @return A list of potentially claimable tiles.
     */
    public List&lt;Tile&gt; getClaimableTiles(Tile centerTile, int radius) {
<span class="nc" id="L3351">        List&lt;Tile&gt; tiles = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3352">        List&lt;Tile&gt; layer = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3353" title="All 2 branches missed.">        if (canClaimToFoundSettlement(centerTile)) {</span>
<span class="nc" id="L3354">            layer.add(centerTile);</span>
<span class="nc bnc" id="L3355" title="All 2 branches missed.">            for (int r = 1; r &lt;= radius; r++) {</span>
<span class="nc" id="L3356">                List&lt;Tile&gt; lastLayer = new ArrayList&lt;&gt;(layer);</span>
<span class="nc" id="L3357">                tiles.addAll(layer);</span>
<span class="nc" id="L3358">                layer.clear();</span>
<span class="nc bnc" id="L3359" title="All 2 branches missed.">                for (Tile have : lastLayer) {</span>
<span class="nc bnc" id="L3360" title="All 2 branches missed.">                    for (Tile next : have.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L3361" title="All 2 branches missed.">                        if (!tiles.contains(next)</span>
<span class="nc bnc" id="L3362" title="All 2 branches missed.">                            &amp;&amp; canClaimForSettlement(next)) {</span>
<span class="nc" id="L3363">                            layer.add(next);</span>
                        }
                    }
                }
            }
<span class="nc" id="L3368">            tiles.addAll(layer);</span>
        }
<span class="nc" id="L3370">        return tiles;</span>
    }


    //
    // AI helpers for evaluation settlement locations
    //

    /**
     * Not currently in use.  Leave here for now, it might yet be revived.
     *
     * Calculates the value of an outpost-type colony at this tile.
     * An &quot;outpost&quot; is supposed to be a colony containing one worker, exporting
     * its whole production to europe. The value of such colony is the maximum
     * amount of money it can make in one turn, assuming sale of its secondary
     * goods plus farmed goods from one of the surrounding tiles.
     *
     * @return The value of a future colony located on this tile. This value is
     *         used by the AI when deciding where to build a new colony.
    public int getOutpostValue(Tile t) {
        Market market = getMarket();
        if (canClaimToFoundSettlement(t)) {
            boolean nearbyTileIsOcean = false;
            float advantages = 1f;
            int value = 0;
            for (Tile tile : t.getSurroundingTiles(1)) {
                if (tile.getColony() != null) {
                    // can't build next to colony
                    return 0;
                } else if (tile.hasSettlement()) {
                    // can build next to an indian settlement, but shouldn't
                    SettlementType type = tile.getSettlement().getType();
                    if (type.getClaimableRadius() &gt; 1) {
                        // really shouldn't build next to cities
                        advantages *= 0.25f;
                    } else {
                        advantages *= 0.5f;
                    }
                } else {
                    if (tile.isHighSeasConnected()) {
                        nearbyTileIsOcean = true;
                    }
                    if (tile.getType()!=null) {
                        for (AbstractGoods production : tile.getType().getProduction()) {
                            GoodsType type = production.getType();
                            int potential = market.getSalePrice(type, tile.getPotentialProduction(type, null));
                            if (tile.getOwner() != null &amp;&amp;
                                !this.owns(tile)) {
                                // tile is already owned by someone (and not by us!)
                                if (tile.getOwner().isEuropean()) {
                                    continue;
                                } else {
                                    potential /= 2;
                                }
                            }
                            value = Math.max(value, potential);
                        }
                    }
                }
            }

            // add good that could be produced by a colony on this tile
            int bestValue = 0;
            for (ProductionType productionType : t.getType()
                     .getAvailableProductionTypes(true)) {
                if (productionType.getOutputs() != null) {
                    int newValue = 0;
                    for (AbstractGoods output: productionType.getOutputs()) {
                        newValue += market.getSalePrice(output.getType(),
                                                        t.getPotentialProduction(output.getType(), null));
                    }
                    if (newValue &gt; bestValue) {
                        bestValue = newValue;
                    }
                }
            }
            value += bestValue;
            if (nearbyTileIsOcean) {
                return Math.max(0, (int) (value * advantages));
            }
        }
        return 0;
    }
    */

    /**
     * Gets a list of values for building a &lt;code&gt;Colony&lt;/code&gt; on the
     * given tile for each &lt;code&gt;ColonyValueCategory&lt;/code&gt;.
     *
     * FIXME: tune magic numbers and expose more to the spec.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt;
     * @return A list of values.
     */
    public List&lt;Double&gt; getAllColonyValues(Tile tile) {
        // Want a few settlements before taking risks
<span class="nc" id="L3466">        final int LOW_SETTLEMENT_NUMBER = 3;</span>

        // Would like a caravel to reach high seas in 3 moves
<span class="nc" id="L3469">        final int LONG_PATH_TILES = 12;</span>

        // Applied once
<span class="nc" id="L3472">        final double MOD_HAS_RESOURCE           = 0.75;</span>
<span class="nc" id="L3473">        final double MOD_FOOD_LOW               = 0.75;</span>
<span class="nc" id="L3474">        final double MOD_INITIAL_FOOD           = 2.0;</span>
<span class="nc" id="L3475">        final double MOD_STEAL                  = 0.5;</span>
<span class="nc" id="L3476">        final double MOD_INLAND                 = 0.5;</span>

        // Applied per surrounding tile
<span class="nc" id="L3479">        final double MOD_OWNED_EUROPEAN         = 0.67;</span>
<span class="nc" id="L3480">        final double MOD_OWNED_NATIVE           = 0.8;</span>

        // Applied per goods production, per surrounding tile
<span class="nc" id="L3483">        final double MOD_HIGH_PRODUCTION        = 1.2;</span>
<span class="nc" id="L3484">        final double MOD_GOOD_PRODUCTION        = 1.1;</span>

        // Applied per occurrence (own colony only one-time), range-dependent.
<span class="nc" id="L3487">        final int DISTANCE_MAX = 5;</span>
<span class="nc" id="L3488">        final double[] MOD_OWN_COLONY     = {0.0, 0.0, 0.5, 1.50, 1.25};</span>
<span class="nc" id="L3489">        final double[] MOD_ENEMY_COLONY   = {0.0, 0.0, 0.4, 0.50, 0.70};</span>
<span class="nc" id="L3490">        final double[] MOD_NEUTRAL_COLONY = {0.0, 0.0, 0.7, 0.80, 1.00};</span>
<span class="nc" id="L3491">        final double[] MOD_ENEMY_UNIT     = {0.4, 0.5, 0.6, 0.75, 0.90};</span>

        // Goods production in excess of this on a tile counts as good/high
<span class="nc" id="L3494">        final int GOOD_PRODUCTION = 4;</span>
<span class="nc" id="L3495">        final int HIGH_PRODUCTION = 8;</span>

        // Counting &quot;high&quot; production as 2, &quot;good&quot; production as 1
        // overall food production is considered low/very low if less than...
<span class="nc" id="L3499">        final int FOOD_LOW = 4;</span>
<span class="nc" id="L3500">        final int FOOD_VERY_LOW = 1;</span>

        // Multiplicative modifiers, to be applied to value later
<span class="nc" id="L3503">        List&lt;Double&gt; values = toList(map(ColonyValueCategory.values(),</span>
<span class="nc" id="L3504">                                         v -&gt; 1.0));</span>

        // Penalize certain problems more in the initial colonies.
<span class="nc" id="L3507">        double development = Math.min(LOW_SETTLEMENT_NUMBER,</span>
<span class="nc" id="L3508">                                      getSettlementCount())</span>
<span class="nc" id="L3509">                / (double)LOW_SETTLEMENT_NUMBER;</span>
<span class="nc" id="L3510">        int portCount = getNumberOfPorts();</span>

<span class="nc bnc" id="L3512" title="All 4 branches missed.">        if (tile.isPolar() &amp;&amp; getSettlementCount() &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3513">            values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3514">                       NoValueType.POLAR.getDouble());</span>
<span class="nc" id="L3515">            return values;</span>
        }

<span class="nc bnc" id="L3518" title="All 7 branches missed.">        switch (canClaimToFoundSettlementReason(tile)) {</span>
        case NONE:
<span class="nc" id="L3520">            break;</span>
        case TERRAIN: case WATER:
<span class="nc" id="L3522">            values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3523">                       NoValueType.TERRAIN.getDouble());</span>
<span class="nc" id="L3524">            return values;</span>
        case RUMOUR:
<span class="nc bnc" id="L3526" title="All 2 branches missed.">            if (!hasSettlements()) {</span>
<span class="nc" id="L3527">                values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3528">                           NoValueType.RUMOUR.getDouble());</span>
<span class="nc" id="L3529">                return values;</span>
            }
<span class="nc" id="L3531">            values.set(ColonyValueCategory.A_TILE.ordinal(),</span>
<span class="nc" id="L3532">                       development);</span>
<span class="nc" id="L3533">            break;</span>
        case OCCUPIED: // transient we hope
<span class="nc" id="L3535">            values.set(ColonyValueCategory.A_TILE.ordinal(),</span>
<span class="nc" id="L3536">                       MOD_ENEMY_UNIT[0]);</span>
<span class="nc" id="L3537">            break;</span>
        case SETTLEMENT: case WORKED: case EUROPEANS:
<span class="nc" id="L3539">            values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3540">                       NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3541">            return values;</span>
        case NATIVES: // If we have no ports, we are desperate enough to steal
<span class="nc bnc" id="L3543" title="All 2 branches missed.">            if (tile.getOwningSettlement() != null</span>
<span class="nc bnc" id="L3544" title="All 2 branches missed.">                &amp;&amp; tile.getOwningSettlement().getTile() != null</span>
<span class="nc bnc" id="L3545" title="All 2 branches missed.">                &amp;&amp; tile.getOwningSettlement().getTile().isAdjacent(tile)) {</span>
<span class="nc" id="L3546">                values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3547">                           NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3548">                return values;</span>
            }
<span class="nc" id="L3550">            int price = getLandPrice(tile);</span>
<span class="nc bnc" id="L3551" title="All 6 branches missed.">            if (price &gt; 0 &amp;&amp; !checkGold(price) &amp;&amp; portCount &gt; 0) {</span>
<span class="nc" id="L3552">                values.set(ColonyValueCategory.A_TILE.ordinal(),</span>
<span class="nc" id="L3553">                           MOD_STEAL);</span>
            }
<span class="nc" id="L3555">            break;</span>
        default:
<span class="nc" id="L3557">            values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3558">                       NoValueType.BOGUS.getDouble());</span>
<span class="nc" id="L3559">            return values;</span>
        }

        // Set up maps for all foods and building materials
<span class="nc" id="L3563">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3564">        TypeCountMap&lt;GoodsType&gt; production = new TypeCountMap&lt;&gt;();</span>

        // Initialize tile value with food production.
<span class="nc" id="L3567">        final GoodsType foodType = spec.getPrimaryFoodType();</span>
<span class="nc" id="L3568">        final AbstractGoods bestFood = tile.getBestFoodProduction();</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">        int initialFood = (bestFood == null) ? 0 : bestFood.getAmount();</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">        if (initialFood &lt;= FOOD_VERY_LOW) {</span>
<span class="nc" id="L3571">            values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3572">                       NoValueType.FOOD.getDouble());</span>
<span class="nc" id="L3573">            return values;</span>
        }
<span class="nc" id="L3575">        production.incrementCount(foodType, initialFood);</span>
<span class="nc" id="L3576">        values.set(ColonyValueCategory.A_PROD.ordinal(),</span>
<span class="nc" id="L3577">                   (double)initialFood * foodType.getProductionWeight());</span>

        // Penalty if there is no direct connection to the high seas, or
        // if it is too long.
<span class="nc" id="L3581">        int tilesToHighSeas = tile.getHighSeasCount();</span>
<span class="nc bnc" id="L3582" title="All 2 branches missed.">        if (tilesToHighSeas &lt; 0) {</span>
<span class="nc bnc" id="L3583" title="All 2 branches missed.">            if (portCount &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3584">                values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3585">                           NoValueType.INLAND.getDouble());</span>
<span class="nc" id="L3586">                return values;</span>
            }
<span class="nc" id="L3588">            values.set(ColonyValueCategory.A_EUROPE.ordinal(),</span>
<span class="nc" id="L3589">                       MOD_INLAND);</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">        } else if (tilesToHighSeas &gt;= LONG_PATH_TILES) {</span>
            // Normally penalize in direct proportion to length of
            // path, but scale up to penalizing by the square of the
            // path length for the first colony.
<span class="nc" id="L3594">            double trip = (double)LONG_PATH_TILES / tilesToHighSeas;</span>
<span class="nc" id="L3595">            values.set(ColonyValueCategory.A_EUROPE.ordinal(),</span>
<span class="nc" id="L3596">                       Math.pow(trip, 2.0 - development));</span>
<span class="nc" id="L3597">        } else {</span>
<span class="nc" id="L3598">            values.set(ColonyValueCategory.A_EUROPE.ordinal(),</span>
<span class="nc" id="L3599">                       1.0 + 0.25 * ((double)LONG_PATH_TILES</span>
<span class="nc" id="L3600">                           / (LONG_PATH_TILES - tilesToHighSeas)));</span>
        }

        // Penalty for building on a resource tile, because production
        // can not be improved much.
<span class="nc" id="L3605">        values.set(ColonyValueCategory.A_RESOURCE.ordinal(),</span>
<span class="nc bnc" id="L3606" title="All 2 branches missed.">                   (tile.hasResource()) ? MOD_HAS_RESOURCE : 1.0);</span>

<span class="nc" id="L3608">        Set&lt;GoodsType&gt; highProduction = new HashSet&lt;&gt;();</span>
<span class="nc" id="L3609">        Set&lt;GoodsType&gt; goodProduction = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3610" title="All 2 branches missed.">        for (Tile t : tile.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L3611" title="All 2 branches missed.">            if (t.getType() == null) continue; // Unexplored!?!</span>
<span class="nc bnc" id="L3612" title="All 2 branches missed.">            if (t.getSettlement() != null) { // Should not happen, tested above</span>
<span class="nc" id="L3613">                values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3614">                           NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3615">                return values;</span>
            }

<span class="nc" id="L3618">            double pf = 1.0;</span>
<span class="nc bnc" id="L3619" title="All 4 branches missed.">            if (t.getOwner() != null &amp;&amp; !this.owns(t)) {</span>
<span class="nc bnc" id="L3620" title="All 2 branches missed.">                if (t.getOwner().isEuropean()) {</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">                    if (portCount &lt; LOW_SETTLEMENT_NUMBER) {</span>
<span class="nc" id="L3622">                        values.set(ColonyValueCategory.A_OVERRIDE.ordinal(),</span>
<span class="nc" id="L3623">                                   NoValueType.SETTLED.getDouble());</span>
<span class="nc" id="L3624">                        return values;</span>
                    }
<span class="nc" id="L3626">                    values.set(ColonyValueCategory.A_ADJACENT.ordinal(),</span>
<span class="nc" id="L3627">                               values.get(ColonyValueCategory.A_ADJACENT.ordinal())</span>
<span class="nc" id="L3628">                               * MOD_OWNED_EUROPEAN * development);</span>
<span class="nc" id="L3629">                    continue; // Always ignore production from this tile</span>
                } else {
<span class="nc" id="L3631">                    pf = MOD_OWNED_NATIVE;</span>
<span class="nc bnc" id="L3632" title="All 2 branches missed.">                    if (portCount &gt; 0) pf *= development;</span>
                }
            }

            // Count production
<span class="nc bnc" id="L3637" title="All 2 branches missed.">            for (AbstractGoods ag : t.getSortedPotential()) {</span>
<span class="nc" id="L3638">                GoodsType type = ag.getType();</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">                if (type.isFoodType()) type = foodType;</span>
<span class="nc" id="L3640">                int amount = ag.getAmount();</span>
<span class="nc bnc" id="L3641" title="All 2 branches missed.">                if (!t.isLand()) amount *= development;</span>
<span class="nc" id="L3642">                values.set(ColonyValueCategory.A_PROD.ordinal(),</span>
<span class="nc" id="L3643">                           values.get(ColonyValueCategory.A_PROD.ordinal())</span>
<span class="nc" id="L3644">                           + amount * type.getProductionWeight() * pf);</span>
<span class="nc" id="L3645">                production.incrementCount(type, amount);</span>
                // A few tiles with distinct high production are
                // better than many tiles with low production.
<span class="nc bnc" id="L3648" title="All 2 branches missed.">                if (amount &gt; HIGH_PRODUCTION) {</span>
<span class="nc" id="L3649">                    highProduction.add(type);</span>
<span class="nc bnc" id="L3650" title="All 2 branches missed.">                } else if (amount &gt; GOOD_PRODUCTION) {</span>
<span class="nc" id="L3651">                    goodProduction.add(type);</span>
                }
            }

<span class="nc bnc" id="L3655" title="All 2 branches missed.">            for (Unit u : t.getUnitList()) {</span>
<span class="nc bnc" id="L3656" title="All 4 branches missed.">                if (!owns(u) &amp;&amp; u.isOffensiveUnit()</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">                    &amp;&amp; atWarWith(u.getOwner())) {</span>
<span class="nc" id="L3658">                    values.set(ColonyValueCategory.A_ADJACENT.ordinal(),</span>
<span class="nc" id="L3659">                        values.get(ColonyValueCategory.A_ADJACENT.ordinal())</span>
<span class="nc" id="L3660">                        * MOD_ENEMY_UNIT[1]);</span>
                }
            }
        }

<span class="nc bnc" id="L3665" title="All 2 branches missed.">        for (GoodsType g : highProduction) {</span>
<span class="nc" id="L3666">            values.set(ColonyValueCategory.A_LEVEL.ordinal(),</span>
<span class="nc" id="L3667">                       values.get(ColonyValueCategory.A_LEVEL.ordinal())</span>
<span class="nc" id="L3668">                       * MOD_HIGH_PRODUCTION);</span>
<span class="nc" id="L3669">            goodProduction.remove(g);</span>
        }
<span class="nc bnc" id="L3671" title="All 2 branches missed.">        if (!goodProduction.isEmpty()) {</span>
<span class="nc" id="L3672">            values.set(ColonyValueCategory.A_LEVEL.ordinal(),</span>
<span class="nc" id="L3673">                       values.get(ColonyValueCategory.A_LEVEL.ordinal())</span>
<span class="nc" id="L3674">                       * MOD_GOOD_PRODUCTION * goodProduction.size());</span>
        }

        // Apply modifiers for other settlements and units at distance.
<span class="nc" id="L3678">        boolean supportingColony = false;</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">        for (int radius = 2; radius &lt; DISTANCE_MAX; radius++) {</span>
<span class="nc bnc" id="L3680" title="All 2 branches missed.">            for (Tile t : getGame().getMap().getCircleTiles(tile, false,</span>
<span class="nc" id="L3681">                                                            radius)) {</span>
<span class="nc" id="L3682">                Settlement settlement = t.getSettlement();</span>
<span class="nc bnc" id="L3683" title="All 2 branches missed.">                if (settlement != null) {</span>
<span class="nc bnc" id="L3684" title="All 2 branches missed.">                    if (owns(settlement)) {</span>
<span class="nc bnc" id="L3685" title="All 2 branches missed.">                        if (!supportingColony) {</span>
<span class="nc" id="L3686">                            supportingColony = true;</span>
<span class="nc" id="L3687">                            values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3688">                                values.get(ColonyValueCategory.A_NEARBY.ordinal())</span>
<span class="nc" id="L3689">                                * MOD_OWN_COLONY[radius]);</span>
                        }
<span class="nc bnc" id="L3691" title="All 2 branches missed.">                    } else if (atWarWith(settlement.getOwner())) {</span>
<span class="nc" id="L3692">                        values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3693">                            values.get(ColonyValueCategory.A_NEARBY.ordinal())</span>
<span class="nc" id="L3694">                            * MOD_ENEMY_COLONY[radius]);</span>
<span class="nc" id="L3695">                    } else {</span>
<span class="nc" id="L3696">                        values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3697">                            values.get(ColonyValueCategory.A_NEARBY.ordinal())</span>
<span class="nc" id="L3698">                            * MOD_NEUTRAL_COLONY[radius]);</span>
                    }
                }

<span class="nc bnc" id="L3702" title="All 2 branches missed.">                for (Unit u : t.getUnitList()) {</span>
<span class="nc bnc" id="L3703" title="All 4 branches missed.">                    if (!owns(u) &amp;&amp; u.isOffensiveUnit()</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">                        &amp;&amp; atWarWith(u.getOwner())) {</span>
<span class="nc" id="L3705">                        values.set(ColonyValueCategory.A_NEARBY.ordinal(),</span>
<span class="nc" id="L3706">                            values.get(ColonyValueCategory.A_NEARBY.ordinal())</span>
<span class="nc" id="L3707">                            * MOD_ENEMY_UNIT[radius]);</span>
                    }
                }
            }
        }

        // Check availability of key goods
<span class="nc bnc" id="L3714" title="All 2 branches missed.">        if (production.getCount(foodType) &lt; FOOD_LOW) {</span>
<span class="nc" id="L3715">            values.set(ColonyValueCategory.A_FOOD.ordinal(),</span>
<span class="nc" id="L3716">                       values.get(ColonyValueCategory.A_FOOD.ordinal())</span>
<span class="nc" id="L3717">                       * MOD_FOOD_LOW);</span>
        }
<span class="nc" id="L3719">        int a = ColonyValueCategory.A_GOODS.ordinal() - 1;</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">        for (GoodsType type : production.keySet()) {</span>
<span class="nc" id="L3721">            Integer amount = production.getCount(type);</span>
<span class="nc" id="L3722">            double threshold = type.getLowProductionThreshold();</span>
<span class="nc bnc" id="L3723" title="All 2 branches missed.">            if (threshold &gt; 0.0) {</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">                if (++a == values.size()) values.add(1.0);</span>
<span class="nc bnc" id="L3725" title="All 2 branches missed.">                if (amount &lt; threshold) {</span>
<span class="nc" id="L3726">                    double fraction = (double)amount / threshold;</span>
<span class="nc" id="L3727">                    double zeroValue = type.getZeroProductionFactor();</span>
<span class="nc" id="L3728">                    values.set(a, (1.0 - fraction) * zeroValue + fraction);</span>
                }
            }
        }

<span class="nc" id="L3733">        return values;</span>
    }

    /**
     * Gets the value for building a &lt;code&gt;Colony&lt;/code&gt; on
     * the given tile.
     *
     * FIXME: tune magic numbers and expose more to the spec.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt;
     * @return A score for the tile.
     */
    public int getColonyValue(Tile tile) {
<span class="nc" id="L3746">        List&lt;Double&gt; values = getAllColonyValues(tile);</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">        if (values.get(0) &lt; 0.0) return (int)Math.round(values.get(0));</span>
<span class="nc" id="L3748">        double v = 1.0;</span>
<span class="nc bnc" id="L3749" title="All 2 branches missed.">        for (Double d : values) v *= d;</span>
<span class="nc" id="L3750">        return (int)Math.round(v);</span>
    }


    //
    // Miscellaneous
    //

    /**
     * Standardized log of an instance of cheating by this player.
     *
     * @param what A description of the cheating.
     */
    public void logCheat(String what) {
<span class="nc" id="L3764">        logger.finest(&quot;CHEAT: &quot; + getGame().getTurn().getNumber()</span>
<span class="nc" id="L3765">            + &quot; &quot; + lastPart(getNationId(), &quot;.&quot;)</span>
<span class="nc" id="L3766">            + &quot; &quot; + what);</span>
<span class="nc" id="L3767">    }</span>

    /**
     * Gets the maximum food consumption of any unit types
     * available to this player.
     *
     * @return A maximum food consumption value.
     */
    public int getMaximumFoodConsumption() {
<span class="nc bnc" id="L3776" title="All 2 branches missed.">        if (maximumFoodConsumption &lt; 0) {</span>
<span class="nc" id="L3777">            final Specification spec = getSpecification();</span>
<span class="nc" id="L3778">            maximumFoodConsumption = max(spec.getUnitTypeList(),</span>
<span class="nc" id="L3779">                ut -&gt; ut.isAvailableTo(this),</span>
<span class="nc" id="L3780">                ut -&gt; sum(spec.getFoodGoodsTypeList(),</span>
<span class="nc" id="L3781">                    ft -&gt; ut.getConsumptionOf(ft)));</span>
        }
<span class="nc" id="L3783">        return maximumFoodConsumption;</span>
    }

    /**
     * Does this player own something?
     *
     * @param ownable The &lt;code&gt;Ownable&lt;/code&gt; to check.
     * @return True if the &lt;code&gt;Ownable&lt;/code&gt; is ours.
     */
    public boolean owns(Ownable ownable) {
<span class="nc bnc" id="L3793" title="All 2 branches missed.">        return (ownable == null) ? false : this.equals(ownable.getOwner());</span>
    }

    /**
     * Get a &lt;code&gt;FreeColGameObject&lt;/code&gt; with the specified
     * identifier and class, owned by this player.
     *
     * Used mainly in message decoding.
     *
     * @param &lt;T&gt; The actual return type.
     * @param id The object identifier.
     * @param returnClass The expected class of the object.
     * @return The game object, or null if not found.
     * @throws IllegalStateException on failure to validate the object
     *     in any way.
     */
    public &lt;T extends FreeColGameObject&gt; T getOurFreeColGameObject(String id,
        Class&lt;T&gt; returnClass) throws IllegalStateException {
<span class="nc" id="L3811">        T t = getGame().getFreeColGameObject(id, returnClass);</span>
<span class="nc bnc" id="L3812" title="All 2 branches missed.">        if (t == null) {</span>
<span class="nc" id="L3813">            throw new IllegalStateException(&quot;Not a &quot; + returnClass.getName()</span>
<span class="nc" id="L3814">                + &quot;: &quot; + id);</span>
<span class="nc bnc" id="L3815" title="All 2 branches missed.">        } else if (t instanceof Ownable) {</span>
<span class="nc bnc" id="L3816" title="All 2 branches missed.">            if (!owns((Ownable)t)) {</span>
<span class="nc" id="L3817">                throw new IllegalStateException(returnClass.getName()</span>
<span class="nc" id="L3818">                    + &quot; not owned by &quot; + getId() + &quot;: &quot; + id);</span>
            }
        } else {
<span class="nc" id="L3821">            throw new IllegalStateException(&quot;Not ownable: &quot; + id);</span>
        }
<span class="nc" id="L3823">        return t;</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="nc" id="L3834">        int result = super.checkIntegrity(fix);</span>
<span class="nc bnc" id="L3835" title="All 2 branches missed.">        for (Unit unit : getUnits()) {</span>
<span class="nc bnc" id="L3836" title="All 2 branches missed.">            if (unit.getOwner() == null) {</span>
<span class="nc bnc" id="L3837" title="All 2 branches missed.">                if (fix) {</span>
<span class="nc" id="L3838">                    unit.setOwner(this);</span>
<span class="nc" id="L3839">                    logger.warning(&quot;Fixed missing owner for: &quot; + unit.getId());</span>
<span class="nc" id="L3840">                    result = 0;</span>
<span class="nc" id="L3841">                } else {</span>
<span class="nc" id="L3842">                    logger.warning(&quot;Missing owner for: &quot; + unit.getId());</span>
<span class="nc" id="L3843">                    result = -1;</span>
                }
            }
<span class="nc" id="L3846">            result = Math.min(result, unit.checkIntegrity(fix));</span>
        }
<span class="nc bnc" id="L3848" title="All 2 branches missed.">        if (monarch != null) {</span>
<span class="nc" id="L3849">            result = Math.min(result, monarch.checkIntegrity(fix));</span>
        }
<span class="nc" id="L3851">        return result;</span>
    }


    //
    // Override FreeColObject
    //

    /**
     * {@inheritDoc}
     */
    @Override
    public final FeatureContainer getFeatureContainer() {
<span class="nc" id="L3864">        return featureContainer;</span>
    }


    // Serialization

    private static final String ADMIN_TAG = &quot;admin&quot;;
    private static final String AI_TAG = &quot;ai&quot;;
    private static final String ATTACKED_BY_PRIVATEERS_TAG = &quot;attackedByPrivateers&quot;;
    private static final String BANKRUPT_TAG = &quot;bankrupt&quot;;
    private static final String BAN_MISSIONS_TAG = &quot;banMissions&quot;;
    private static final String CURRENT_FATHER_TAG = &quot;currentFather&quot;;
    private static final String DEAD_TAG = &quot;dead&quot;;
    private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;
    private static final String FOUNDING_FATHERS_TAG = &quot;foundingFathers&quot;;
    private static final String GOLD_TAG = &quot;gold&quot;;
    private static final String IMMIGRATION_TAG = &quot;immigration&quot;;
    private static final String IMMIGRATION_REQUIRED_TAG = &quot;immigrationRequired&quot;;
    private static final String LIBERTY_TAG = &quot;liberty&quot;;
    private static final String INDEPENDENT_NATION_NAME_TAG = &quot;independentNationName&quot;;
    private static final String INTERVENTION_BELLS_TAG = &quot;interventionBells&quot;;
    private static final String NATION_ID_TAG = &quot;nationId&quot;;
    private static final String NATION_TYPE_TAG = &quot;nationType&quot;;
    private static final String NEW_LAND_NAME_TAG = &quot;newLandName&quot;;
    private static final String OFFERED_FATHERS_TAG = &quot;offeredFathers&quot;;
    private static final String OLD_SOL_TAG = &quot;oldSoL&quot;;
    private static final String PLAYER_TAG = &quot;player&quot;;
    private static final String PLAYER_TYPE_TAG = &quot;playerType&quot;;
    private static final String READY_TAG = &quot;ready&quot;;
    private static final String SCORE_TAG = &quot;score&quot;;
    private static final String STANCE_TAG = &quot;stance&quot;;
    private static final String TAX_TAG = &quot;tax&quot;;
    private static final String TENSION_TAG = &quot;tension&quot;;
    private static final String USERNAME_TAG = &quot;username&quot;;
    // @compat 0.10.7
<span class="nc" id="L3899">    private static final String OLD_NATION_ID_TAG = &quot;nationID&quot;;</span>
    // end @compat


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L3908">        super.writeAttributes(xw);</span>

<span class="nc" id="L3910">        xw.writeAttribute(USERNAME_TAG, name);</span>

<span class="nc" id="L3912">        xw.writeAttribute(NATION_ID_TAG, nationId);</span>

<span class="nc bnc" id="L3914" title="All 2 branches missed.">        if (nationType != null) {</span>
<span class="nc" id="L3915">            xw.writeAttribute(NATION_TYPE_TAG, nationType);</span>
        }

<span class="nc" id="L3918">        xw.writeAttribute(ADMIN_TAG, admin);</span>

<span class="nc" id="L3920">        xw.writeAttribute(READY_TAG, ready);</span>

<span class="nc" id="L3922">        xw.writeAttribute(DEAD_TAG, dead);</span>

<span class="nc" id="L3924">        xw.writeAttribute(PLAYER_TYPE_TAG, playerType);</span>

<span class="nc" id="L3926">        xw.writeAttribute(AI_TAG, ai);</span>

<span class="nc bnc" id="L3928" title="All 2 branches missed.">        if (xw.validFor(this)) {</span>

<span class="nc" id="L3930">            xw.writeAttribute(BANKRUPT_TAG, bankrupt);</span>

<span class="nc" id="L3932">            xw.writeAttribute(TAX_TAG, tax);</span>

<span class="nc" id="L3934">            xw.writeAttribute(GOLD_TAG, gold);</span>

<span class="nc" id="L3936">            xw.writeAttribute(IMMIGRATION_TAG, immigration);</span>

<span class="nc" id="L3938">            xw.writeAttribute(LIBERTY_TAG, liberty);</span>

<span class="nc" id="L3940">            xw.writeAttribute(INTERVENTION_BELLS_TAG, interventionBells);</span>

<span class="nc bnc" id="L3942" title="All 2 branches missed.">            if (currentFather != null) {</span>
<span class="nc" id="L3943">                xw.writeAttribute(CURRENT_FATHER_TAG, currentFather);</span>
            }

<span class="nc" id="L3946">            xw.writeAttribute(IMMIGRATION_REQUIRED_TAG, immigrationRequired);</span>

<span class="nc" id="L3948">            xw.writeAttribute(ATTACKED_BY_PRIVATEERS_TAG, attackedByPrivateers);</span>

<span class="nc" id="L3950">            xw.writeAttribute(OLD_SOL_TAG, oldSoL);</span>

<span class="nc" id="L3952">            xw.writeAttribute(SCORE_TAG, score);</span>
        }

<span class="nc bnc" id="L3955" title="All 2 branches missed.">        if (newLandName != null) {</span>
<span class="nc" id="L3956">            xw.writeAttribute(NEW_LAND_NAME_TAG, newLandName);</span>
        }

<span class="nc bnc" id="L3959" title="All 2 branches missed.">        if (independentNationName != null) {</span>
<span class="nc" id="L3960">            xw.writeAttribute(INDEPENDENT_NATION_NAME_TAG, independentNationName);</span>
        }

<span class="nc bnc" id="L3963" title="All 2 branches missed.">        if (entryLocation != null) {</span>
<span class="nc" id="L3964">            xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
        }
<span class="nc" id="L3966">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="nc" id="L3973">        super.writeChildren(xw);</span>

<span class="nc bnc" id="L3975" title="All 2 branches missed.">        if (market != null) market.toXML(xw);</span>

<span class="nc bnc" id="L3977" title="All 2 branches missed.">        if (xw.validFor(this)) {</span>

<span class="nc bnc" id="L3979" title="All 2 branches missed.">            for (Ability ability : getSortedAbilities()) {</span>
<span class="nc bnc" id="L3980" title="All 2 branches missed.">                if (ability.isIndependent()) ability.toXML(xw);</span>
            }

<span class="nc" id="L3983">            Turn turn = getGame().getTurn();</span>
<span class="nc bnc" id="L3984" title="All 2 branches missed.">            for (Modifier modifier : getSortedModifiers()) {</span>
<span class="nc bnc" id="L3985" title="All 4 branches missed.">                if (modifier.isTemporary() &amp;&amp; !modifier.isOutOfDate(turn)) {</span>
<span class="nc" id="L3986">                    modifier.toXML(xw);</span>
                }
            }

<span class="nc bnc" id="L3990" title="All 2 branches missed.">            for (Player p : toSortedList(tension.keySet())) {</span>
<span class="nc" id="L3991">                xw.writeStartElement(TENSION_TAG);</span>

<span class="nc" id="L3993">                xw.writeAttribute(PLAYER_TAG, p);</span>

<span class="nc" id="L3995">                xw.writeAttribute(VALUE_TAG, tension.get(p).getValue());</span>

<span class="nc" id="L3997">                xw.writeEndElement();</span>
            }
            
<span class="nc bnc" id="L4000" title="All 2 branches missed.">            if (bannedMissions != null) {</span>
<span class="nc bnc" id="L4001" title="All 2 branches missed.">                for (Player p : toSortedList(bannedMissions)) {</span>
<span class="nc" id="L4002">                    xw.writeStartElement(BAN_MISSIONS_TAG);</span>

<span class="nc" id="L4004">                    xw.writeAttribute(PLAYER_TAG, p.getId());</span>

<span class="nc" id="L4006">                    xw.writeEndElement();</span>
                }
            }

<span class="nc bnc" id="L4010" title="All 2 branches missed.">            for (Entry&lt;String, Stance&gt; e : mapEntriesByKey(stance)) {</span>
<span class="nc" id="L4011">                Stance s = e.getValue();</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">                if (s == Stance.UNCONTACTED) continue;</span>

<span class="nc" id="L4014">                xw.writeStartElement(STANCE_TAG);</span>

<span class="nc" id="L4016">                xw.writeAttribute(PLAYER_TAG, e.getKey());</span>

<span class="nc" id="L4018">                xw.writeAttribute(VALUE_TAG, s);</span>

<span class="nc" id="L4020">                xw.writeEndElement();</span>
            }

<span class="nc bnc" id="L4023" title="All 2 branches missed.">            for (HistoryEvent event : getHistory()) { // Already in order</span>
<span class="nc" id="L4024">                event.toXML(xw);</span>
            }

<span class="nc bnc" id="L4027" title="All 2 branches missed.">            for (TradeRoute route : toSortedList(getTradeRoutes())) {</span>
<span class="nc" id="L4028">                route.toXML(xw);</span>
            }

<span class="nc bnc" id="L4031" title="All 2 branches missed.">            if (highSeas != null) highSeas.toXML(xw);</span>
            
<span class="nc" id="L4033">            xw.writeToListElement(FOUNDING_FATHERS_TAG, foundingFathers);</span>

<span class="nc" id="L4035">            xw.writeToListElement(OFFERED_FATHERS_TAG, offeredFathers);</span>

<span class="nc bnc" id="L4037" title="All 2 branches missed.">            if (europe != null) europe.toXML(xw);</span>

<span class="nc bnc" id="L4039" title="All 2 branches missed.">            if (monarch != null) monarch.toXML(xw);</span>

<span class="nc bnc" id="L4041" title="All 2 branches missed.">            for (ModelMessage m : getModelMessages()) m.toXML(xw);</span>

<span class="nc bnc" id="L4043" title="All 2 branches missed.">            if (lastSales != null) {</span>
<span class="nc bnc" id="L4044" title="All 2 branches missed.">                for (LastSale ls : toSortedList(lastSales.values())) {</span>
<span class="nc" id="L4045">                    ls.toXML(xw);</span>
                }
            }

<span class="nc" id="L4049">        } else {</span>
<span class="nc" id="L4050">            Player player = xw.getClientPlayer();</span>
<span class="nc" id="L4051">            Tension t = getTension(player);</span>
<span class="nc bnc" id="L4052" title="All 2 branches missed.">            if (t != null) {</span>
<span class="nc" id="L4053">                xw.writeStartElement(TENSION_TAG);</span>

<span class="nc" id="L4055">                xw.writeAttribute(PLAYER_TAG, player);</span>

<span class="nc" id="L4057">                xw.writeAttribute(VALUE_TAG, t.getValue());</span>

<span class="nc" id="L4059">                xw.writeEndElement();</span>
            }

<span class="nc bnc" id="L4062" title="All 2 branches missed.">            if (missionsBanned(player)) {</span>
<span class="nc" id="L4063">                xw.writeStartElement(BAN_MISSIONS_TAG);</span>

<span class="nc" id="L4065">                xw.writeAttribute(PLAYER_TAG, player.getId());</span>

<span class="nc" id="L4067">                xw.writeEndElement();</span>
            }

<span class="nc" id="L4070">            Stance s = getStance(player);</span>
<span class="nc bnc" id="L4071" title="All 4 branches missed.">            if (s != null &amp;&amp; s != Stance.UNCONTACTED) {</span>
<span class="nc" id="L4072">                xw.writeStartElement(STANCE_TAG);</span>
                
<span class="nc" id="L4074">                xw.writeAttribute(PLAYER_TAG, player);</span>

<span class="nc" id="L4076">                xw.writeAttribute(VALUE_TAG, s);</span>

<span class="nc" id="L4078">                xw.writeEndElement();</span>
            }
        }
<span class="nc" id="L4081">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L4088">        super.readAttributes(xr);</span>

<span class="nc" id="L4090">        final Specification spec = getSpecification();</span>
<span class="nc" id="L4091">        final Game game = getGame();</span>

<span class="nc" id="L4093">        name = xr.getAttribute(USERNAME_TAG, (String)null);</span>
        // @compat 0.11.5
<span class="nc bnc" id="L4095" title="All 2 branches missed.">        if (name.startsWith(&quot;model.nation.&quot;)) name = Messages.message(name);</span>
        // end @compat 0.11.5

<span class="nc" id="L4098">        nationId = xr.getAttribute(NATION_ID_TAG,</span>
            // @compat 0.10.7
<span class="nc" id="L4100">            xr.getAttribute(OLD_NATION_ID_TAG,</span>
            // end @compat 0.10.7
<span class="nc" id="L4102">                (String)null));</span>

<span class="nc bnc" id="L4104" title="All 2 branches missed.">        if (isUnknownEnemy()) {</span>
<span class="nc" id="L4105">            nationType = null;</span>
<span class="nc" id="L4106">        } else {</span>
<span class="nc" id="L4107">            nationType = xr.getType(spec, NATION_TYPE_TAG,</span>
<span class="nc" id="L4108">                                    NationType.class, (NationType)null);</span>
        }

<span class="nc" id="L4111">        admin = xr.getAttribute(ADMIN_TAG, false);</span>

<span class="nc" id="L4113">        gold = xr.getAttribute(GOLD_TAG, 0);</span>

<span class="nc" id="L4115">        immigration = xr.getAttribute(IMMIGRATION_TAG, 0);</span>

<span class="nc" id="L4117">        liberty = xr.getAttribute(LIBERTY_TAG, 0);</span>

<span class="nc" id="L4119">        interventionBells = xr.getAttribute(INTERVENTION_BELLS_TAG, 0);</span>

<span class="nc" id="L4121">        oldSoL = xr.getAttribute(OLD_SOL_TAG, 0);</span>

<span class="nc" id="L4123">        score = xr.getAttribute(SCORE_TAG, 0);</span>

<span class="nc" id="L4125">        ready = xr.getAttribute(READY_TAG, false);</span>

<span class="nc" id="L4127">        ai = xr.getAttribute(AI_TAG, false);</span>

<span class="nc" id="L4129">        dead = xr.getAttribute(DEAD_TAG, false);</span>

<span class="nc" id="L4131">        bankrupt = xr.getAttribute(BANKRUPT_TAG, false);</span>

<span class="nc" id="L4133">        tax = xr.getAttribute(TAX_TAG, 0);</span>

<span class="nc" id="L4135">        changePlayerType(xr.getAttribute(PLAYER_TYPE_TAG,</span>
<span class="nc" id="L4136">                                         PlayerType.class, (PlayerType)null));</span>

<span class="nc" id="L4138">        currentFather = xr.getType(spec, CURRENT_FATHER_TAG,</span>
<span class="nc" id="L4139">                                   FoundingFather.class, (FoundingFather)null);</span>

<span class="nc" id="L4141">        immigrationRequired = xr.getAttribute(IMMIGRATION_REQUIRED_TAG, 12);</span>

<span class="nc" id="L4143">        newLandName = xr.getAttribute(NEW_LAND_NAME_TAG, (String)null);</span>

<span class="nc" id="L4145">        independentNationName = xr.getAttribute(INDEPENDENT_NATION_NAME_TAG,</span>
<span class="nc" id="L4146">                                                (String)null);</span>

<span class="nc" id="L4148">        attackedByPrivateers = xr.getAttribute(ATTACKED_BY_PRIVATEERS_TAG,</span>
<span class="nc" id="L4149">                                               false);</span>

<span class="nc" id="L4151">        entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG,</span>
<span class="nc" id="L4152">                                                true);</span>
<span class="nc" id="L4153">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // Clear containers.
<span class="nc" id="L4161">        tension.clear();</span>
<span class="nc bnc" id="L4162" title="All 2 branches missed.">        if (bannedMissions != null) bannedMissions.clear();</span>
<span class="nc" id="L4163">        stance.clear();</span>
<span class="nc" id="L4164">        foundingFathers.clear();</span>
<span class="nc" id="L4165">        offeredFathers.clear();</span>
<span class="nc" id="L4166">        europe = null;</span>
<span class="nc" id="L4167">        monarch = null;</span>
<span class="nc" id="L4168">        clearHistory();</span>
<span class="nc" id="L4169">        clearTradeRoutes();</span>
<span class="nc" id="L4170">        clearModelMessages();</span>
<span class="nc" id="L4171">        lastSales = null;</span>
<span class="nc" id="L4172">        highSeas = null;</span>
<span class="nc" id="L4173">        featureContainer.clear();</span>
<span class="nc bnc" id="L4174" title="All 2 branches missed.">        if (nationType != null) addFeatures(nationType);</span>

<span class="nc" id="L4176">        super.readChildren(xr);</span>

        // @compat 0.10.7
        // Fixup production modifiers deriving from founding fathers
<span class="nc" id="L4180">        final Specification spec = getSpecification();</span>
<span class="nc bnc" id="L4181" title="All 2 branches missed.">        for (Modifier m : getModifiers()) {</span>
<span class="nc bnc" id="L4182" title="All 2 branches missed.">            if (m.getSource() == null) continue;</span>
<span class="nc" id="L4183">            String type = spec.fatherGoodsFixMap.get(m.getSource().getId());</span>
<span class="nc bnc" id="L4184" title="All 4 branches missed.">            if (type != null &amp;&amp; m.getId().equals(type)) {</span>
<span class="nc" id="L4185">                m.requireNegatedPersonScope();</span>
            }
        }
        // end @compat 0.10.7

<span class="nc" id="L4190">        recalculateBellsBonus(); // Bells bonuses depend on tax</span>
<span class="nc" id="L4191">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="nc" id="L4198">        final Specification spec = getSpecification();</span>
<span class="nc" id="L4199">        final Game game = getGame();</span>
<span class="nc" id="L4200">        final String tag = xr.getLocalName();</span>

<span class="nc bnc" id="L4202" title="All 2 branches missed.">        if (BAN_MISSIONS_TAG.equals(tag)) {</span>
<span class="nc" id="L4203">            Player player = xr.makeFreeColGameObject(game, PLAYER_TAG,</span>
<span class="nc" id="L4204">                                                     Player.class, true);</span>
<span class="nc bnc" id="L4205" title="All 4 branches missed.">            if (player != null &amp;&amp; player.isEuropean()) addMissionBan(player);</span>
<span class="nc" id="L4206">            xr.closeTag(BAN_MISSIONS_TAG);</span>

<span class="nc bnc" id="L4208" title="All 2 branches missed.">        } else if (FOUNDING_FATHERS_TAG.equals(tag)) {</span>
<span class="nc" id="L4209">            List&lt;FoundingFather&gt; ffs = xr.readList(spec, FOUNDING_FATHERS_TAG,</span>
<span class="nc" id="L4210">                                                   FoundingFather.class);</span>
<span class="nc bnc" id="L4211" title="All 2 branches missed.">            if (ffs != null) {</span>
<span class="nc bnc" id="L4212" title="All 2 branches missed.">                for (FoundingFather ff : ffs) {</span>
<span class="nc" id="L4213">                    addFather(ff); // addFather adds the features</span>
                }
            }
        
<span class="nc bnc" id="L4217" title="All 2 branches missed.">        } else if (OFFERED_FATHERS_TAG.equals(tag)) {</span>
<span class="nc" id="L4218">            List&lt;FoundingFather&gt; ofs = xr.readList(spec, OFFERED_FATHERS_TAG,</span>
<span class="nc" id="L4219">                                                   FoundingFather.class);</span>
<span class="nc" id="L4220">            offeredFathers.addAll(ofs);</span>

<span class="nc bnc" id="L4222" title="All 2 branches missed.">        } else if (STANCE_TAG.equals(tag)) {</span>
<span class="nc" id="L4223">            Player player = xr.makeFreeColGameObject(game, PLAYER_TAG,</span>
<span class="nc" id="L4224">                                                     Player.class, true);</span>
<span class="nc" id="L4225">            stance.put(player.getId(),</span>
<span class="nc" id="L4226">                xr.getAttribute(VALUE_TAG, Stance.class, Stance.UNCONTACTED));</span>
<span class="nc" id="L4227">            xr.closeTag(STANCE_TAG);</span>

<span class="nc bnc" id="L4229" title="All 2 branches missed.">        } else if (TENSION_TAG.equals(tag)) {</span>
<span class="nc" id="L4230">            tension.put(xr.makeFreeColGameObject(game, PLAYER_TAG,</span>
<span class="nc" id="L4231">                                                 Player.class, true),</span>
<span class="nc" id="L4232">                        new Tension(xr.getAttribute(VALUE_TAG, 0)));</span>
<span class="nc" id="L4233">            xr.closeTag(TENSION_TAG);</span>
        
<span class="nc bnc" id="L4235" title="All 2 branches missed.">        } else if (Ability.getTagName().equals(tag)) {</span>
<span class="nc" id="L4236">            Ability ability = new Ability(xr, spec);</span>
<span class="nc bnc" id="L4237" title="All 2 branches missed.">            if (ability.isIndependent()) addAbility(ability);</span>

<span class="nc bnc" id="L4239" title="All 2 branches missed.">        } else if (Europe.getTagName().equals(tag)) {</span>
<span class="nc" id="L4240">            europe = xr.readFreeColGameObject(game, Europe.class);</span>

<span class="nc bnc" id="L4242" title="All 2 branches missed.">        } else if (HighSeas.getTagName().equals(tag)) {</span>
<span class="nc" id="L4243">            highSeas = xr.readFreeColGameObject(game, HighSeas.class);</span>

<span class="nc bnc" id="L4245" title="All 2 branches missed.">        } else if (HistoryEvent.getTagName().equals(tag)) {</span>
<span class="nc" id="L4246">            addHistory(new HistoryEvent(xr));</span>

<span class="nc bnc" id="L4248" title="All 2 branches missed.">        } else if (LastSale.getTagName().equals(tag)) {</span>
<span class="nc" id="L4249">            addLastSale(new LastSale(xr));</span>

<span class="nc bnc" id="L4251" title="All 2 branches missed.">        } else if (Market.getTagName().equals(tag)) {</span>
<span class="nc" id="L4252">            market = xr.readFreeColGameObject(game, Market.class);</span>

<span class="nc bnc" id="L4254" title="All 2 branches missed.">        } else if (ModelMessage.getTagName().equals(tag)) {</span>
<span class="nc" id="L4255">            addModelMessage(new ModelMessage(xr));</span>

<span class="nc bnc" id="L4257" title="All 2 branches missed.">        } else if (Modifier.getTagName().equals(tag)) {</span>
<span class="nc" id="L4258">            Modifier modifier = new Modifier(xr, spec);</span>
<span class="nc bnc" id="L4259" title="All 2 branches missed.">            if (modifier.isIndependent()) addModifier(modifier);</span>

<span class="nc bnc" id="L4261" title="All 2 branches missed.">        } else if (Monarch.getTagName().equals(tag)) {</span>
<span class="nc" id="L4262">            monarch = xr.readFreeColGameObject(game, Monarch.class);</span>

<span class="nc bnc" id="L4264" title="All 2 branches missed.">        } else if (TradeRoute.getTagName().equals(tag)) {</span>
<span class="nc" id="L4265">            addTradeRoute(xr.readFreeColGameObject(game, TradeRoute.class));</span>

<span class="nc" id="L4267">        } else {</span>
<span class="nc" id="L4268">            super.readChild(xr);</span>
        }
<span class="nc" id="L4270">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L4277">        return nationId;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
<span class="nc" id="L4284">    public String getXMLTagName() { return getTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;player&quot;
     */
    public static String getTagName() {
<span class="nc" id="L4292">        return &quot;player&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</div></body></html>