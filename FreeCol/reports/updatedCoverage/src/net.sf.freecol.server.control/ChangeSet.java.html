<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ChangeSet.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.server.control</a> &gt; <span class="el_source">ChangeSet.java</span></div><h1>ChangeSet.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/**</span>
 *  Copyright (C) 2002-2016   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.server.control;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import net.sf.freecol.common.model.Ability;
import net.sf.freecol.common.model.Feature;
import net.sf.freecol.common.model.FoundingFather;
import net.sf.freecol.common.model.FreeColGameObject;
import net.sf.freecol.common.model.FreeColObject;
import net.sf.freecol.common.model.Game;
import net.sf.freecol.common.model.GoodsType;
import net.sf.freecol.common.model.HistoryEvent;
import net.sf.freecol.common.model.LastSale;
import net.sf.freecol.common.model.Location;
import net.sf.freecol.common.model.ModelMessage;
import net.sf.freecol.common.model.Modifier;
import net.sf.freecol.common.model.Ownable;
import net.sf.freecol.common.model.Player;
import net.sf.freecol.common.model.Stance;
import net.sf.freecol.common.model.Settlement;
import net.sf.freecol.common.model.Tile;
import net.sf.freecol.common.model.TradeRoute;
import net.sf.freecol.common.model.Unit;
import net.sf.freecol.common.model.WorkLocation;
import net.sf.freecol.common.networking.DOMMessage;
import net.sf.freecol.common.networking.MultipleMessage;
import net.sf.freecol.common.networking.SpySettlementMessage;
import net.sf.freecol.server.model.ServerPlayer;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;


/**
 * Changes to be sent to the client.
 */
public class ChangeSet {

    /** Compare changes by ascending priority. */
<span class="nc" id="L65">    private static final Comparator&lt;Change&gt; changeComparator</span>
<span class="nc" id="L66">        = Comparator.comparingInt(Change::getPriority);</span>

    // Convenient way to specify the relative priorities of the fixed
    // change types in one place.
<span class="nc" id="L70">    public static enum ChangePriority {</span>
<span class="nc" id="L71">        CHANGE_ATTRIBUTE(-1), // N/A</span>
<span class="nc" id="L72">        CHANGE_ANIMATION(0),  // Do animations first</span>
<span class="nc" id="L73">        CHANGE_REMOVE(100),   // Do removes last</span>
<span class="nc" id="L74">        CHANGE_STANCE(5),     // Do stance before updates</span>
<span class="nc" id="L75">        CHANGE_OWNED(20),     // Do owned changes after updates</span>
<span class="nc" id="L76">        CHANGE_UPDATE(10),    // There are a lot of updates</span>
        // Symbolic priorities used by various non-fixed types
<span class="nc" id="L78">        CHANGE_EARLY(1),</span>
<span class="nc" id="L79">        CHANGE_NORMAL(15),</span>
<span class="nc" id="L80">        CHANGE_LATE(90);</span>

        private final int level;

<span class="nc" id="L84">        ChangePriority(int level) {</span>
<span class="nc" id="L85">            this.level = level;</span>
<span class="nc" id="L86">        }</span>

        public int getPriority() {
<span class="nc" id="L89">            return level;</span>
        }
    }

    private final ArrayList&lt;Change&gt; changes;


    /**
     * Class to control the visibility of a change.
     */
    public static class See {
        private static final int ALL = 1;
        private static final int PERHAPS = 0;
        private static final int ONLY = -1;
        private ServerPlayer seeAlways;
        private ServerPlayer seePerhaps;
        private ServerPlayer seeNever;
        private final int type;

<span class="nc" id="L108">        private See(int type) {</span>
<span class="nc" id="L109">            this.seeAlways = this.seePerhaps = this.seeNever = null;</span>
<span class="nc" id="L110">            this.type = type;</span>
<span class="nc" id="L111">        }</span>

        /**
         * Check this visibility with respect to a player.
         *
         * @param player The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
         * @param perhapsResult The result if the visibility is ambiguous.
         * @return True if the player satisfies the visibility test.
         */
        public boolean check(ServerPlayer player, boolean perhapsResult) {
<span class="nc bnc" id="L121" title="All 2 branches missed.">            return (seeNever == player) ? false</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                : (seeAlways == player) ? true</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                : (seePerhaps == player) ? perhapsResult</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                : (type == ONLY) ? false</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                : (type == ALL) ? true</span>
<span class="nc" id="L126">                : perhapsResult;</span>
        }

        // Use these public constructor-like functions to define the
        // visibility of changes.

        /**
         * Make this change visible to all players.
         *
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public static See all() {
<span class="nc" id="L138">            return new See(ALL);</span>
        }

        /**
         * Make this change visible to all players, provided they can
         * see the objects that are being changed.
         *
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public static See perhaps() {
<span class="nc" id="L148">            return new See(PERHAPS);</span>
        }

        /**
         * Make this change visible only to the given player.
         *
         * @param player a &lt;code&gt;ServerPlayer&lt;/code&gt; value
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public static See only(ServerPlayer player) {
<span class="nc" id="L158">            return new See(ONLY).always(player);</span>
        }

        // Use these to modify a See visibility.

        /**
         * Make this change visible to the given player.
         *
         * @param player a &lt;code&gt;ServerPlayer&lt;/code&gt; value
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public See always(ServerPlayer player) {
<span class="nc" id="L170">            seeAlways = player;</span>
<span class="nc" id="L171">            return this;</span>
        }

        /**
         * Make this change visible to the given player, provided the
         * player can see the objects being changed.
         *
         * @param player a &lt;code&gt;ServerPlayer&lt;/code&gt; value
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public See perhaps(ServerPlayer player) {
<span class="nc" id="L182">            seePerhaps = player;</span>
<span class="nc" id="L183">            return this;</span>
        }

        /**
         * Make this change invisible to the given player.
         *
         * @param player a &lt;code&gt;ServerPlayer&lt;/code&gt; value
         * @return a &lt;code&gt;See&lt;/code&gt; value
         */
        public See except(ServerPlayer player) {
<span class="nc" id="L193">            seeNever = player;</span>
<span class="nc" id="L194">            return this;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L202">            StringBuilder sb = new StringBuilder(64);</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">            sb.append((type == ALL) ? &quot;ALL&quot; : (type == PERHAPS) ? &quot;PERHAPS&quot;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                : (type == ONLY) ? &quot;ONLY&quot; : &quot;BADTYPE&quot;);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (seeAlways != null) {</span>
<span class="nc" id="L206">                sb.append(&quot;,always(&quot;).append(seeAlways.getId()).append(&quot;)&quot;);</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (seePerhaps != null) {</span>
<span class="nc" id="L209">                sb.append(&quot;,perhaps(&quot;).append(seePerhaps.getId()).append(&quot;)&quot;);</span>
            }
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (seeNever != null) {</span>
<span class="nc" id="L212">                sb.append(&quot;,never(&quot;).append(seeNever.getId()).append(&quot;)&quot;);</span>
            }
<span class="nc" id="L214">            return sb.toString();</span>
        }
    }

    /**
     * Abstract template for all types of Change.
     */
    private abstract static class Change {

        /**
         * The visibility of the change.
         */
        protected final See see;


        /**
         * Make a new Change.
         *
         * @param see The visibility.
         */
<span class="nc" id="L234">        public Change(See see) {</span>
<span class="nc" id="L235">            this.see = see;</span>
<span class="nc" id="L236">        }</span>


        /**
         * Does this Change operate on the given object?
         *
         * @param fcgo The &lt;code&gt;FreeColGameObject&lt;/code&gt; to check.
         * @return True if the object is a subject of this change.
         */
        public boolean matches(FreeColGameObject fcgo) {
<span class="nc" id="L246">            return false;</span>
        }

        /**
         * Gets the sort priority of a change, to be used by the
         * changeComparator.
         *
         * @return The sort priority.
         */
        public abstract int getPriority();

        /**
         * Should a player be notified of this Change?
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
         * @return True if this &lt;code&gt;Change&lt;/code&gt; should be sent.
         */
        public boolean isNotifiable(ServerPlayer serverPlayer) {
<span class="nc" id="L264">            return see.check(serverPlayer, isPerhapsNotifiable(serverPlayer));</span>
        }

        /**
         * Should a player be notified of a Change for which the
         * visibility is delegated to the change type, allowing
         * special change-specific overrides.
         *
         * This is false by default, subclasses should override when
         * special case handling is required.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
         * @return False.
         */
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="nc" id="L279">            return false;</span>
        }

        /**
         * Are the secondary changes consequent to this Change?
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to consider.
         * @return A list of secondary &lt;code&gt;Change&lt;/code&gt;s or the
         *     empty list if there are none, which is usually the case.
         */
        public List&lt;Change&gt; consequences(ServerPlayer serverPlayer) {
<span class="nc" id="L290">            return Collections.&lt;Change&gt;emptyList();</span>
        }

        /**
         * Can this Change be directly converted to an Element?
         *
         * @return True if this change can be directly converted to an Element.
         */
        public boolean convertsToElement() {
<span class="nc" id="L299">            return true;</span>
        }

        /**
         * Specialize a Change for a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt; to build the element in.
         * @return An &lt;code&gt;Element&lt;/code&gt; encapsulating this change.
         */
        public abstract Element toElement(ServerPlayer serverPlayer,
                                          Document doc);

        /**
         * Some changes can not be directly specialized, but need to be
         * directly attached to an element.
         *
         * @param element The &lt;code&gt;Element&lt;/code&gt; to attach to.
         */
        public abstract void attachToElement(Element element);
    }

    /**
     * Encapsulate an attack.
     */
    private static class AttackChange extends Change {

        private final Unit attacker;
        private final Unit defender;
        private final boolean success;
        private final boolean defenderInSettlement;


        /**
         * Build a new AttackChange.
         *
         * Note that we must copy attackers and defenders because a
         * successful attacker can move, any an unsuccessful
         * participant can die, and unsuccessful defenders can be
         * captured.  Furthermore for defenders, insufficient
         * information is serialized when a unit is inside a
         * settlement, but if unscoped too much is disclosed.  So we
         * make a copy and neuter it.
         *
         * We have to remember if the defender was in a settlement
         * because by the time serialization occurs the settlement
         * might have been destroyed.
         *
         * We just have to accept that combat animation is an
         * exception to the normal visibility rules.
         *
         * @param see The visibility of this change.
         * @param attacker The &lt;code&gt;Unit&lt;/code&gt; that is attacking.
         * @param defender The &lt;code&gt;Unit&lt;/code&gt; that is defending.
         * @param success Did the attack succeed.
         */
        public AttackChange(See see, Unit attacker, Unit defender,
                            boolean success) {
<span class="nc" id="L357">            super(see);</span>
<span class="nc" id="L358">            Game game = attacker.getGame();</span>
<span class="nc" id="L359">            this.defenderInSettlement = defender.getTile().hasSettlement();</span>
<span class="nc" id="L360">            this.attacker = attacker.copy(game, Unit.class);</span>
<span class="nc" id="L361">            this.attacker.setLocationNoUpdate(this.attacker.getTile());</span>
<span class="nc" id="L362">            this.defender = defender.copy(game, Unit.class);</span>
<span class="nc" id="L363">            this.defender.setLocationNoUpdate(this.defender.getTile());</span>
<span class="nc" id="L364">            this.defender.setWorkType(null);</span>
<span class="nc" id="L365">            this.defender.setState(Unit.UnitState.ACTIVE);            </span>
<span class="nc" id="L366">            this.success = success;</span>
<span class="nc" id="L367">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_ANIMATION&quot;.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L376">            return ChangePriority.CHANGE_ANIMATION.getPriority();</span>
        }

        /**
         * Should a player perhaps be notified of this attack?  Do not
         * use canSeeUnit because that gives a false negative for
         * units in settlements, which should be animated.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return True if the player should be notified.
         */
        @Override
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="nc bnc" id="L389" title="All 2 branches missed.">            return serverPlayer == attacker.getOwner()</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                || serverPlayer == defender.getOwner()</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                || (serverPlayer.canSee(attacker.getTile())</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    &amp;&amp; serverPlayer.canSee(defender.getTile()));</span>
        }

        /**
         * Specialize a AttackChange into an &quot;animateAttack&quot; element
         * for a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;animateAttack&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L405">            final Game game = serverPlayer.getGame();</span>
<span class="nc" id="L406">            Element element = doc.createElement(&quot;animateAttack&quot;);</span>
<span class="nc" id="L407">            element.setAttribute(&quot;attacker&quot;, attacker.getId());</span>
<span class="nc" id="L408">            element.setAttribute(&quot;defender&quot;, defender.getId());</span>
<span class="nc" id="L409">            element.setAttribute(&quot;attackerTile&quot;, attacker.getTile().getId());</span>
<span class="nc" id="L410">            element.setAttribute(&quot;defenderTile&quot;, defender.getTile().getId());</span>
<span class="nc" id="L411">            element.setAttribute(&quot;success&quot;, Boolean.toString(success));</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (!canSeeUnit(serverPlayer, attacker)) {</span>
<span class="nc" id="L413">                element.appendChild(DOMMessage.toXMLElement(attacker, doc,</span>
<span class="nc" id="L414">                                                            (Player)null));</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                if (attacker.getLocation() instanceof Unit) {</span>
<span class="nc" id="L416">                    Unit loc = (Unit)attacker.getLocation();</span>
<span class="nc" id="L417">                    element.appendChild(DOMMessage.toXMLElement(loc, doc, serverPlayer));</span>
                }
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (!canSeeUnit(serverPlayer, defender)</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                || this.defenderInSettlement) {</span>
<span class="nc" id="L422">                element.appendChild(DOMMessage.toXMLElement(defender, doc,</span>
<span class="nc" id="L423">                                                            (Player)null));</span>
            }
<span class="nc" id="L425">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L432">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L439">            StringBuilder sb = new StringBuilder(64);</span>
<span class="nc" id="L440">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L441">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L442">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L443">                .append(&quot; &quot;).append(attacker.getId())</span>
<span class="nc" id="L444">                .append(&quot;@&quot;).append(attacker.getTile().getId())</span>
<span class="nc" id="L445">                .append(&quot; &quot;).append(success)</span>
<span class="nc" id="L446">                .append(&quot; &quot;).append(defender.getId())</span>
<span class="nc" id="L447">                .append(&quot;@&quot;).append(defender.getTile().getId())</span>
<span class="nc" id="L448">                .append(&quot;]&quot;);</span>
<span class="nc" id="L449">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate an attribute change.
     */
    private static class AttributeChange extends Change {
        private final String key;
        private final String value;

        /**
         * Build a new AttributeChange.
         *
         * @param see The visibility of this change.
         * @param key A key &lt;code&gt;String&lt;/code&gt;.
         * @param value The corresponding value as a &lt;code&gt;String&lt;/code&gt;.
         */
        public AttributeChange(See see, String key, String value) {
<span class="nc" id="L468">            super(see);</span>
<span class="nc" id="L469">            this.key = key;</span>
<span class="nc" id="L470">            this.value = value;</span>
<span class="nc" id="L471">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_ATTRIBUTE&quot;, attributes are special.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L480">            return ChangePriority.CHANGE_ATTRIBUTE.getPriority();</span>
        }

        /**
         * AttributeChanges are tacked onto the final Element, not converted
         * directly.
         *
         * @return false.
         */
        @Override
        public boolean convertsToElement() {
<span class="nc" id="L491">            return false;</span>
        }

        /**
         * We do not specialize AttributeChanges.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return Null.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L503">            return null;</span>
        }

        /**
         * Tack attributes onto the element.
         *
         * @param element The &lt;code&gt;Element&lt;/code&gt; to attach to.
         */
        @Override
        public void attachToElement(Element element) {
<span class="nc" id="L513">            element.setAttribute(key, value);</span>
<span class="nc" id="L514">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L521">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L522">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L523">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L524">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L525">                .append(&quot; &quot;).append(key)</span>
<span class="nc" id="L526">                .append(&quot;=&quot;).append(value)</span>
<span class="nc" id="L527">                .append(&quot;]&quot;);</span>
<span class="nc" id="L528">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a Message.
     */
    private static class MessageChange extends Change {
        private final ChangePriority priority;
        private final DOMMessage message;

        /**
         * Build a new MessageChange.
         *
         * @param see The visibility of this change.
         * @param priority The priority of the change.
         * @param message The &lt;code&gt;Message&lt;/code&gt; to add.
         */
        public MessageChange(See see, ChangePriority priority,
                             DOMMessage message) {
<span class="nc" id="L548">            super(see);</span>
<span class="nc" id="L549">            this.priority = priority;</span>
<span class="nc" id="L550">            this.message = message;</span>
<span class="nc" id="L551">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return The priority.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L560">            return priority.getPriority();</span>
        }

        /**
         * Specialize a MessageChange to a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L572">            Element element = message.toXMLElement();</span>
<span class="nc" id="L573">            return (Element) doc.importNode(element, true);</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L580">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L587">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L588">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L589">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L590">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L591">                .append(&quot; &quot;).append(message)</span>
<span class="nc" id="L592">                .append(&quot;]&quot;);</span>
<span class="nc" id="L593">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a move.
     */
    private static class MoveChange extends Change {
        private final Unit unit;
        private final Location oldLocation;
        private final Tile newTile;

        private boolean seeOld(ServerPlayer serverPlayer) {
<span class="nc" id="L606">            Tile oldTile = oldLocation.getTile();</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">            return serverPlayer.owns(unit)</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                || (oldTile != null</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">                    &amp;&amp; serverPlayer.canSee(oldTile)</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                    &amp;&amp; !oldTile.hasSettlement()</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">                    &amp;&amp; !(oldLocation instanceof Unit));</span>
        }

        private boolean seeNew(ServerPlayer serverPlayer) {
<span class="nc" id="L615">            return canSeeUnit(serverPlayer, unit);</span>
        }


        /**
         * Build a new MoveChange.
         *
         * @param see The visibility of this change.
         * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is moving.
         * @param oldLocation The location from which the unit is moving.
         * @param newTile The &lt;code&gt;Tile&lt;/code&gt; to which the unit is moving.
         */
        public MoveChange(See see, Unit unit, Location oldLocation,
                          Tile newTile) {
<span class="nc" id="L629">            super(see);</span>
<span class="nc" id="L630">            this.unit = unit;</span>
<span class="nc" id="L631">            this.oldLocation = oldLocation;</span>
<span class="nc" id="L632">            this.newTile = newTile;</span>
<span class="nc" id="L633">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_ANIMATION&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L642">            return ChangePriority.CHANGE_ANIMATION.getPriority();</span>
        }

        /**
         * Should a player perhaps be notified of this move?
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return True if the player should be notified.
         */
        @Override
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="nc bnc" id="L653" title="All 4 branches missed.">            return seeOld(serverPlayer) || seeNew(serverPlayer);</span>
        }

        /**
         * There are consequences to a move.  If the player can not
         * see the unit after the move, it should be removed.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return A RemoveChange if the unit disappears (but not if it
         *     is destroyed, that is handled elsewhere).
         */
        @Override
        public List&lt;Change&gt; consequences(ServerPlayer serverPlayer) {
<span class="nc bnc" id="L666" title="All 4 branches missed.">            if (seeOld(serverPlayer) &amp;&amp; !seeNew(serverPlayer)</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                &amp;&amp; !unit.isDisposed()) {</span>
<span class="nc" id="L668">                List&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L669">                units.add(unit);</span>
<span class="nc" id="L670">                List&lt;Change&gt; changes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L671">                changes.add(new RemoveChange(See.only(serverPlayer),</span>
<span class="nc" id="L672">                                             unit.getLocation(), units));</span>
<span class="nc" id="L673">                return changes;</span>
            }
<span class="nc" id="L675">            return Collections.&lt;Change&gt;emptyList();</span>
        }

        /**
         * Specialize a MoveChange into an &quot;animateMove&quot; element for a
         * particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;animateMove&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L688">            Element element = doc.createElement(&quot;animateMove&quot;);</span>
<span class="nc" id="L689">            element.setAttribute(&quot;unit&quot;, unit.getId());</span>
<span class="nc" id="L690">            element.setAttribute(&quot;oldTile&quot;, oldLocation.getTile().getId());</span>
<span class="nc" id="L691">            element.setAttribute(&quot;newTile&quot;, newTile.getId());</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (!seeOld(serverPlayer)) {</span>
                // We can not rely on the unit that is about to move
                // being present on the client side, and it is needed
                // before we can run the animation, so it is attached
                // to animateMove.
<span class="nc" id="L697">                element.appendChild(DOMMessage.toXMLElement(unit, doc, serverPlayer));</span>
            }
<span class="nc" id="L699">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L706">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L713">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L714">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L715">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L716">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L717">                .append(&quot; &quot;).append(unit.getId())</span>
<span class="nc" id="L718">                .append(&quot; &quot;).append(oldLocation.getId())</span>
<span class="nc" id="L719">                .append(&quot; &quot;).append(newTile.getId())</span>
<span class="nc" id="L720">                .append(&quot;]&quot;);</span>
<span class="nc" id="L721">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a FreeColGameObject update.
     */
    private static class ObjectChange extends Change {
        protected final FreeColGameObject fcgo;

        /**
         * Build a new ObjectChange for a single object.
         *
         * @param see The visibility of this change.
         * @param fcgo The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
         */
        public ObjectChange(See see, FreeColGameObject fcgo) {
<span class="nc" id="L738">            super(see);</span>
<span class="nc" id="L739">            this.fcgo = fcgo;</span>
<span class="nc" id="L740">        }</span>


        /**
         * {@inheritDoc}
         */
        @Override
        public boolean matches(FreeColGameObject fcgo) {
<span class="nc bnc" id="L748" title="All 2 branches missed.">            return this.fcgo == fcgo;</span>
        }

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_UPDATE&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L758">            return ChangePriority.CHANGE_UPDATE.getPriority();</span>
        }

        /**
         * Should a player perhaps be notified of this update?
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return True if the object update can is notifiable.
         */
        @Override
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (fcgo instanceof Unit) {</span>
                // Units have a precise test, use that rather than
                // the more general interface-based tests.
<span class="nc" id="L772">                return canSeeUnit(serverPlayer, (Unit)fcgo);</span>
            }
            // If we own it, we can see it.
<span class="nc bnc" id="L775" title="All 4 branches missed.">            if (fcgo instanceof Ownable &amp;&amp; serverPlayer.owns((Ownable)fcgo)) {</span>
<span class="nc" id="L776">                return true;</span>
            }
            // We do not own it, so the only way we could see it is if
            // it is on the map.  Would like to use getTile() to
            // decide that, but this will include ColonyTiles, which
            // report the colony center tile, yet should never be visible.
            // So just brutally disallow WorkLocations which should always
            // be invisible inside colonies.
<span class="nc bnc" id="L784" title="All 2 branches missed.">            if (fcgo instanceof WorkLocation) {</span>
<span class="nc" id="L785">                return false;</span>
            }
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (fcgo instanceof Location) {</span>
<span class="nc" id="L788">                Tile tile = ((Location)fcgo).getTile();</span>
<span class="nc" id="L789">                return serverPlayer.canSee(tile);</span>
            }
<span class="nc" id="L791">            return false;</span>
        }

        /**
         * Specialize a ObjectChange to a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;update&quot; element, or null if the update should not
         *     be visible to the player.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L804">            Element element = doc.createElement(&quot;update&quot;);</span>
<span class="nc" id="L805">            element.appendChild(DOMMessage.toXMLElement(fcgo, doc, serverPlayer));</span>
<span class="nc" id="L806">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L813">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L820">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L821">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L822">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L823">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L824">                .append(&quot; &quot;).append(fcgo.getId())</span>
<span class="nc" id="L825">                .append(&quot;]&quot;);</span>
<span class="nc" id="L826">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a partial update of a FreeColGameObject.
     */
    private static class PartialObjectChange extends ObjectChange {
        private final String[] fields;

        /**
         * Build a new PartialObjectChange for a single object.
         *
         * @param see The visibility of this change.
         * @param fcgo The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
         * @param fields The fields to update.
         */
        public PartialObjectChange(See see, FreeColGameObject fcgo,
                                   String... fields) {
<span class="nc" id="L845">            super(see, fcgo);</span>
<span class="nc" id="L846">            this.fields = fields;</span>
<span class="nc" id="L847">        }</span>


        /**
         * Should a player perhaps be notified of this update?
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return False.  Revert to default from ObjectChange special case.
         */
        @Override
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
<span class="nc" id="L858">            return false;</span>
        }

        /**
         * Specialize a PartialObjectChange to a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;update&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L870">            Element element = doc.createElement(&quot;update&quot;);</span>
<span class="nc" id="L871">            element.appendChild(DOMMessage.toXMLElementPartial(fcgo, doc, fields));</span>
<span class="nc" id="L872">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L880">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L881">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L882">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L883">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L884">                .append(&quot; &quot;).append(fcgo.getId());</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            for (String f : fields) sb.append(&quot; &quot;).append(f);</span>
<span class="nc" id="L886">            sb.append(&quot;]&quot;);</span>
<span class="nc" id="L887">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a new player change.
     */
    private static class PlayerChange extends Change {
        private final ServerPlayer player;

        /**
         * Build a new PlayerChange.
         *
         * @param see The visibility of this change.
         * @param player The &lt;code&gt;Player&lt;/code&gt; to add.
         */
        public PlayerChange(See see, ServerPlayer player) {
<span class="nc" id="L904">            super(see);</span>
<span class="nc" id="L905">            this.player = player;</span>
<span class="nc" id="L906">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_EARLY&quot;.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L915">            return ChangePriority.CHANGE_EARLY.getPriority();</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public boolean isNotifiable(ServerPlayer serverPlayer) {
<span class="nc" id="L923">            return true;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L931">            final Game game = serverPlayer.getGame();</span>
<span class="nc" id="L932">            Element element = doc.createElement(&quot;addPlayer&quot;);</span>
<span class="nc" id="L933">            element.appendChild(DOMMessage.toXMLElement(this.player, doc, serverPlayer));</span>
<span class="nc" id="L934">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L941">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L948">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L949">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L950">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L951">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L952">                .append(&quot; &quot;).append(player.getId())</span>
<span class="nc" id="L953">                .append(&quot;]&quot;);</span>
<span class="nc" id="L954">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulates removing some objects.
     *
     * -vis: If removing settlements or units, visibility changes.
     */
    private static class RemoveChange extends Change {
        private final Tile tile;
        private final FreeColGameObject fcgo;
        private final List&lt;? extends FreeColGameObject&gt; contents;

        /**
         * Build a new RemoveChange for an object that is disposed.
         *
         * @param see The visibility of this change.
         * @param loc The &lt;code&gt;Location&lt;/code&gt; where the object was.
         * @param objects The &lt;code&gt;FreeColGameObject&lt;/code&gt;s to remove.
         */
        public RemoveChange(See see, Location loc,
                            List&lt;? extends FreeColGameObject&gt; objects) {
<span class="nc" id="L977">            super(see);</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">            this.tile = (loc instanceof Tile) ? (Tile)loc : null;</span>
<span class="nc" id="L979">            this.fcgo = objects.remove(objects.size() - 1);</span>
<span class="nc" id="L980">            this.contents = objects;</span>
<span class="nc" id="L981">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_REMOVE&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L990">            return ChangePriority.CHANGE_REMOVE.getPriority();</span>
        }

        /**
         * Should a player perhaps be notified of this removal?
         * They should if they can see the tile, and there is no
         * other-player settlement present.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to notify.
         * @return True if the player should be notified.
         */
        @Override
        public boolean isPerhapsNotifiable(ServerPlayer serverPlayer) {
            Settlement settlement;
<span class="nc bnc" id="L1004" title="All 2 branches missed.">            return tile != null</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">                &amp;&amp; serverPlayer.canSee(tile)</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                &amp;&amp; ((settlement = tile.getSettlement()) == null</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                    || settlement.isDisposed()</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                    || serverPlayer.owns(settlement));</span>
        }

        /**
         * Specialize a RemoveChange to a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return A &quot;remove&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1020">            Element element = doc.createElement(&quot;remove&quot;);</span>
            // The main object may be visible, but the contents are
            // only visible if the deeper ownership test succeeds.
<span class="nc bnc" id="L1023" title="All 4 branches missed.">            if (fcgo instanceof Ownable &amp;&amp; serverPlayer.owns((Ownable)fcgo)) {</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                for (FreeColGameObject o : contents) {</span>
<span class="nc" id="L1025">                    element.appendChild(DOMMessage.toXMLElementPartial(o, doc));</span>
                }
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                element.setAttribute(&quot;divert&quot;, (tile != null) ? tile.getId()</span>
<span class="nc" id="L1028">                                     : serverPlayer.getId());</span>
            }
<span class="nc" id="L1030">            element.appendChild(DOMMessage.toXMLElementPartial(fcgo, doc));</span>
<span class="nc" id="L1031">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1038">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1045">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1046">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L1047">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L1048">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                .append(&quot; &quot;).append(((tile == null) ? &quot;&lt;null&gt;&quot; : tile.getId()));</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            for (FreeColGameObject f : contents) {</span>
<span class="nc" id="L1051">                sb.append(&quot; &quot;).append(f.getId());</span>
            }
<span class="nc" id="L1053">            sb.append(&quot; &quot;).append(fcgo.getId()).append(&quot;]&quot;);</span>
<span class="nc" id="L1054">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate an owned object change.
     */
    private static class OwnedChange extends Change {
        private final FreeColObject fco;

        /**
         * Build a new OwnedChange.
         *
         * @param see The visibility of this change.
         * @param fco The &lt;code&gt;FreeColObject&lt;/code&gt; to update.
         */
        public OwnedChange(See see, FreeColObject fco) {
<span class="nc" id="L1071">            super(see);</span>
<span class="nc" id="L1072">            this.fco = fco;</span>
<span class="nc" id="L1073">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_OWNER&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L1082">            return ChangePriority.CHANGE_OWNED.getPriority();</span>
        }

        /**
         * Specialize a OwnedChange into an &quot;addObject&quot; element for a
         * particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;addObject&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1095">            Element element = doc.createElement(&quot;addObject&quot;);</span>
<span class="nc" id="L1096">            Element child = DOMMessage.toXMLElement(fco, doc, serverPlayer);</span>
<span class="nc" id="L1097">            child.setAttribute(&quot;owner&quot;, serverPlayer.getId());</span>
<span class="nc" id="L1098">            element.appendChild(child);</span>
<span class="nc" id="L1099">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1106">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1113">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1114">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L1115">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L1116">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1117">                .append(&quot; &quot;).append(fco.getId())</span>
<span class="nc" id="L1118">                .append(&quot;]&quot;);</span>
<span class="nc" id="L1119">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a feature change.
     */
    private static class FeatureChange extends Change {
        private final FreeColGameObject object;
        private final Feature feature;
        private final boolean add;

        /**
         * Build a new FeatureChange.
         *
         * @param see The visibility of this change.
         * @param object The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
         * @param feature a &lt;code&gt;Feature&lt;/code&gt; value to add or remove.
         * @param add a &lt;code&gt;boolean&lt;/code&gt; value
         */
        public FeatureChange(See see, FreeColGameObject object,
                             Feature feature, boolean add) {
<span class="nc" id="L1141">            super(see);</span>
<span class="nc" id="L1142">            this.object = object;</span>
<span class="nc" id="L1143">            this.feature = feature;</span>
<span class="nc" id="L1144">            this.add = add;</span>
<span class="nc" id="L1145">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_OWNER&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L1154">            return ChangePriority.CHANGE_OWNED.getPriority();</span>
        }

        /**
         * Specialize a feature change into an element for a
         * particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An &quot;addObject&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1167">            Element element = doc.createElement(&quot;featureChange&quot;);</span>
<span class="nc" id="L1168">            element.setAttribute(&quot;add&quot;, Boolean.toString(add));</span>
<span class="nc" id="L1169">            element.setAttribute(FreeColObject.ID_ATTRIBUTE_TAG, object.getId());</span>
<span class="nc" id="L1170">            Element child = DOMMessage.toXMLElement(feature, doc, (Player)null);</span>
<span class="nc" id="L1171">            element.appendChild(child);</span>
<span class="nc" id="L1172">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1179">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1186">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1187">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L1188">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L1189">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">                .append(&quot; &quot;).append((add) ? &quot;add&quot; : &quot;remove&quot;)</span>
<span class="nc" id="L1191">                .append(&quot; &quot;).append(feature)</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">                .append(&quot; &quot;).append((add) ? &quot;to&quot; : &quot;from&quot;)</span>
<span class="nc" id="L1193">                .append(&quot; &quot;).append(object.getId())</span>
<span class="nc" id="L1194">                .append(&quot;]&quot;);</span>
<span class="nc" id="L1195">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulates a spying action.
     */
    private static class SpyChange extends Change {
        private final Unit unit;
        private final Settlement settlement;

        /**
         * Build a new SpyChange.
         *
         * @param see The visibility of this change.
         * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is spying.
         * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to spy on.
         */
        public SpyChange(See see, Unit unit, Settlement settlement) {
<span class="nc" id="L1214">            super(see);</span>
<span class="nc" id="L1215">            this.unit = unit;</span>
<span class="nc" id="L1216">            this.settlement = settlement;</span>
<span class="nc" id="L1217">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return priority.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L1226">            return ChangePriority.CHANGE_NORMAL.getPriority();</span>
        }

        /**
         * Specialize a SpyChange into an element with the supplied name.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1238">            Element element = (Element)doc</span>
<span class="nc" id="L1239">                .adoptNode(new SpySettlementMessage(unit, settlement)</span>
<span class="nc" id="L1240">                    .toXMLElement());</span>
            // Tack on a copy of the settlement tile with full visibility.
<span class="nc" id="L1242">            Tile tile = settlement.getTile();</span>
<span class="nc" id="L1243">            element.appendChild(DOMMessage.toXMLElement(tile, doc,</span>
<span class="nc" id="L1244">                                                        (Player)null));</span>
<span class="nc" id="L1245">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1252">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1259">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1260">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L1261">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L1262">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1263">                .append(&quot; &quot;).append(settlement.getId())</span>
<span class="nc" id="L1264">                .append(&quot;]&quot;);</span>
<span class="nc" id="L1265">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate a stance change.
     */
    private static class StanceChange extends Change {
        private final Player first;
        private final Stance stance;
        private final Player second;

        /**
         * Build a new StanceChange.
         *
         * @param see The visibility of this change.
         * @param first The &lt;code&gt;Player&lt;/code&gt; changing stance.
         * @param stance The &lt;code&gt;Stance&lt;/code&gt; to change to.
         * @param second The &lt;code&gt;Player&lt;/code&gt; wrt with to change.
         */
        public StanceChange(See see, Player first, Stance stance,
                            Player second) {
<span class="nc" id="L1287">            super(see);</span>
<span class="nc" id="L1288">            this.first = first;</span>
<span class="nc" id="L1289">            this.stance = stance;</span>
<span class="nc" id="L1290">            this.second = second;</span>
<span class="nc" id="L1291">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return &quot;CHANGE_STANCE&quot;
         */
        @Override
        public int getPriority() {
<span class="nc" id="L1300">            return ChangePriority.CHANGE_STANCE.getPriority();</span>
        }

        /**
         * Specialize a StanceChange to a particular player.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return A &quot;setStance&quot; element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1312">            Element element = doc.createElement(&quot;setStance&quot;);</span>
<span class="nc" id="L1313">            element.setAttribute(&quot;stance&quot;, stance.toString());</span>
<span class="nc" id="L1314">            element.setAttribute(&quot;first&quot;, first.getId());</span>
<span class="nc" id="L1315">            element.setAttribute(&quot;second&quot;, second.getId());</span>
<span class="nc" id="L1316">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1323">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public String toString() {
<span class="nc" id="L1330">            StringBuilder sb = new StringBuilder(32);</span>
<span class="nc" id="L1331">            sb.append(&quot;[&quot;).append(getClass().getName())</span>
<span class="nc" id="L1332">                .append(&quot; &quot;).append(see)</span>
<span class="nc" id="L1333">                .append(&quot; #&quot;).append(getPriority())</span>
<span class="nc" id="L1334">                .append(&quot; &quot;).append(first.getId())</span>
<span class="nc" id="L1335">                .append(&quot; &quot;).append(stance)</span>
<span class="nc" id="L1336">                .append(&quot; &quot;).append(second.getId())</span>
<span class="nc" id="L1337">                .append(&quot;]&quot;);</span>
<span class="nc" id="L1338">            return sb.toString();</span>
        }
    }

    /**
     * Encapsulate trivial element, which will only have attributes apart
     * from its name.
     */
    private static class TrivialChange extends Change {
        private final int priority;
        private final String name;
        private final String[] attributes;

        /**
         * Build a new TrivialChange.
         *
         * @param see The visibility of this change.
         * @param name The name of the element.
         * @param priority The sort priority of this change.
         * @param attributes The attributes to add to the change.
         */
        public TrivialChange(See see, String name, int priority,
                             String[] attributes) {
<span class="nc" id="L1361">            super(see);</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if ((attributes.length &amp; 1) == 1) {</span>
<span class="nc" id="L1363">                throw new IllegalArgumentException(&quot;Attributes must be even sized&quot;);</span>
            }
<span class="nc" id="L1365">            this.name = name;</span>
<span class="nc" id="L1366">            this.priority = priority;</span>
<span class="nc" id="L1367">            this.attributes = attributes;</span>
<span class="nc" id="L1368">        }</span>

        /**
         * Gets the sort priority.
         *
         * @return priority.
         */
        @Override
        public int getPriority() {
<span class="nc" id="L1377">            return priority;</span>
        }

        /**
         * Specialize a TrivialChange into an element with the supplied name.
         *
         * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to update.
         * @param doc The owner &lt;code&gt;Document&lt;/code&gt;.
         * @return An element.
         */
        @Override
        public Element toElement(ServerPlayer serverPlayer, Document doc) {
<span class="nc" id="L1389">            Element element = doc.createElement(name);</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">            for (int i = 0; i &lt; attributes.length; i += 2) {</span>
<span class="nc" id="L1391">                element.setAttribute(attributes[i], attributes[i+1]);</span>
            }
<span class="nc" id="L1393">            return element;</span>
        }

        /**
         * {@inheritDoc}
         */
        @Override
<span class="nc" id="L1400">        public void attachToElement(Element element) {} // Noop</span>

        /**
         * Debug helper.
         */
        @Override
        public String toString() {
<span class="nc" id="L1407">            String ret = &quot;[&quot; + getClass().getName() + &quot; &quot; + see</span>
<span class="nc" id="L1408">                + &quot; #&quot; + getPriority()</span>
<span class="nc" id="L1409">                + &quot; &quot; + name;</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">            for (String a : attributes) ret += &quot; &quot; + a;</span>
<span class="nc" id="L1411">            return ret + &quot;]&quot;;</span>
        }
    }

    /**
     * Simple constructor.
     */
<span class="nc" id="L1418">    public ChangeSet() {</span>
<span class="nc" id="L1419">        changes = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1420">    }</span>

    /**
     * Copying constructor.
     *
     * @param other The other &lt;code&gt;ChangeSet&lt;/code&gt; to copy.
     */
<span class="nc" id="L1427">    public ChangeSet(ChangeSet other) {</span>
<span class="nc" id="L1428">        changes = new ArrayList&lt;&gt;(other.changes);</span>
<span class="nc" id="L1429">    }</span>


    // Helper routines that should be used to construct a change set.

    /**
     * Sometimes we need to backtrack on making a change.
     *
     * @param fcgo A &lt;code&gt;FreeColGameObject&lt;/code&gt; to remove a matching
     *     change for.
     */
    public void remove(FreeColGameObject fcgo) {
<span class="nc" id="L1441">        Iterator&lt;Change&gt; ci = changes.iterator();</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        while (ci.hasNext()) {</span>
<span class="nc" id="L1443">            Change c = ci.next();</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">            if (c.matches(fcgo)) ci.remove();</span>
        }
<span class="nc" id="L1446">    }</span>

    /**
     * Helper function to add updates for multiple objects to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param objects The &lt;code&gt;FreeColGameObject&lt;/code&gt;s that changed.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet add(See see, FreeColGameObject... objects) {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        for (FreeColGameObject o : objects) {</span>
<span class="nc" id="L1457">            changes.add(new ObjectChange(see, o));</span>
        }
<span class="nc" id="L1459">        return this;</span>
    }

    /**
     * Helper function to add updates for multiple objects to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param objects The &lt;code&gt;FreeColGameObject&lt;/code&gt;s that changed.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet add(See see, Collection&lt;? extends FreeColGameObject&gt; objects) {
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        for (FreeColGameObject o : objects) {</span>
<span class="nc" id="L1471">            changes.add(new ObjectChange(see, o));</span>
        }
<span class="nc" id="L1473">        return this;</span>
    }

    /**
     * Helper function to add a Message to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param cp The priority of this change.
     * @param message The &lt;code&gt;Message&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet add(See see, ChangePriority cp, DOMMessage message) {
<span class="nc" id="L1485">        changes.add(new MessageChange(see, cp, message));</span>
<span class="nc" id="L1486">        return this;</span>
    }

    /**
     * Helper function to add an attack to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param attacker The &lt;code&gt;Unit&lt;/code&gt; that is attacking.
     * @param defender The &lt;code&gt;Unit&lt;/code&gt; that is defending.
     * @param success Did the attack succeed?
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addAttack(See see, Unit attacker, Unit defender,
                               boolean success) {
<span class="nc" id="L1500">        changes.add(new AttackChange(see, attacker, defender, success));</span>
<span class="nc" id="L1501">        return this;</span>
    }

    /**
     * Helper function to add an attribute setting to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param key A key &lt;code&gt;String&lt;/code&gt;.
     * @param value The corresponding value as a &lt;code&gt;String&lt;/code&gt;.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addAttribute(See see, String key, String value) {
<span class="nc" id="L1513">        changes.add(new AttributeChange(see, key, value));</span>
<span class="nc" id="L1514">        return this;</span>
    }

    /**
     * Helper function to add a dead player event to a ChangeSet.
     * Deaths are public knowledge.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; that died.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addDead(ServerPlayer serverPlayer) {
<span class="nc" id="L1525">        addTrivial(See.all(), &quot;setDead&quot;, ChangePriority.CHANGE_EARLY,</span>
<span class="nc" id="L1526">                &quot;player&quot;, serverPlayer.getId());</span>
<span class="nc" id="L1527">        return this;</span>
    }

    /**
     * Helper function to add a removal for an object that disappears
     * (that is, moves where it can not be seen) to a ChangeSet.
     *
     * @param owner The &lt;code&gt;ServerPlayer&lt;/code&gt; that owns this object.
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; where the object was.
     * @param fcgo The &lt;code&gt;FreeColGameObject&lt;/code&gt; that disappears.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addDisappear(ServerPlayer owner, Tile tile,
                                  FreeColGameObject fcgo) {
<span class="nc" id="L1541">        List&lt;FreeColGameObject&gt; objects = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1542">        objects.add(fcgo);</span>
<span class="nc" id="L1543">        changes.add(new RemoveChange(See.perhaps().except(owner), tile, objects));</span>
<span class="nc" id="L1544">        changes.add(new ObjectChange(See.perhaps().except(owner), tile));</span>
<span class="nc" id="L1545">        return this;</span>
    }

    /**
     * Helper function to add a founding father addition event to a ChangeSet.
     * Also adds the father to the owner.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; adding the father.
     * @param father The &lt;code&gt;FoundingFather&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addFather(ServerPlayer serverPlayer,
                               FoundingFather father) {
<span class="nc" id="L1558">        changes.add(new OwnedChange(See.only(serverPlayer), father));</span>
<span class="nc" id="L1559">        serverPlayer.addFather(father);</span>
<span class="nc" id="L1560">        return this;</span>
    }

    /**
     * Helper function to add an Ability to a FreeColGameObject, or remove it.
     *
     * @param serverPlayer a &lt;code&gt;ServerPlayer&lt;/code&gt; value
     * @param object a &lt;code&gt;FreeColGameObject&lt;/code&gt; value
     * @param ability an &lt;code&gt;Ability&lt;/code&gt; value
     * @param add a &lt;code&gt;boolean&lt;/code&gt; value
     * @return a &lt;code&gt;ChangeSet&lt;/code&gt; value
     */
    public ChangeSet addFeatureChange(ServerPlayer serverPlayer, FreeColGameObject object,
                                      Ability ability, boolean add) {
<span class="nc" id="L1574">        changes.add(new FeatureChange(See.only(serverPlayer), object, ability, add));</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">        if (add) {</span>
<span class="nc" id="L1576">            object.addAbility(ability);</span>
<span class="nc" id="L1577">        } else {</span>
<span class="nc" id="L1578">            object.removeAbility(ability);</span>
        }
<span class="nc" id="L1580">        return this;</span>
    }

    /**
     * Helper function to add a Modifier to a FreeColGameObject, or remove it.
     *
     * @param serverPlayer a &lt;code&gt;ServerPlayer&lt;/code&gt; value
     * @param object a &lt;code&gt;FreeColGameObject&lt;/code&gt; value
     * @param modifier a &lt;code&gt;Modifier&lt;/code&gt; value
     * @param add a &lt;code&gt;boolean&lt;/code&gt; value
     * @return a &lt;code&gt;ChangeSet&lt;/code&gt; value
     */
    public ChangeSet addFeatureChange(ServerPlayer serverPlayer, FreeColGameObject object,
                                      Modifier modifier, boolean add) {
<span class="nc" id="L1594">        changes.add(new FeatureChange(See.only(serverPlayer), object, modifier, add));</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">        if (add) {</span>
<span class="nc" id="L1596">            object.addModifier(modifier);</span>
<span class="nc" id="L1597">        } else {</span>
<span class="nc" id="L1598">            object.removeModifier(modifier);</span>
        }
<span class="nc" id="L1600">        return this;</span>
    }

    /**
     * Helper function to add a global history event to a ChangeSet.
     * Also adds the history to all the European players.
     *
     * @param game The &lt;code&gt;Game&lt;/code&gt; to find players in.
     * @param history The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addGlobalHistory(Game game, HistoryEvent history) {
<span class="nc" id="L1612">        changes.add(new OwnedChange(See.all(), history));</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">        for (Player p : game.getLiveEuropeanPlayers(null)) {</span>
<span class="nc" id="L1614">            p.addHistory(history);</span>
        }
<span class="nc" id="L1616">        return this;</span>
    }

    /**
     * Helper function to add a history event to a ChangeSet.
     * Also adds the history to the owner.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; making history.
     * @param history The &lt;code&gt;HistoryEvent&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addHistory(ServerPlayer serverPlayer,
                                HistoryEvent history) {
<span class="nc" id="L1629">        changes.add(new OwnedChange(See.only(serverPlayer), history));</span>
<span class="nc" id="L1630">        serverPlayer.addHistory(history);</span>
<span class="nc" id="L1631">        return this;</span>
    }

    /**
     * Helper function to add a message to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param message The &lt;code&gt;ModelMessage&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addMessage(See see, ModelMessage message) {
<span class="nc" id="L1642">        changes.add(new OwnedChange(see, message));</span>
<span class="nc" id="L1643">        return this;</span>
    }

    /**
     * Helper function to add a move to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is moving.
     * @param loc The location from which the unit is moving.
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to which the unit is moving.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addMove(See see, Unit unit, Location loc, Tile tile) {
<span class="nc" id="L1656">        changes.add(new MoveChange(see, unit, loc, tile));</span>
<span class="nc" id="L1657">        return this;</span>
    }

    /**
     * Helper function to add a partial update change for an object to
     * a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param fcgo The &lt;code&gt;FreeColGameObject&lt;/code&gt; to update.
     * @param fields The fields to update.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addPartial(See see, FreeColGameObject fcgo,
                                String... fields) {
<span class="nc" id="L1671">        changes.add(new PartialObjectChange(see, fcgo, fields));</span>
<span class="nc" id="L1672">        return this;</span>
    }

    /**
     * Helper function to add a new player to a ChangeSet.
     *
     * @param serverPlayer The new &lt;code&gt;ServerPlayer&lt;/code&gt; to add.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addPlayer(ServerPlayer serverPlayer) {
<span class="nc" id="L1682">        changes.add(new PlayerChange(See.all().except(serverPlayer),</span>
<span class="nc" id="L1683">                                     serverPlayer));</span>
<span class="nc" id="L1684">        return this;</span>
    }

    /**
     * Helper function to add a removal to a ChangeSet.
     *
     * -vis: If disposing of units or colonies, this routine changes
     * player visibility.
     *
     * @param see The visibility of this change.
     * @param loc The &lt;code&gt;Location&lt;/code&gt; where the object was.
     * @param obj The &lt;code&gt;FreeColGameObject&lt;/code&gt; to remove.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addRemove(See see, Location loc, FreeColGameObject obj) {
<span class="nc" id="L1699">        changes.add(new RemoveChange(see, loc, obj.getDisposeList()));//-vis</span>
<span class="nc" id="L1700">        return this;</span>
    }

    /**
     * Helper function to add removals for several objects to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param loc The &lt;code&gt;Location&lt;/code&gt; where the object was.
     * @param objects A list of &lt;code&gt;FreeColGameObject&lt;/code&gt;s to remove.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addRemoves(See see, Location loc,
                                List&lt;? extends FreeColGameObject&gt; objects) {
<span class="nc bnc" id="L1713" title="All 2 branches missed.">        for (FreeColGameObject fcgo : objects) {</span>
<span class="nc" id="L1714">            changes.add(new RemoveChange(see, loc, fcgo.getDisposeList()));</span>
        }
<span class="nc" id="L1716">        return this;</span>
    }

    /**
     * Helper function to add a sale change to a ChangeSet.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; making the sale.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; that is buying.
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; bought.
     * @param price The per unit price.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addSale(ServerPlayer serverPlayer, Settlement settlement,
                             GoodsType type, int price) {
<span class="nc" id="L1730">        Game game = settlement.getGame();</span>
<span class="nc" id="L1731">        LastSale sale = new LastSale(settlement, type, game.getTurn(), price);</span>
<span class="nc" id="L1732">        changes.add(new OwnedChange(See.only(serverPlayer), sale));</span>
<span class="nc" id="L1733">        serverPlayer.addLastSale(sale);</span>
<span class="nc" id="L1734">        return this;</span>
    }

    /**
     * Helper function to add a spying change to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; that is spying.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to spy on.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addSpy(See see, Unit unit, Settlement settlement) {
<span class="nc" id="L1746">        changes.add(new SpyChange(see, unit, settlement));</span>
<span class="nc" id="L1747">        return this;</span>
    }

    /**
     * Helper function to add a stance change to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param first The &lt;code&gt;Player&lt;/code&gt; changing stance.
     * @param stance The &lt;code&gt;Stance&lt;/code&gt; to change to.
     * @param second The &lt;code&gt;Player&lt;/code&gt; wrt with to change.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addStance(See see, Player first, Stance stance,
                               Player second) {
<span class="nc" id="L1761">        changes.add(new StanceChange(see, first, stance, second));</span>
<span class="nc" id="L1762">        return this;</span>
    }

    /**
     * Helper function to add a new trade route change to a ChangeSet.
     * Also adds the trade route to the player.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; adding the route.
     * @param tradeRoute The new &lt;code&gt;TradeRoute&lt;/code&gt;.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addTradeRoute(ServerPlayer serverPlayer,
                                   TradeRoute tradeRoute) {
<span class="nc" id="L1775">        changes.add(new OwnedChange(See.only(serverPlayer), tradeRoute));</span>
<span class="nc" id="L1776">        return this;</span>
    }

    /**
     * Helper function to add a trivial element to a ChangeSet.
     *
     * @param see The visibility of this change.
     * @param name The name of the element.
     * @param cp The &lt;code&gt;ChangePriority&lt;/code&gt; for this change.
     * @param attributes Attributes to add to this trivial change.
     * @return The updated &lt;code&gt;ChangeSet&lt;/code&gt;.
     */
    public ChangeSet addTrivial(See see, String name, ChangePriority cp,
                                String... attributes) {
<span class="nc" id="L1790">        changes.add(new TrivialChange(see, name, cp.getPriority(), attributes));</span>
<span class="nc" id="L1791">        return this;</span>
    }

    // Conversion of a change set to a corresponding element.

    /**
     * Checks if a player can see a unit.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; looking for the unit.
     * @param unit The &lt;code&gt;Unit&lt;/code&gt; to check.
     * @return True if the &lt;code&gt;Unit&lt;/code&gt; is visible to the player.
     */
    private static boolean canSeeUnit(ServerPlayer serverPlayer, Unit unit) {
        Tile tile;
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        return (serverPlayer.owns(unit)) ? true</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            : ((tile = unit.getTile()) == null) ? false</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">            : (!serverPlayer.canSee(tile)) ? false</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            : (tile.hasSettlement()) ? false</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">            : (unit.isOnCarrier()) ? false</span>
<span class="nc" id="L1810">            : true;</span>
    }

    /**
     * Collapse one element into another.
     *
     * @param head The &lt;code&gt;Element&lt;/code&gt; to collapse into.
     * @param tail The &lt;code&gt;Element&lt;/code&gt; to extract nodes from.
     */
    private static void collapseElements(Element head, Element tail) {
<span class="nc bnc" id="L1820" title="All 2 branches missed.">        while (tail.hasChildNodes()) {</span>
<span class="nc" id="L1821">            head.appendChild(tail.removeChild(tail.getFirstChild()));</span>
        }
<span class="nc" id="L1823">    }</span>

    /**
     * Can two elements be collapsed?
     * They need to have the same name and attributes.
     *
     * @param e1 The first &lt;code&gt;Element&lt;/code&gt;.
     * @param e2 The second &lt;code&gt;Element&lt;/code&gt;.
     * @return True if they can be collapsed.
     */
    private static boolean collapseOK(Element e1, Element e2) {
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        if (!e1.getTagName().equals(e2.getTagName())) return false;</span>
<span class="nc" id="L1835">        NamedNodeMap nnm1 = e1.getAttributes();</span>
<span class="nc" id="L1836">        NamedNodeMap nnm2 = e2.getAttributes();</span>
<span class="nc bnc" id="L1837" title="All 2 branches missed.">        if (nnm1.getLength() != nnm2.getLength()) return false;</span>
<span class="nc bnc" id="L1838" title="All 2 branches missed.">        for (int i = 0; i &lt; nnm1.getLength(); i++) {</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">            if (nnm1.item(i).getNodeType() != nnm2.item(i).getNodeType()) {</span>
<span class="nc" id="L1840">                return false;</span>
            }
<span class="nc bnc" id="L1842" title="All 2 branches missed.">            if (!nnm1.item(i).getNodeName().equals(nnm2.item(i).getNodeName())) {</span>
<span class="nc" id="L1843">                return false;</span>
            }
<span class="nc bnc" id="L1845" title="All 2 branches missed.">            if (!nnm1.item(i).getNodeValue().equals(nnm2.item(i).getNodeValue())) {</span>
<span class="nc" id="L1846">                return false;</span>
            }
        }
<span class="nc" id="L1849">        return true;</span>
    }

    /**
     * Collapse adjacent elements in a list with the same tag.
     *
     * @param elements The list of &lt;code&gt;Element&lt;/code&gt;s to consider.
     * @return A collapsed list of elements.
     */
    private static List&lt;Element&gt; collapseElementList(List&lt;Element&gt; elements) {
<span class="nc" id="L1859">        List&lt;Element&gt; results = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">        if (!elements.isEmpty()) {</span>
<span class="nc" id="L1861">            Element head = elements.remove(0);</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">            while (!elements.isEmpty()) {</span>
<span class="nc" id="L1863">                Element e = elements.remove(0);</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">                if (collapseOK(head, e)) {</span>
<span class="nc" id="L1865">                    collapseElements(head, e);</span>
<span class="nc" id="L1866">                } else {</span>
<span class="nc" id="L1867">                    results.add(head);</span>
<span class="nc" id="L1868">                    head = e;</span>
                }
            }
<span class="nc" id="L1871">            results.add(head);</span>
        }
<span class="nc" id="L1873">        return results;</span>
    }

    /**
     * Build a generalized update.
     * Beware that removing an object does not necessarily update
     * its tile correctly on the client side--- if a tile update
     * is needed the tile should be supplied in the objects list.
     *
     * @param serverPlayer The &lt;code&gt;ServerPlayer&lt;/code&gt; to send the
     *            update to.
     * @return An element encapsulating an update of the objects to
     *         consider, or null if there is nothing to report.
     */
    public Element build(ServerPlayer serverPlayer) {
<span class="nc" id="L1888">        List&lt;Change&gt; c = new ArrayList&lt;&gt;(changes);</span>
<span class="nc" id="L1889">        List&lt;Element&gt; elements = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1890">        List&lt;Change&gt; diverted = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1891">        Document doc = DOMMessage.createNewDocument();</span>

        // For all sorted changes, if it is notifiable to the target
        // player then convert it to an Element, or divert for later
        // attachment.  Then add all consequence changes to the list.
<span class="nc" id="L1896">        Collections.sort(c, changeComparator);</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">        while (!c.isEmpty()) {</span>
<span class="nc" id="L1898">            Change change = c.remove(0);</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">            if (change.isNotifiable(serverPlayer)) {</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">                if (change.convertsToElement()) {</span>
<span class="nc" id="L1901">                    elements.add(change.toElement(serverPlayer, doc));</span>
<span class="nc" id="L1902">                } else {</span>
<span class="nc" id="L1903">                    diverted.add(change);</span>
                }
<span class="nc" id="L1905">                c.addAll(change.consequences(serverPlayer));</span>
            }
        }
<span class="nc" id="L1908">        elements = collapseElementList(elements);</span>

        // Decide what to return.  If there are several parts with
        // children then return multiple, if there is one viable part,
        // return that, if there is none return null unless there are
        // attributes in which case they become viable as an update.
        Element result;
<span class="nc bnc" id="L1915" title="All 3 branches missed.">        switch (elements.size()) {</span>
        case 0:
<span class="nc bnc" id="L1917" title="All 2 branches missed.">            if (diverted.isEmpty()) return null;</span>
<span class="nc" id="L1918">            result = doc.createElement(&quot;update&quot;);</span>
<span class="nc" id="L1919">            break;</span>
        case 1:
<span class="nc" id="L1921">            result = elements.get(0);</span>
<span class="nc" id="L1922">            break;</span>
        default:
<span class="nc" id="L1924">            result = new MultipleMessage(elements).toXMLElement();</span>
            break;
        }
<span class="nc" id="L1927">        result = (Element)doc.importNode(result, true);</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">        for (Change change : diverted) change.attachToElement(result);</span>
<span class="nc" id="L1929">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="nc" id="L1937">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1938">        Collections.sort(changes, changeComparator);</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">        for (Change c : changes) sb.append(c).append(&quot;\n&quot;);</span>
<span class="nc" id="L1940">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>net.sf.freecol.tools (2) (May 15, 2016 11:18:55 PM)</div></body></html>